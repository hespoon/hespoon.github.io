<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-hespoon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-hespoon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-hespoon.png">
  <link rel="mask-icon" href="/images/hespoon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hespoon.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":"//cdn.jsdelivr.net/gh/user/repo@version/file","lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="余大佬的面试经验  多刷算法题 啃《高级 Unix 编程》 掌握基本 Linux 知识 掌握常见的协议，如 http、tcp 之类的 网络安全，如 CSRF、XSS 项目经验会问项目设计相关内容 研究 LevelDB 用 C++ 实现一个 http 服务器 熟练使用 epoll 可以保证有话题聊 消息队列及常见消息中间件 问道不会的直接说不会，不会扣分 算法题最难到动态规">
<meta property="og:type" content="article">
<meta property="og:title" content="面试项目总结">
<meta property="og:url" content="http://hespoon.github.io/2020/01/13/%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Spirit">
<meta property="og:description" content="余大佬的面试经验  多刷算法题 啃《高级 Unix 编程》 掌握基本 Linux 知识 掌握常见的协议，如 http、tcp 之类的 网络安全，如 CSRF、XSS 项目经验会问项目设计相关内容 研究 LevelDB 用 C++ 实现一个 http 服务器 熟练使用 epoll 可以保证有话题聊 消息队列及常见消息中间件 问道不会的直接说不会，不会扣分 算法题最难到动态规">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006XJF4Oly1gc494izextj30u00fymyi.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006XJF4Oly1gc5xu6v526j30u00iymyj.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006XJF4Oly1gc5y87dgrrj30u00rzgo7.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006XJF4Oly1gc639pr8n0j30ku0ofdi6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006XJF4Oly1gc63hpi46qj30u00m1ab3.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006XJF4Oly1gc646iatulj30u00gtwfz.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006XJF4Oly1gc648lr2d9j30u00am75m.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006XJF4Oly1gc785harqgj30u00itn3s.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006XJF4Oly1gc79ecgev5j30u00rmwi5.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006XJF4Oly1gbq9oo19c7j30u00gwgn8.jpg">
<meta property="article:published_time" content="2020-01-13T11:06:42.000Z">
<meta property="article:modified_time" content="2020-03-25T13:41:49.011Z">
<meta property="article:author" content="hespoon">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/006XJF4Oly1gc494izextj30u00fymyi.jpg">

<link rel="canonical" href="http://hespoon.github.io/2020/01/13/%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>面试项目总结 | Spirit</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Spirit</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hespoon" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/01/13/%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试项目总结<a href="https://github.com/hespoon/my-blog/tree/master/source/_posts/%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93.md" class="post-edit-link" title="Edit this post" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 19:06:42" itemprop="dateCreated datePublished" datetime="2020-01-13T19:06:42+08:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-25 21:41:49" itemprop="dateModified" datetime="2020-03-25T21:41:49+08:00">2020-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="余大佬的面试经验">余大佬的面试经验</h1>
<ul>
<li>多刷算法题</li>
<li>啃《高级 Unix 编程》</li>
<li>掌握基本 Linux 知识</li>
<li>掌握常见的协议，如 http、tcp 之类的</li>
<li>网络安全，如 CSRF、XSS</li>
<li>项目经验会问项目设计相关内容</li>
<li>研究 LevelDB</li>
<li>用 C++ 实现一个 http 服务器</li>
<li>熟练使用 epoll 可以保证有话题聊</li>
<li>消息队列及常见消息中间件</li>
<li>问道不会的直接说不会，不会扣分</li>
<li>算法题最难到动态规划</li>
<li>每一面都会问算法问题</li>
</ul>
<h1 id="计算机网络">计算机网络</h1>
<ul>
<li><p>TCP 协议 Transmission Control Protocol</p></li>
<li><p>TCP 是传输层的协议，解决传输的可靠、有序、无丢失和不重复。</p></li>
<li><p>面向连接的，每条 TCP 连接只有两个端点</p></li>
<li><p>全双工通信，通信双发在任何时候都能发送数据，有缓存，用于临时存放双向通信数据</p></li>
<li><p>面向字节流，TCP 将应用程序交付的数据视为一串无结构的字节流</p></li>
<li><p>TCP 首部最短 20B。</p>
<ul>
<li>源端口，目的端口各占 2B。</li>
<li>序号字段 4B，每个字节都会编号。</li>
<li>确认字段 4B，是期望收到的报文段数据的第一个字节的序号</li>
<li>数据偏移，4 位。单位是 4B。表示首部的长度</li>
<li>保留字段 6 位</li>
<li>6 个状态位。URG 紧急位、ACK 确认位、PSH 推送位、RST 复位位、SYN 同步位、FIN 终止位</li>
<li>窗口字段。指出现在允许对方发送的数据量，单位为字节。</li>
<li>校验和。 2B，校验首部和数据两部分，计算时要加上伪首部。</li>
<li>紧急字段指针，2B。指出本报文段中紧急数据共有多少字节。</li>
<li>选项字段，长度可变。</li>
<li>填充字段。使头部的长度为 4B 的整数倍。</li>
</ul></li>
<li><p>建立连接的 3 次握手</p>
<ul>
<li>SYN=1，seq=x，不含应用层数据，消耗一个序号</li>
<li>SYN=1，ACK=1，ack=x+1，seq=y，不含应用层数据，消耗一个序号，服务器为连接分配资源，因此易受 SYN 洪泛攻击</li>
<li>ACK=1，seq=x+1，ack=y+1，可以开始携带应用层数据，客户端为连接分配资源</li>
<li>为何要三次握手？为了解决网络中存在延迟的重复分组。比如，客户端发送了一个连接请求，但在网络中长时间的滞留了，以至于延迟到连接结束后的某个时间到达了服务器。服务器会误以为这是一个新的连接请求，然后响应该请求并发出确认，为连接分配资源。如果不采用三次握手，客户端不理睬服务器的确认，不会向服务器传输数据，因此服务器的资源就被浪费了。</li>
</ul></li>
<li><p>断开连接的 4 次挥手</p>
<ul>
<li>FIN=1，seq=u，客户端主动请求断开连接</li>
<li>ACK=1，seq=v，ack=u+1，此时客户端到服务器的连接已经释放了，TCP 处于半关闭状态，服务器发送数据，客户端依旧要接收。客户端不能发送数据，但可以发送确认报文。</li>
<li>FIN=1，ACK=1，seq=w，ack=u+1，此时服务器请求释放连接</li>
<li>ACK=1，seq=u+1，ack=w+1，客户端收到服务器发来的连接释放报文后，必须要发出确认，然后等待 2 个报文最大生存时间后关闭连接。服务器端在接受到客户端的确认报文后就断开连接。</li>
<li>为何要四次挥手？ 因为在客户端主动要求断开连接后，服务器端还可能存在需要发送的数据，要等这些数据发送完后，再断开 TCP 连接。</li>
<li>为何要有 TIME_WAIT 阶段 因为客户端在发送确认报文后，服务器端可能没有收到，此时服务器会再次发送请求断开连接的报文，客户端应当保持 TCP 连接一段时间，以便保证服务器端收到了自己的确认报文。同时，TCP 连接占用了一个套接字，连接释放后，该套接字会被其他连接重复使用。若没有 TIME_WAIT 状态，网络中可能还存在当前连接产生的报文，连接释放后，旧的报文可能会被新的连接接收，造成信息混乱。因此，TIME_WAIT 状态主要是保证当前连接产生的报文在网络中已经全部消失了。</li>
</ul></li>
<li><p>TCP 可靠传输</p>
<ul>
<li>TCP 通过校验机制保证传输的报文段没有差错</li>
<li>TCP 通过首部的序号字段保证数据能够有序的提交给应用层，对每个字节进行编号，同时会丢弃重复数据。</li>
<li>TCP 通过首部的确认号表示期望收到的下一报文段数据的第一个字节的序号，发送方会在缓存中存储那些已经发送但未确认的报文段，以便在需要时重传。使用累计确认</li>
<li>TCP 重传。
<ul>
<li>超时重传 TCP 为每一个发送的报文段都设置一个计时器。计时器设置的重传时间到期但还没有收到确认，就要重传这一报文段。超时重传时间 RTO，加权平均往返时间 RTTs，RTT 的偏差的加权平均值 RTTd。RTO = RTTs + 4 × RTTd，RTTs = ( 1 - α ) × 旧 RTTs + α × 新 RTT 样本，RTTd = ( 1 - β ) × 旧 RTTd + β × |RTTs - 新 RTT 样本|。α 和 β 都是小于 1 大于 0 的系数。第一个 RTTs 等于测量到的 RTT，第一个 RTTd 等于测量到的 RTT 的值的一半。</li>
<li>冗余 ACK 发送方可以通过冗余 ACK 来检测丢包情况。TCP 规定，每当接收方收到比期望序号大的失序报文段时，就发送一个冗余 ACK，指明下一个期待字节的序号。当发送方收到对同一报文段的三个冗余 ACK 时，就认为该报文段已经丢失。冗余 ACK 也用在了拥塞控制中。</li>
</ul></li>
</ul></li>
<li><p>TCP 流量控制</p>
<ul>
<li>TCP 提供一种基于滑动窗口协议的流量控制机制。</li>
<li>接收方根据自己缓存的大小，动态调整接收窗口的大小，就是调整头部中的窗口字段。限制发送方的发送速率。</li>
<li>发送方根据当前网络的拥塞情况调整拥塞窗口的大小。发送方的发送窗口取接收窗口和拥塞窗口两者中的最小值。</li>
</ul></li>
<li><p>TCP 拥塞控制</p>
<ul>
<li>两个窗口，接收窗口和拥塞窗口。发送窗口 = min(接受窗口，拥塞窗口)</li>
<li>四种算法，慢开始、拥塞避免、快重传、快恢复。四种算法是用来维护拥塞窗口的。
<ul>
<li>慢开始。刚开始发送报文段时，令拥塞窗口 = 1，即一个最长报文段的大小。每收到一个对新报文段的确认后，将拥塞窗口的值加 1，就是增大一个 MSS。一般每经过一个传输轮次，拥塞窗口的大小就会翻倍。慢开始一直把拥塞窗口增加到一个阈值后，就改用拥塞避免算法。</li>
<li>拥塞避免。发送端的拥塞窗口每经过一个 RTT 就增加 1，就是开始线性增加。</li>
<li>网络拥塞处理
<ul>
<li>超时 当发送方检测到超时时，就将慢开始阈值设为当前拥塞窗口大小的一半，但不能小于 2，并将拥塞窗口的大小设为一个 MSS。然后开始执行慢开始算法。这样可以快速减少发送方发到网络中的分组数。</li>
</ul></li>
<li>快重传 当发送方连续收到三个冗余 ACK 时，就直接重传接收方未收到的报文段，不用等到超时。</li>
<li>快恢复 当发送方收到三个冗余 ACK 时，就将慢开始阈值设为当前拥塞窗口的一半，将拥塞窗口设为改变后的慢开始阈值，然后执行拥塞避免算法。</li>
</ul></li>
</ul></li>
<li><p>UDP 协议，User Datagram Protocol</p></li>
<li><p>UDP 的优点</p>
<ul>
<li>UDP 无需建立连接，所以没有建立连接带来的延时，速度比较快。</li>
<li>UDP 不用维护连接状态，就是说不用维护发送接收缓存，不用记录确认序号和拥塞控制参数，消耗的资源就小一些。</li>
<li>分组头部开销小，只有 8B。</li>
<li>发送方的应用层能够更好的控制要发送的数据和发送时间。因为 UDP 没有拥塞控制，所以网络中的拥塞不会影响发送方的发送效率。</li>
</ul></li>
<li><p>UDP 应用</p>
<ul>
<li>一次性传输数据较少的应用。比如 DNS。</li>
<li>多媒体应用。比如实时视频会议。可靠的数据传输对这些应用来说不是最重要的。</li>
</ul></li>
<li><p>UDP 不保证可靠交付，数据的可靠性要通过应用层来完成。</p></li>
<li><p>UDP 面向报文，将应用层传下来的报文添加首部后就交给网络层，将网络层传上来的报文去除首部后就交给应用层。</p></li>
<li><p>UDP 数据报首部</p>
<ul>
<li>2B 的源端口号。需要对方回复时才会使用。</li>
<li>2B 的目的端口号。</li>
<li>2B 的长度标记，单位为 1B</li>
<li>2B 的校验和。是可选的。计算校验和时要在数据报之前添加 12B 的伪首部。校验整个数据报。</li>
</ul></li>
<li><p>TCP 与 UDP 的区别</p>
<ol type="1">
<li>TCP 是有连接的，UDP 是无连接的</li>
<li>TCP 是可靠的，UDP 是不可靠的。接收方不会对 UDP 报文发送确认报文。</li>
<li>TCP 是面向字节流的，UDP 是面向报文的。TCP 发送报文时以字节为单位，应用层传来的数据报可拆分。UDP 不能拆分数据报。</li>
<li>TCP 有拥塞控制机制，UDP 没有。</li>
<li>TCP 首部开销大，UDP 首部开销小。</li>
<li>UDP 不需要维护连接状态，消耗资源小。</li>
<li>TCP 只支持点对点通信。UDP 可以一对一、一对多、多对一、多对多</li>
</ol></li>
<li><p>如何选择 TCP 与 UDP 对实时性要求高，对可靠传输要求低时，一般选用 UDP。比如 DNS 服务，直播。对可靠性要求高时用 TCP。HTTP 协议一般都用 TCP。HTTP3 使用了基于 UDP 协议的QUIC 协议。可能是因为现在网络环境越来越好了吧，设备本身越来越可靠，协议上就可以偷些懒。</p></li>
<li><p>TCP 粘包</p>
<ul>
<li>指发送方发送的若干数据包在到达接收方时粘成了一包。从接收方缓存来看，后一包数据的头紧挨着前一包数据的尾。如果粘包是同一数据的不同部分，可以不处理。如果粘包之间没有关系，此时就必须要使用合理的拆包机制将包分开。</li>
<li>粘包原因
<ol type="1">
<li>发送方默认使用 Nagle 算法，将多次间隔较小，数据量较小的数据报合并成一个数据量大的数据报发送，用于减少网络中的报文段，尽可能的利用网络带宽。</li>
<li>接收方读取接收缓存的速度比 TCP 写入缓存的速度慢。</li>
</ol></li>
<li>解决方法
<ul>
<li>发送方可以尝试关闭 Nagle 算法。接收方可以在应用层处理。将接收缓存的数据全部读完后，再分组。可以通过开始符和结束符的方式分组，也可以在数据报数据部分的开始部分记录数据的长度。</li>
</ul></li>
</ul></li>
<li><p>HTTP HyperText Transfer Protocol</p>
<ul>
<li>HTTP 使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li>
<li>HTTP 是专门用来在两点之间传输数据的约定和规范</li>
<li>超文本就是指超越了普通文本，包含有图片、音频、视频和超链接</li>
<li>HTTP 由两个程序实现，一个客户端程序，一个服务器程序。</li>
<li>URL 地址包含两部分，存放文件的服务器地址和文件的存放路径</li>
<li>HTTP 使用 TCP 作为传输协议，应用通过套接字接口将 HTTP 请求发给 TCP 连接，同时也从套接字接口中接受响应信息。</li>
<li>持续连接。客户端与服务器在一个相当长的时间范围内通信时，所有的请求和相应都通过一个 TCP 连接发送，这种模式称为持续连接。</li>
<li>非持续连接。客户端与服务器在一个相当长的时间范围内通信时，每个请求和相应都通过一个单独的 TCP 连接发送。</li>
<li>HTTP 默认使用持续连接，也可以使用非持续连接。</li>
<li>HTTP 客户端进程运行在 80 号端口。</li>
<li>非持续连接中的 TCP 连接可以是串行的也可以是并行的。</li>
<li>HTTP 有两种报文，请求报文和相应报文。HTTP 的报文是明文传输。是无状态的，服务器不会记录客户端的任何信息。
<ul>
<li>请求报文
<ul>
<li>请求报文的第一行叫做请求行，后续的行叫做首部行。</li>
<li>请求行包含三个字段。方法字段、URL 字段和 HTTP 版本字段。</li>
<li>首部行 Host 指明了对象所在的主机</li>
<li>首部行 Connection 指明了是使用持续连接还是非持续连接</li>
<li>首部行 User-agent 指明了用户代理，即向服务器发送请求的浏览器的类型</li>
<li>Content-Length 字段，表明本次回应的数据长度。</li>
<li>Accept 字段用于声明可接受的数据格式。</li>
<li>Accept-Encoding 声明可接受的压缩方式</li>
<li>首部行后有一个空行。空行后是请求的实体。</li>
<li>GET 方法用与获取服务器内容，向服务器传递的参数加在 URL 中，只允许 ASCII 字符，有长度限制。请求的实体为空。</li>
<li>GET 方法是安全的和幂等的。 幂等是指，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。 安全是指，请求方法不会破坏服务器上的资源。</li>
<li>POST 方法一般用来向指定的资源提交数据进行处理请求，如上传表单和文件。数据包含在请求体中。</li>
<li>POST 方法是不安全和不幂等的。</li>
<li>HEAD 方法用于向服务器索要与 GET 请求相一致的响应，但是响应体不返回，只返回响应消息的头部。</li>
<li>PUT 方法用于向指定资源位置上传其最新内容，是幂等的。</li>
<li>DELETE 方法用于删除 URL 所标识的资源。</li>
</ul></li>
<li>响应报文
<ul>
<li>第一行是状态行。包含 HTTP 版本，状态码和状态描述</li>
<li>接下来每一行都表示一个 HTTP 首部，为客户端提供关于所发送数据的一些信息，并以一个空行结束</li>
<li>Content-Type 字段用于说明本次数据是什么格式。</li>
<li>Content-Encoding 说明数据的压缩方式</li>
<li>最后是数据块，包含了响应数据</li>
<li>200 OK 表示请求成功</li>
<li>302 Found 临时重定向</li>
<li>404 Not Found 请求失败，所请求的资源未在服务器上找到</li>
</ul></li>
</ul></li>
<li>HTTP 常见状态码</li>
</ul>
<ol type="1">
<li>1xx 状态码 信息，服务器收到请求，需要请求者继续执行操作。100 Continue 继续、101 Switching Protocols 切换协议，只能切换到更高级的协议</li>
<li>2xx 状态码 操作成功。200 OK 请求成功、204 No Content 请求成功，但是响应报文的 body 部分没有数据</li>
<li>3xx 状态码 重定向。301 Moved Permanently 永久重定向、302 Found 临时移动、304 Not Modify 资源未修改，重定向至缓存文件。</li>
<li>4xx 状态码 客户端错误。400 Bad Request 客户端请求语法错误、401 Unanuthorized 请求用户的身份认证、403 Forbidden 服务器拒绝执行、404 Not Found 服务器未找到客户端请求的资源</li>
<li>5xx 状态码 服务端错误。500 Internal Server Error 服务器内部错误、501 Not Implemented 服务器不支持请求的功能、502 Bad GateWay 网关或代理服务器执行请求时，从远程服务器接收到了一个无效响应。</li>
</ol>
<ul>
<li><p>HTTP 重定向 URL 重定向，也称 URL 转发，是一种当前实际资源，如页面，表单等迁移到新的 URL 下的时候，保持原有链接可用的技术。HTTP 使用 HTTP 重定向来执行此类操作。可以用于网站维护期间的临时跳转或者网站架构改变后为保持外部链接继续可用的永久重定向。 重定向操作由服务器发送特殊的响应而触发，状态码是 3xx。浏览器接受到重定向响应后，会采用响应提供的新的 URL，并立即加载。 永久重定向：表示原 URL 不再使用，应优先选用新的 URL。 临时重定向：资源无法从其标准的地址访问，却可以从另外的地方访问。搜索引擎不会记录这个新的、临时的链接。临时重定向也可以用来显示临时性质的进度页面。 特殊重定向：304 Not Modified 资源未修改，会使页面跳转到本地缓存的版本中。300 Multiple Choice 是一种手工重定向，以 Web 页面的形式呈现消息主题包含的一个可能的重定向链接列表，用户可以从中选择。</p></li>
<li><p>HTTPS</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw" target="_blank" rel="noopener">GoLang：你真的了解 HTTPS 吗？</a></li>
<li>运行在 SSL （Secure Sockets Layer 安全套接层 位于传输层和应用层之间）上，添加了加密和认证机制，更加安全。</li>
<li>HTTPS = HTTP over SSL/TLS，也就是说，HTTPS 在传输层 TCP 和应用层 HTTP 之间多了一层 SSL/TLS。SSL/TLS 协议作用在传输层和应用层之间，对应用数据进行加密传输。</li>
</ul>
<figure>
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc494izextj30u00fymyi.jpg" alt="" /><figcaption>STL+TSL.jpg</figcaption>
</figure>
<p>SSL，全称 Secure Socket Layer，在 1994 年由网景公司最早提出。TLS，全称 Transport Layer Security，在 1999 年基于 SSL3.0 版本上改进而来的。官方建议启用 SSL 而保留和采用 TLS。</p>
<ul>
<li>HTTPS 三大优势：数据加密，防窃听；身份验证，防冒充；完整性校验，防篡改。</li>
<li>通信需要证书，一般是向证书颁发机构购买。证书就是一个公钥和一个私钥。</li>
<li>首先建立 TCP 连接。然后客户端向服务器发送客户端支持的一套加密规则</li>
<li>服务器从中选取出一组加密算法与 Hash 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里包含了网站地址，加密公钥，和证书的颁发机构等信息。</li>
<li>客户端验证服务器的合法性</li>
<li>如果证书受信任，或者客户端接受了不受信任的证书，浏览器会生成一个随机密钥，并用服务器提供的公钥加密。使用 Hash 算法对握手消息进行摘要计算，并对摘要使用之前产生的随机密钥加密。然后，将加密后的随机密钥和摘要发给服务器。</li>
<li>服务器用自己的私钥解开被加密的随机密钥，并用随机密钥解出被加密的 Hash 摘要，验证握手信息是否一致。如果一致，则服务器使用获得的随机密钥加密握手消息发给客户端。</li>
<li>客户端解密并验证摘要，若一致，则握手结束，以后发送的数据都使用该随机密钥进行对称加密。</li>
<li>证书公钥用于加密在握手过程中生成的随机密钥，随机密钥用于加密真正传输的数据，Hash 算法用于验证数据的完整性。</li>
<li>对称加密，加密和解密使用同一个的密钥。</li>
<li>非对称加密，需要两个密钥，公钥和私钥。使用公钥加密的内容用私钥才能解开。</li>
</ul></li>
<li><p>SSL/TLS 连接建立过程</p>
<ol type="1">
<li>ClientHello</li>
<li>SeverHello</li>
<li>客户端回应</li>
<li>服务器最后回应</li>
</ol></li>
<li><p>HTTPS 为什么同时需要有对称加密和非对称加密两种加密方式？ 对称加密的加密和解密使用的是同样的密钥，所以速度快，但密钥需要在网络中传播，所以安全性不高。 非对称加密使用了一对密钥，公钥和私钥，安全性高，但是加密与解密速度慢。 两者结合起来，可以结合双方的优点，摒弃双方的缺点。即，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双发可以使用对称加密来进行沟通。 HTTPS 最开始就是这样做的。HTTPS 既有非对称加密也有对称加密。对称加密的性能高速度快，因此在数据传输时使用对称加密。对称加密使用的密钥 SK 是在对话前通过网络协商生成的。为了确保 SK 的安全，使用非对称加密来协商 SK。</p></li>
<li><p>HTTPS 对称加密的密钥 SK 如何产生？ HTTPS 分为两个阶段：</p>
<ol type="1">
<li>协商对称加密密钥 SK 的非对称加密阶段，称为 TLS 握手阶段。</li>
<li>使用 SK 对数据进行对称加密的阶段，称为数据通信阶段。 HTTPS 协商对称加密密钥 SK 的办法有很多种，其中三种最常见的为：</li>
<li>基于非对称加密算法</li>
<li>基于专用密钥交换算法，常见的有 DH，ECDH 等</li>
<li>基于共享的 secret，常见的有 PSK，SRP 等</li>
</ol></li>
<li><p>非对称加密 RSA 协商密钥的办法，是 HTTPS 最早的办法，其过程如下：</p>
<figure>
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc5xu6v526j30u00iymyj.jpg" alt="" /><figcaption>RSA 协商密钥.jpg</figcaption>
</figure>
<ol type="1">
<li>客户端给服务端发送请求</li>
<li>服务端将自己的公钥 PuK 返回给客户端</li>
<li>客户端生成本次对话的对称密钥 SK，并用 PuK 进行加密得到 SK_Enc 后传给服务端</li>
<li>服务端收到 SK_Enc 后用自己的私钥 PrK 解密得到 SK；若成功，则返回客户端 OK，否则终止对话。</li>
<li>接下来，客户端和服务端的对话均用 SK 加密后传输。 这种方法存在中间人攻击的问题，同时，服务端的私钥 PrK 泄露后，HTTPS 的加密也就不安全了。</li>
</ol></li>
<li><p>密钥交换算法。DH 和 ECDH 协商密钥算法的大致过程如下：</p></li>
</ul>
<figure>
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc5y87dgrrj30u00rzgo7.jpg" alt="" /><figcaption>DH ECDH 密钥协商.jpg</figcaption>
</figure>
<p>ECDH 算法中的 A 和 B，也别称为 PreMaster-Secret。最终协商得到的密钥 SK 被称为 Master Secret，也被称为 Session Key。 ECDH 比 DH 算法更快，并且 ECDH 比 DH 更难破解，可行性更好。</p>
<ul>
<li><p>基于共享的 secret 这列做法就是在客户端和服务端预设好对称加密的密钥，握手阶段只需要传递类似钥匙 id 即可。代表算法有 PSK。</p></li>
<li><p>HTTPS 有几套非对称加密？目的是什么？是否可以省略？ 有两套非对称加密。 一套用于协商对称加密密钥，一套用于数字证书签名加密。 前者是服务器端产生的，私钥在服务器上。后者是 CA 机构产生的，私钥在 CA 机构那里。 两套都不应当省略。</p></li>
<li><p>HTTPS 的证书</p></li>
</ul>
<p>CA、CA 机构：Certificate Authority 机构/组织概念 数字证书、（CA）证书、HTTPS 证书、SSL/TLS 证书：CA 签发的数字证书。 数字签名、证书指纹：CA 签发的证书的内容之一，一段加密的密文。 数字证书用于主体身份验证。 数字证书 = 主体信息 + 数字签名 一张完整的数字证书包括： 1. 主体的必要信息：版本、序列号、签名算法、颁发者、有效期、使用者、公钥信息 2. 主体的扩展信息：密钥标识符、证书策略 如下图：</p>
<figure>
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc639pr8n0j30ku0ofdi6.jpg" alt="" /><figcaption>数字证书.jpg</figcaption>
</figure>
<center>
<p>数字证书</p>
</center>
<p>数字证书用于防范中间人攻击。</p>
<ul>
<li>HTTPS 中间人攻击及防范</li>
</ul>
<p>中间人攻击 MITM（Man-in-the-middle attack）</p>
<figure>
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc63hpi46qj30u00m1ab3.jpg" alt="" /><figcaption>中间人攻击.jpg</figcaption>
</figure>
<center>
<p>中间人攻击</p>
</center>
<p>中间人攻击是指攻击者与通讯的两端分别建立独立的连接，并交换其收到的数据，使通讯的两端认为他们正在通过一个私密的连接接与对方通讯，但事实上整个会话都被攻击者 控制。攻击者可以截通讯双方的通话并插入新的内容。</p>
<p>客户端请求与服务器发起 HTTPS 通信，信息被中间人获取。服务器把自己的公钥发给客户端，信息被中间人获取，中间人将公钥改为自己的公钥，再发给客户端。客户端收到 公钥，生成随机密钥并用公钥加密随机密钥，然后发给服务器。信息被中间人获取，中间人自己的私钥解密获得随机密钥。现在中间人有服务器的公钥和客端产生的随机密钥。 中间人将随机密钥用服务器的公钥加密，再给服务器。服务器用自己的私钥解密，获得随机密钥。以后客户与服务器的通信都通过随机密钥加密，而中间人有随机密钥，所以中 间人可以获得所有的通信信息。</p>
<p>防范中间人攻击，就是要保证通信中的信息来自正确的发送者且没被修改过。保证客户端收到的信息来自服务器，保证服务器到的信息来自客户端，保证中间没有一个家伙能查 看并修改信息。</p>
<p>可以通过数字签名来保证某段信息确实来自它所声称的那个体。比如，服务器在产生要发送的消息后，通过 Hash 算法计摘要，然后用自己的私钥加密摘要，生成数字签名。消 息接受者到信息和数字签名后，使用同样的 Hash 算法计算信息摘要，用公钥解密数字签名获得服务器端发来的摘要。比对两个摘要查是否一致。如果一致，可以保证信息来自 对方且没被修改过。但这种方式依旧可以被中间人攻击，中间人可以在会话建立阶段将方交换公钥换为自己的公钥，获取双方计算信息摘要的 Hash 法。这样中间人依旧可以修 改信息而不被发现。</p>
<p>为了解决这个问题，通信双方需要找一个双方都信任的第三方为双方确认身份。就是向数字证书机构购买数字证书。</p>
<ul>
<li>数字证书如何工作？</li>
</ul>
<p>这需要从两个角度来说明： 申请证书，即需要被验证身份的一端，需要申请一份能够验证自己身份的证书 验证证书，即需要验证对方身份的一端，拿到证书后验证对端的身份。 这张证书必须是由权威 CA 机构颁发的，且尚在有效期内，或者是一张受信任的私人证书。</p>
<p>申请证书 申请证书的过程：用户向 CA 机构提交自己的信息（如域名）和公钥（用户自己生成的非对称加密公钥，用于 TLS 握手阶段和另一端协商密钥），CA 机构生成数字证书，如下图：</p>
<figure>
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc646iatulj30u00gtwfz.jpg" alt="" /><figcaption>申请证书.jpg</figcaption>
</figure>
<center>
<p>申请证书</p>
</center>
<p>验证证书 收到对端发来的证书，执行证书申请的“逆过程”即可，如下图：</p>
<figure>
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc648lr2d9j30u00am75m.jpg" alt="" /><figcaption>验证证书.jpg</figcaption>
</figure>
<center>
<p>验证证书</p>
</center>
<p>接受证书的一端先对除数字签名的其他部分使用证书中指明的哈希算法计算一次哈希值，记作 H1；获取 CA 机构的公钥对数字签名属性做解码，得到了 CA 机构计算出来的哈希值，记作 H2.对比 H1 和 H2 是否严格相等。若是，则代表该证书的信息未被篡改，证书有效；否则，证书无效。</p>
<p>CA 机构的公钥如何获取？ 答案是提前内置。 操作系统和浏览器在软件安装阶段会在其特定目录下放置一堆证书。 查看 win10 的内置证书命令：win+R 然后输入 certmgr.msc 这些证书都是权威 CA 机构颁发的根证书（Root Certificate）。 根证书有如下几个特点：</p>
<ul>
<li>没有上层机构再为其本身作数字签名</li>
<li>证书上的公钥即为 CA 机构发布的公钥</li>
<li>权威 CA 机构的自签证书</li>
</ul>
<p>本地内置了这么多根证书，那要怎么知道我这份证书应该要用哪个根证书来验证呢？ 通过证书信任链。 证书信任链上有 3 类证书：根证书、中介证书和用户证书。 根证书就是前面提到的，内置在浏览器和操作系统中的证书。用户证书就是对端发过来的证书，是用户向权威 CA 机构绑定了自己身份（主要指域名）和自己公钥的证书。中介证书可以理解为由权威 CA 机构委派的代理机构签发的数字证书。中介证书或说中介机构的存在是为了保证根证书密钥的安全性。 从用户证书寻找根证书的过程，是一个在树形结构中，从叶子节点搜索根节点的过程。</p>
<figure>
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc785harqgj30u00itn3s.jpg" alt="" /><figcaption>搜索根证书.png</figcaption>
</figure>
<center>
<p>搜索根证书</p>
</center>
<ul>
<li>完整性校验：HTTPS 的哈希 HTTPS 的哈希用在两个地方：</li>
</ul>
<ol type="1">
<li>证书的数字签名 这里使用哈希的主要目的是减少非对称加密算法在文本上的开销。</li>
<li>对称加密的 Message Digest 在数据通信阶段，SSL/TLS 会对原始消息做一次哈希，的到该消息的摘要，称为消息摘要。对端接受到消息后，使用协商出来的对称加密密钥解密数据包，得到原始信息。接着也做一次相同的哈希算法得到摘要，对比发送过来的消息摘要和计算出的消息摘要是否一致，可以判断通信数据是否被篡改。</li>
</ol>
<ul>
<li>HTTPS 的通信流程</li>
</ul>
<figure>
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc79ecgev5j30u00rmwi5.jpg" alt="" /><figcaption>HTTPS的通信流程.jpg</figcaption>
</figure>
<ul>
<li>如何由 www.example.com 跳转至 https://www.example.com</li>
</ul>
<p>如果网站启用了 HTTPS，则服务器会将这个请求使用 301 永久重定向或者 302 临时重定向将请求从 HTTP 的 80 端口重定向到 HTTPS 的 443 端口。 此时，如果中间人劫持了使用者的网络请求，那么中间人可以阻止客户端与服务器建立 HTTPS 连接，而一直使用 HTTP 连接，而中间人则和服务器建立正常的 HTTPS 连接，让客户端以为自己在和真正的服务器通信，这种攻击手法称为 SSLTrip。</p></li>
<li><p>Session 与 Cooike 的区别 Session 是服务器保持状态的方法，Cooike 是客户端保持状态的方法。 Cooike 是本地机器存储的一个小段文本，并随着每一个请求发送至同一个服务器。服务器通过 HTTP 头向客户端发送 Cooike。在客户端，浏览器解析这些 Cooike 并把它们保存为一个本地文件，浏览器会自动的将向同一服务器发送的任何请求上附加这些 Cooike。 Cooike 是用户端的会话状态保存机制。Cooike 的作用是为了解决 HTTP 协议无状态的缺陷。 Cooike 的主要内容包含：名字、值、过期时间、路径和域。路径和域一起组成 Cooike 的作用范围。如果不设置过期时间，则表示 Cooike 的生命周期为浏览器的会话期间，关闭浏览器，Cooike 就消失，这种 Cooike 被称为会话 Cooike，一般存放在内存中。若设置了过期时间，浏览器就会把 Cooike 保存到硬盘上，关闭后再次打开浏览器，这些 Cooike 依旧有效直到超过设定的过期时间。 Session 机制采用的是在服务器端保持状态的解决方案。由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以 Session 机制可能需要借助 Cooike 机制来达到保存状态的目的。 Session 是针对每一个用户的，Session 的值保存在服务器端，使用 SessionID 来区分用户。SessionID 是一个不容易被找到规律的字符串，用来防止仿造。 服务器接受到客户端的请求时，会检查请求中是否包含一个 SessionID，如果包含，则服务器会通过 SessionID 检索 Session，如果检索不到则会新建一个。如果客户端请求中不包含 SessionID，则服务器为次客户端创建一个 Session 并生成一个与该 Session 关联的 SessionID，SessionID 会在本次响应中返回给客户端。 保存这个 SessionID 的方式可以使用 Cooike。当客户端禁止使用 Cooike 时，可以采用 URL 重写的技术，把 SessionID 直接附加在 URL 的路径后，类似于 URL 的参数。还有一种技术称为表单隐藏字段，服务器自动修改表单，增加一个隐藏字段，以便表单在提交时能够把 SessionID 传递给服务器。 Cooike 中只能保存 ASCII 字符串，如果需要存放 Unicode 字符或者二进制数据，则需要先进行编码。因此存储较复杂的状态，使用 Cooike 是比较困难的。 Session 中能存放任何类型的数据，使用起来比较方便。 Cooike 中的信息存放在客户端，因此最好不要存放一些敏感信息，比如帐号密码，因为一些客户端的不良程序可能会窥探甚至修改 Cooike 中的内容。也可以对 Cooike 加密，提交到服务器后再解密。 Session 在服务器端，保存隐私信息很方便。 Cooike 可以设置一个长时间的有效期，来保持状态一直有效，比如保持登陆。 Session 一般依赖一个会话 Cooike，浏览器关闭后，该 Session 就失效了。而且 Session 一般不应维持较长的有效期，因为这样会对服务器带来较大的压力。并且，Session 不适用于访问量超高的网站，因为这种网站使用 Session 保存状态的话，会消耗大量服务器资源。 Cooike 存放在客户端，如果网站的并发量超大，一般都采用 Cooike 保存状态。 Cooike 的有效时间，有效位置容易设置，Session 就不行。 Cooike 支持跨域名访问。Session 不支持跨域名访问。</p></li>
<li><p>session 的实现 session 由三个组件配合完成，分别为 <code>Manager</code>、<code>Provider</code> 和 <code>Session</code> 这三个类。</p></li>
</ul>
<p>下图是一个 HTTP 请求的完整流程</p>
<figure>
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbq9oo19c7j30u00gwgn8.jpg" alt="" /><figcaption>http的请求过程.jpg</figcaption>
</figure>
<ol type="1">
<li>Handler 函数用于接收请求，解析 HTTP header 中的 cooike，得到 SessionID，然后把 SessionID 发给 Manager。</li>
<li>Manager 充当一个 Session 管理器的角色，主要用于存储配置信息。比如：session 的存活时间，Cooike 的名字等。Manager 将 SessionID 接着发给 Provider。</li>
<li>Provider 是一个容器，一般是一个散列表，将每个 SessionID 和 Session 的对应关系存储起来。</li>
<li>Session 中存放用户的具体信息，一般是一个散列表。</li>
</ol>
<ul>
<li><p>Cross-Origin Resource Sharing（CORS）跨域资源共享 一般是指，一个域下的文档或脚本试图请求另一个域下的资源。</p></li>
<li><p>从输入 URL 到获得页面的过程</p>
<ul>
<li>浏览器查询 DNS。浏览器自己的 DNS 缓存，本地 Host 文件，操作系统的 DNS 缓存，本地 DNS 服务器，递归查询或迭代查询</li>
<li>浏览器获得 IP 地址后，向服务器建立 TCP 连接。</li>
<li>TCP 连接建立后，浏览器向服务器发送 HTTP 请求。</li>
<li>服务器响应 HTTP 请求。</li>
<li>浏览器不断请求资源，最终渲染出整个页面。</li>
</ul></li>
<li><p>网络层</p></li>
<li><p>功能：互联异构网络、路由与转发、拥塞控制</p>
<ul>
<li>异构网络：好多个网络，各个网络由不同厂家生产的计算机组成，使用了不同的协议。</li>
<li>路由与转发：通过路由器实现</li>
<li>拥塞控制：ICMP Internet Control Message Protocol 网络信息控制协议</li>
</ul></li>
<li><p>路由算法</p>
<ul>
<li>静态：网络管理员手工配置</li>
<li>动态：通过路由器间彼此交换信息来构造路由表，分为距离-向量算法和链路状态算法。
<ul>
<li>距离-向量算法 所有的路由器都定期地将它们自己的整个路由选择表传送给所有与之相连的临近路由器。路由选择表包含每条路径的目的地和路径的代价。</li>
<li>链路状态算法 每个参与该算法的节点都有整个网络的拓扑信息。一个结点检查所有与之直连的链路的状态，并将所得的信息发送给网络上的所有其他节点。其他结点包括和它直连的和不直连的。当一个结点收到其他节点发来的链路状态时，该节点就通过这些信息更新自己维护的整张网络的拓扑图。如果链路状态发生变化，就通过 Dijsktra 算法计算最短路由。只有链路状态发生变化时，结点才会发送此消息。消息传递使用的是洪泛法。</li>
</ul></li>
</ul></li>
<li><p>层次路由 将互联网分为许多较小的自治系统，系统有权决定自己内部使用什么路由协议</p>
<ul>
<li>内部网关协议 自制系统内部使用的协议。比如使用距离向量算法更新路由表的 RIP 协议和使用链路状态算法更新路由表的 OSPF 协议。</li>
<li>外部网关协议 自制系统之间的网关协议。比如 BGP4。</li>
</ul></li>
<li><p>IPV4</p></li>
<li><p>首部，固定部分为 20B，还有一部分的变长部分。</p></li>
<li><p>NAT Network Address Transform 网络地址转换 用于实现专用网络与公共网络之间的地址转换</p></li>
<li><p>子网划分 使用子网掩码，对物理子网再一次进行划分。IP 地址分为三部分：网络号，子网号，主机号</p></li>
<li><p>CIDR Classless Inter-Domin Routing 无分类域间路由选择 用于消除传统的 A、B、C类网络划分。IP 地址分为两部分：网络前缀和主机号。需要在 IP 地址后用斜线记录网络前缀占用的比特数。可以合并路由表的表项。</p></li>
<li><p>路由聚合 将网络前缀相同的连续 IP 地址组成 CIDR 地址块。使得一个地址块可以表示多个地址，减少路由表的表项，从而降低路由器间交换信息的大小</p></li>
<li><p>ARP address resolution protocol 地址解析协议 对于特定的 IP 地址，查询其对应的物理地址</p></li>
<li><p>DHCP dynamic host configuration protocol 动态地址配置协议 给网络中的主机动态分配 IP 地址</p></li>
<li><p>ICMP internet control message protocol 网络控制信息协议 用来给主机和路由器报告差错和异常，用于拥塞控制。</p></li>
<li><p>IPV6 首部固定 40B，地址长度 16B，用于解决 IPV4 地址耗尽的问题</p></li>
<li><p>路由协议</p>
<ul>
<li>自制系统内
<ul>
<li>RIP 协议 Routing Information Protocol 基于距离向量算法的路由选择协议。 网络中的每个路由器都要维护从它自身到其他每一个目的网络的距离记录。 距离用跳数表示，路由器与网络直连时跳数为 1。每经过一个路由器，跳数加一。16 跳时，表示网络不可达。 RIP 认为跳数少，则该路径就好。 仅与相邻的路由器交换信息。交换的是整个路由表。每个固定的时间，就交换一次信息。 应用层协议，使用 UDP 传输数据</li>
<li>OSPF 协议 Open Shortest Path First 开放最短路径优先协议 基于链路状态算法的路由选择协议。 使用洪泛法发送信息。 只发送与本路由器直连的链路的状态。 只有链路状态发生变化时，才发送信息。 网络层协议，直接使用 IP 数据报发送信息，此时 IP 数据报首部的协议字段为 89。 每个链路状态都附带一个 32 位的序号，序号越大，状态越新。</li>
</ul></li>
<li>自制系统间
<ul>
<li>BGP border gateway protocol 边界网关协议 只力求找到一条能够到达目的网络且比较好的路由，而不是寻找最佳路由。 主要用于处理各 ISP 之间的路由选择。 应用层协议，使用 TCP 传输数据。</li>
</ul></li>
</ul></li>
<li><p>IP 组播 一个发送者与多个接受者之间实现一对多的数据传输。使用 UDP 协议传输数据，IP 地址为 D 类地址。</p></li>
<li><p>计算机网络体系结构</p>
<ul>
<li>原理的体系结构：应用层、传输层、网络层、数据链路层、物理层</li>
<li>IOS 7 层结构：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</li>
<li>TCP 层结构：应用层、传输层、网际层、网络接口层</li>
</ul></li>
<li><p>应用层常见协议</p>
<ul>
<li>FTP 文件传输协议 使用 TCP 21端口为控制端口，20端口是数据连接端口</li>
<li>HTTP 超文本传输协议 80端口</li>
<li>HTTPS 加密的超文本传输协议 443 端口</li>
<li>DNS 地址解析协议 53端口 使用 UDP</li>
<li>STMP 发送邮件协议 客户端向邮件服务器发邮件，邮件服务器向邮件服务器发邮件 25端口 使用 TCP</li>
<li>POP3 接收邮件协议 邮件服务器向客户端发邮件 110端口 使用 TCP</li>
<li>TELNET 远程登录 23端口</li>
</ul></li>
</ul>
<h1 id="操作系统基础">操作系统基础</h1>
<h2 id="进程与线程的区别">进程与线程的区别</h2>
<ul>
<li>进程是系统进行资源分配和调度的基本单位，线程是 CUP 调度和分派的基本单位</li>
<li>线程依赖于进程</li>
<li>进程有自己的独立地址空间，同一进程的不同线程共享当前线程的地址空间</li>
<li>线程基本上不拥有系统资源，只有一点在运行中必不可少的资源，比如自己的线程 ID、程序计数器、一组寄存器和栈。同一进程的不同线程共享该进程的系统资源，比内存，CUP，I/O 等。</li>
<li>进程切换时开销大。因为操作系统要分配和回收资源。同一进程内的线程切换时开销小。</li>
<li>线程间通信比较方便，因为同一进程下的线程共享全局变量等数据。进程间通信比较复杂，要通过 管道、信号量等方式。</li>
<li>线程有两种实现方式：用户级线程和内核级线程。</li>
<li>用户级线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。</li>
<li>内核级线程，线程管理的所有工作由内核完成，应用程序没有线程管理的代码，只有一个到内核级线程的编程接口。</li>
<li>多线程模型：多对一模型、一对一模型、多对多模型</li>
<li>多对一模型：将多个用户级线程映射到一个内核级线程上，线程管理在用户空间完成。一个线程阻塞时，整个进程都阻塞。</li>
<li>一对一模型：每个用户级线程都对应一个内核级线程。并发能力强。</li>
<li>多对多模型：m 个用户级线程映射到 n 个内核级线程上，要求 n ≤ m ## 进程间通信</li>
<li>共享存储 通信进程间共享一块可以直接访问的内存空间。通过对这块共享空间的读写操作来实现进程间的信息交换。对共享空间的读写需要用到 P、V 操作实现同步互斥。</li>
<li>消息传递 进程间的数据交换以格式化的消息为单位。进程间通过操作系统提供的发送消息和接受消息两个原语进行数据交换。 直接通信方式：发送进程直接把消息发给接收进程，并把消息挂在接收进程的消息缓冲队列上。 间接通信方式：发送进程把消息发到某个中间实体，接收进程从中间实体获得消息。</li>
<li>管道通信 管道是连接一个读进程和一个写进程以实现他们之间通信的一个共享文件。写进程向管道写入数据，读进程从管道读出数据。数据被读出后就会被抛弃。管道是半双工通的，要向实现双向通信，则需要两个管道。 ## 进程间调度策略</li>
<li>先来先服务</li>
<li>最短作业优先</li>
<li>优先级调度算法
<ul>
<li>优先级反转问题 高优先级的进程等待被一个低优先级进程占用的资源时会出现优先级反转。</li>
<li>解决方法 优先级继承：将低优先级进程的优先级提升到等待它所占有的资源的最高优先级进程的优先级。当高优先级进程由于等待资源而被阻塞时，此时资源的拥有者的优先级将会自 动被提升。 优先级天花板：将申请某资源的进程的优先级提升到可能访问该资源的所有进程中最高优先级进程的优先级.(这个优先级称为该资源的优先级天花板)</li>
</ul></li>
<li>高响应比优先调度算法</li>
<li>时间片轮转</li>
<li>多级反馈队列 ## 进程间同步</li>
<li>多道程序环境下，进程是并发执行的，但不同进程之前存在这制约关系，为了协调进程间的制约关系，引入了进程间同步。</li>
<li>临界资源：一次仅允许一个进程使用的资源称为临界资源</li>
<li>临界区：进程中访问临界资源的那段代码</li>
<li>同步：为完成某种任务而建立的两个或多个进程，这些进程间因为需要在某些位置上协调他们工作次序而产生制约关系。</li>
<li>互斥：当进程进入临界区使用临界资源时，另一个进程必须等待。</li>
<li>同步机制的四个准则：空闲让进、忙则等待、有限等待、让权等待</li>
<li>信号量机制：信号量机制使用两个原语 “P 操作” 和 “V 操作” 解决同步互斥问题。整型信号量和记录型信号量。</li>
<li>管程：管程是由一组数据及定义在这组数据上的对这组数据的操作所组成的软件模块。</li>
<li>管程的组成
<ol type="1">
<li>局部于管程的共享数据结构，该组数据结构可以用于描述系统中的各种软件资源和硬件资源</li>
<li>对该数据结构进行操作的一组方法</li>
<li>对该数据结构设置初始值的语句</li>
</ol></li>
<li>管程的特性
<ol type="1">
<li>管程内的共享数据只能通过管程的方法操作</li>
<li>每次只允许一个进程在管程内执行某个管程的方法 ## 死锁</li>
</ol></li>
<li>死锁的必要条件
<ul>
<li>互斥：在某一段时间内，一个资源只能由一个进程占有。若此时有其他进程申请资源，则发起请求的进程只能等待。</li>
<li>不剥夺：进程获得资源在未使用完之前，不能被其他进程强行夺走。资源只能由获得资源的进程主动释放。</li>
<li>请求并保持：进程已经获得了至少一个资源，同时又提出了新的资源请求，而该资源已被其他进程占有，此时请求资源的进程被阻塞，但不释放自己获得资源。</li>
<li>循环等待：存在一种进程资源的循环等待链，链中每个进程已获得资源并且该资源同时被链中的下一个进程请求。</li>
</ul></li>
<li>死锁与循环等待的区别 死锁形成的循环等待环，进程 i 请求的资源必须由进程 i+1 提供。而循环等待链却没有该要求。即进程 i 的请求可以被链外的某个进程持有，该进程释放资源后，循环等待链就会被打破。</li>
<li>死锁处理
<ul>
<li>死锁预防 破坏死锁的四个必要条件，就可以保证死锁不会发生。</li>
<li>死锁避免 通过银行家算法实现，保证系统一直处于安全状态</li>
<li>死锁检测和解除 系统分配资源时，不采取任何措施。用资源分配图检测当前系统状态是否是死锁状态。资源分配图可以完全简化，则说明当前系统未死锁。死锁时，用死锁解除方法解除死锁。比如，撤销一个进程，剥夺某个进程的资源，或者让进程回退到系统不死锁的状态。 ## 内存管理 为了更好的支持多道程序的并发，提升系统性能。</li>
</ul></li>
<li>逻辑地址空间 是指一个源程序在编译或者链接装配后，指令和数据使用的虚拟地址组成的空间。</li>
<li>物理地址空间 指内存中真实的物理单元的集合</li>
<li>内存保护 通过上、下限地址寄存器。访问内存时，现将地址与上下限寄存器中的地址比较，防止越界。 通过界址寄存器。虚拟地址与必须小于界址寄存器中的值。</li>
<li>内存管理方式
<ul>
<li>连续分配 一个作业装入一块连续的内存中，内存不够，作业不能执行。 单一连续分配：内存中只有一个作业，用于单道程序机器。 固定分区分配：先在内存中划分好若干固定大小的内存区域，每个区域中装入一个作业。可以实现多道程序的并发。 动态分区分配：不事先划分好内存区域。在进程装入内存时，根据进程的大小动态划分分区。
<ul>
<li>动态分区分配方法 按照程序的需要进行动态的划分。分配算法有首次适应算法、最佳适应算法、最坏适应算法和临近适应算法</li>
</ul></li>
<li>非连续分配 允许一个程序分散的装入不连续的内存中。此时，需要额外的空间去存储分散的内存区域的索引。根据分区大小是否固定，分为分页存储管理方式和分段存储管理方式。其中，分页管理方式根据运行作业时，是否需要把作业的所有页面都装入内存，分为基本分页管理和请求分页管理，两种管理方式。 基本分页：内存分为固定的块，按物理结构划分，会有内部碎片。进程的虚拟内存空间划分为大小相等页，物理内存空间划分为大小相等的页框，一个页刚好装入一个页框中。虚拟地址分为两部分：页号和页内地址。页表记录了页面对应的物理页框号。 基本分段：内存块的大小不固定，按照逻辑结构划分，会有外部碎片。虚拟地址分为两部分：段号和段内地址。 段页式：基本分段和基本分页的结合，会有内部碎片。虚拟地址分为三部分：段号、页号和页内偏移。</li>
</ul></li>
<li>虚拟内存 虚拟内存基于局部性原理，在程序装入时，将程序的一部分装入内存，其余部分留在外面，就可以启动程序执行。在执行的过程中，当所访问的信息不在内存中时，由操作系统将所需要的部分调入内存，然后继续执行。此时，操作系统好像为用户程序提供了一个比实际内存大的多的存储器，称为虚拟存储器。虚拟存储器的大小由计算机的地址结构决定，并不是内存和外存的简单相加。</li>
<li>虚拟内存的实现方式</li>
</ul>
<ol type="1">
<li>请求分页式存储管理
<ul>
<li>页表项结构 与普通页式管理相比，请求分页式管理要处理缺页的情况。如何发现和处理缺页是请求分页管理系统必须解决的问题。因此，页表中增加了四个字段。页表项共有 6 个字段。 页号、页框号、状态位、访问字段、修改位、外存地址 状态位用于指示内存中的该页是否有效。 访问字段用于记录本页在一段时间内被访问的次数，或记录本页最近已经有多长时间未被访问。用于置换算法换出页面时的参考。 修改位用于标识该页在写入内存后是否被修改过。 外存地址，是该页在外存上的物理地址。</li>
<li>地址变换 虚拟地址转换为物理地址 虚拟地址结构：页号和页内地址 首先访问 TLB，TLB 未命中则访问页表，再未命中则缺页。</li>
<li>缺页中断 缺页中断属于内中断。</li>
<li>页面置换算法</li>
</ul>
<ol type="1">
<li>理想的最佳置换算法</li>
<li>先进先出置换算法</li>
<li>最近最久未使用置换算法</li>
<li>时钟置换算法又称为最近未使用算法 先换出未被访问且未被修改的，然后是未被访问但修改了的，然后是被访问但未被修改的，最后是被访问也被修改的</li>
</ol></li>
<li>请求分段式内存管理</li>
<li>请求段页式内存管理</li>
</ol>
<ul>
<li>实现虚拟内存所需要的硬件支持</li>
</ul>
<ol type="1">
<li>一定容量的内存和外存</li>
<li>页表机制或段表机制</li>
<li>中断机构</li>
<li>地址变换机构。实现虚拟地址到物理地址的转换 ## 文件系统</li>
</ol>
<ul>
<li>文件目录 UNIX 的文件目录由文件名和指向文件对应的 inode 的指针组成。</li>
<li>inode</li>
</ul>
<ol type="1">
<li>存放了文件控制文件所需要的各种基本信息。
<ol type="1">
<li>文件基本信息 文件物理位置、文件的逻辑结构、文件的物理结构、文件大小、文件占用的块的个数</li>
<li>存取控制信息 文件读写权限，文件所属的用户，文件所属的组，文件连接数</li>
<li>使用信息 文件最近一次访问时间、inode 的修改时间、文件的修改时间和文件的删除时间</li>
</ol></li>
<li>还有文件用到的物理块的地址。</li>
</ol>
<ul>
<li>文件的逻辑结构
<ol type="1">
<li>流式文件。没有结构，将数据按顺序组织成记录并保存，以字节为单位。</li>
<li>有结构文件。顺序文件、索引文件、索引顺序文件、散列文件</li>
</ol></li>
<li>文件共享 基于索引节点的硬连接，利用符号链实现的软连接</li>
<li>文件控制访问 为每个文件和目录设置一个访问控制表</li>
<li>文件描述符、文件描述符表、打开文件表、目录项、inode 结点 每个进程在 PCB 中都有一个数组，名叫文件描述符表，文件描述符就是这个数组的下标。文件描述符 0 表示标准输入流文件，文件描述符 1 表示标准输出流文件，文件描述符 2 表示标准错误输出流文件。文件描述符的表项是一个指向系统打开文件表的指针。</li>
<li>系统打开文件表 又叫做系统级的描述符表，表格中的各项条目称为打开文件句柄，是一个 file 对象。一个打开文件句柄存储了与一个打开文件相关的全部信息。如下所示：
<ol type="1">
<li>当前文件偏移量</li>
<li>打开文件时所使用的状态标识</li>
<li>文件访问模式</li>
<li>指向该文件 inode 的指针</li>
<li>文件类型和访问权限</li>
<li>一个指向该文件持有的锁列表的指针</li>
<li>文件的各种属性，包括文件大小以及不同类型操作相关的时间戳</li>
<li>该文件的引用计数，就是指向该表项的文件描述符的个数。关闭一个文件描述符会减少相应的文件的引用计数，当引用计数为零时，内核会删除该文件在系统打开文件表中的表项。</li>
<li>一个指向 file_operations 结构体的指针，结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如：read、write、open 等函数。</li>
<li>一个指向 dentry 结构体的指针。“dentry” 是 directory entry 的缩写。open、stat 等函数的参数是文件路径，这些函数需要通过文件路径找到文件的 inode。为了减少磁盘访问，内核缓存了目录的树状结构，称为 dentry cache。该树状结构的每一个结点就是一个 dentry 结构体。open、stat 等函数可以沿着路径各部分的 dentry 结构体搜索即可。dentry 结构体中有一个指向 inode 结构体的指针。inode 结构体保存着从磁盘上 inode 读出来的信息。如果两个 dentry 结构体指向同一个 inode 结构体，则说明这两个文件是硬连接。 系统只维护一个系统打开文件表，所有进程共享这张表。</li>
</ol></li>
<li>虚拟文件系统 Linux 系统中存在很多物理的文件系统，比如 ext2、ext3、ext4 等。每个文件系统都有自己的文件组织方法，操作方法。Linux 系统通过虚拟文件系统使用户能够透明的处理文件，忽视不同物理文件系统之间的差异。 虚拟文件系统中有四个重要对象：超级块（super block)、索引节点（inode）、目录项（dentry）和文件对象（file）</li>
<li>超级块（super block） 一个超级块对应一个真实的物理文件系统，保存文件系统的类型、大小、状态等元信息。不同的物理文件系统对应不同的 super_block，因此对于不同的 super_block 的操作也不同。super_block 结构体中有一个指向 super_operations 结构体的指针，指向某个特定的具体文件系统用于管理这个文件系统中 inode 的操作函数的集合。 内核中的结构处理都是有讲究的，内核单独使用一个简单的结构体将所有 super_block 都连接起来，但这个结构体不是 super_block 本身，因为 super_block 本身太大了，效率不高。 struct file_system_type *s_type 属性：文件系统类型，也就是当前文件系统是属于哪个类型，ext2 还是 ext3。</li>
<li>索引节点 inode 保存的是文件的元数据，就是文件属性的描述。例如：文件大小、设备标识符、用户标识符、文件模式、文件读取或修改的时间戳、指向存储文件数据的磁盘区块的指针。 inode 有两种，一种是虚拟文件系统的 inode，一种是具体文件系统的 inode。前者存在与内存中，后者存在于磁盘中。使用 inode 时，要将磁盘上的 inode 填充到内存中的 inode 中。 每个 inode 结点的大小，一般是 128B 或者 256B。inode 结点的总数在磁盘格式化时就给定。一般每 2KB 的硬盘就设置一个 inode。 inode number 是唯一的，表示不同的文件。文件名是给用户使用的，Linux 的系统文件目录的一个表项就是 “文件名 + inode number”。系统通过文件名，找到文件对应的 inode number，再通过 inode number 找到 inode 信息，最后通过 inode 中的指向磁盘块的指针，找到文件的数据。 创建一个文件时，内核就给该文件分配一个 inode，一个 inode 只对应一个实际文件，一个文件也只有一个 inode。inode 的个数就是系统中文件的最大个数。</li>
<li>目录项（dentry） 目录项是描述文件的逻辑属性，只存在与内存中，没有实际对应的磁盘描述，是存在于内存的目录项缓存，为了提高查找性能而设计的。所有目录项在一起构成一颗庞大的目录树。 一个目录项对应一个 inode 结构，一个 inode 结构可以对应多个 dentry 结构。</li>
<li>文件对象（file） 文件对象描述的是进程已经打开的文件。file 对象组成系统打开文件表。</li>
</ul>
<h1 id="数据库">数据库</h1>
<h2 id="事务的概念与特性">事务的概念与特性</h2>
<ul>
<li>事务是一个操作序列，是不可分割的工作单位。</li>
<li>特性</li>
</ul>
<ol type="1">
<li>原子性，逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</li>
<li>一致性，事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li>隔离性，一个事务所做的修改在最终提交之前，对其他事务是不可见的。并发的事务之间不能互相影响。</li>
<li>持久性，事务一旦提交成功，对数据的修改是永久性的。</li>
</ol>
<h1 id="计算机组成">计算机组成</h1>
<h2 id="补码">补码</h2>
<p>正数和 0 的补码就是该数字本身。负数的补码则是将其对应的整数按位取反再加 1。 补码的最大优点是可以在加法或减法处理中，不需要因为数字的正负而使用不同的计算方式。减一个数相当于加上这个数的相反数的补码。 0 只有一个表示方式。</p>
<h1 id="编译器文法分析模拟器">编译器文法分析模拟器</h1>
<ul>
<li>简单介绍项目 项目是一个只有前端没有后端的静态化 Web 应用。项目通过可视化的方式，动态的展示了 LL(1) 文法的分析过程。项目主要是用来辅助老师教学。用户首先自定义一个上下文无关文法，然后通过消除文法中的左递归和提取左因子化简文法，简化的目的是尝试将用户自定义的上下文无关文法化简为 LL(1) 文法。计算化简后文法的 First 集合和 Follow 集合。通过 First 集合和 Follow 集合的信息判断当前文法是否属于 LL(1) 文法。如果是，则继续生成预测分析表，否则提醒用户去修改文法。</li>
<li>为何选用 Nuxt.js 作为开发框架？ 因为项目是一个没有后端的静态化 Web 应用，Nuxt.js 可以把基于 Vue.js 的应用生成对应的静态站点，所以就选用了 Nuxt.js。</li>
<li>如何进行项目管理的？ 使用华为云项目管理平台进行的项目管理。主要使用了平台的需求规划、迭代和测试管理这三个功能。代码使用 git-flow 进行版本控制。需求分析-用例归约描述-项目计划（项目开发计划和测试计划）-解决方案说明书-设计原型-编码-测试。小组成员每周开两次例会，写一次周报，借此来监控项目进度。</li>
<li>项目技术细节？ 项目使用了 Element-UI 组件库中的一些基础组件，也自定义了很多组件，比如 “计算 First 集合” 的组件、“计算 Follow 集合” 的组件。</li>
<li>你做的工作？ 实现四个功能。读取用户输入、检查并消除文法中的左递归（包括立即左递归和间接左递归）、计算文法的 First 集合并动态展示计算过程和判断文法是否属于 LL(1) 文法这四个功能。
<ol type="1">
<li>读取用户输入 就是读取用户自定义的文法符号和产生式，然后将其转换为我们自定义的一个 grammar 对象。</li>
<li>检查并消除文法中的左递归 2.1 检查并消除文法中的立即左递归 立即左递归很好检查与消除。 2.2 检查并消除文法中的间接左递归 间接左递归需要经过两步或两步以上的推导才能检测出来，有一些难度，这里使用了回溯法进行检测。</li>
<li>计算 First 集合并动态展示计算过程 计算 First 集合有标准的算法，只要将其翻译为代码即可。这里的难点是动态展示计算过程。要求达到的效果是，用户点击下一步，界面上显示下一步的计算结果，以此帮助用户理解算法的运行过程。 解决方法是使用了 JavaScript 中的 Generator 函数，算法每进行一步就通过 yield 表达式返回当前算法状态并展示在前端界面上，然后返回 yield 表达式停下的地方继续执行算法。</li>
<li>判断文法是否属于 LL(1) 文法 这里没有难度。有两条规则用于判断文法是否属于 LL(1) 文法。如果一个文法同时满足这两条规则，则属于 LL(1) 文法，否则不属于。</li>
</ol></li>
<li>项目整体架构？ 项目使用了单例模式，有一个单例对象 grammar，代表用户输入的文法。没有通过编码技巧保证全局只有一个 grammar 对象，只是要求大家在写代码时不可调用 grammar 的构造方法。。</li>
</ul>
<h1 id="内存数据库模型">内存数据库模型</h1>
<ul>
<li>简单介绍 通过控制台读入 SQL 语句，对 SQL 进行解析，调用对应的方法。可以解析八种 SQL 语句。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> databasename</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> databasename</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename(column1,column2) <span class="keyword">values</span> (value1,value2)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tablename <span class="keyword">where</span> <span class="keyword">column</span>=<span class="keyword">value</span></span><br><span class="line"><span class="keyword">select</span> column1 <span class="keyword">from</span> tablename <span class="keyword">where</span> column2=<span class="keyword">value</span></span><br><span class="line"><span class="keyword">update</span> tablename <span class="keyword">set</span> column1=value1, column2=value2 <span class="keyword">where</span> column3=value3</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tablename</span><br><span class="line">(</span><br><span class="line">	colume1 <span class="keyword">type</span>,</span><br><span class="line">	column2 <span class="keyword">type</span>,</span><br><span class="line">	primary <span class="keyword">key</span>(column1)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tablename</span><br></pre></td></tr></table></figure></li>
<li>SQL 语句解析过程
<ul>
<li>首先从控制台读取 SQL 语句，让后词法分析器提取 SQL 语句中的 token 并传递给语法分析器，语法分析器获取 token 并分析 SQL 的语义，按照语义调用数据引擎的接口，实现 SQL 语句的执行。</li>
<li>词法分析通过一个 scan 函数，一个字符一个字符的读取 SQL 语句。然后将读到的每一个词素，组成词法单元 token。有一个 Lexer 类实现词法分析。</li>
<li>语法分析首先要获得一个词法分析器对象。然后不断调用词法分析对象的 scan 方法获取词法单元。然后通过一个 stmt 函数分析获得词法单元。其实就是一堆 switch 和 case，用 case 匹配预先定义好的 token-name。比如 CREATE、TABLE、DROP 等。然后调用 DBs 对象实现的方法来模拟 SQL 语句的功能。</li>
<li>没有生成语法树，语义分析和语法分析放在一起了。或者说没有语法分析，只有语义分析。语义分析实现了类型检查。</li>
<li>到语义分析就结束了。该编译器的功能就是把 SQL ��句翻译为 C++ 函数调用。。</li>
</ul></li>
<li>数据库模拟
<ul>
<li>有一个 DBs 对象，该对象用来管理所有的数据库。它的属性是一个 vector 数组，数组里面的值是一个个 Database 对象。DBs 对象有所有的操作数据库的方法。SQL 语句分析结束后就是调用这里的方法来模拟执行 SQL 语句。</li>
<li>一个 Database 对象表示一个数据库。它的属性值有一个 string 类型的数据库名，一个 int 类型的变量记录库中表的个数和一个 vector 数组存储数据库中的所有表。数组里面的值是一个个 Table 对象。还有一些操作表的方法。</li>
<li>一个 Table 对象来表示一个数据库中的表。它的属性值有一个 string 类型的表名，两个 int 类型的变量分别记录表的行数和列数。两个 vector 数组，分别存储行和列。数组里面分别是 Column 对象和 Row 对象。还有一系列操作属性值的方法。</li>
<li>一个 Column 对象，用来表示 Table 中的某一列。属性值有 bool 类型的主码标识，string 类型的列名，一个枚举类型的变量，表示列的数据类型，只做到了支持 varchar 类型。一个 bool 类型的变量，用于标识当前列是否允许为空。一个 int 类型的变量用于记录列值的长度。还有一些列操作属性的方法。</li>
<li>一个 Row 对象，用于表示 Table 中的某一行。属性值只有一个 string 类型的数组，记录一行的内容。</li>
<li>一个 Where 类，用于支持 where 语句，只有两个属性，一个 string 类型的列名，一个 string 类型的变量记录 where 语句中的值。</li>
<li>create database 方法实现
<ul>
<li>创建一个数据库就是创建一个 Database 对象。。然后加入 DBs 对象的 vector 数组中。。</li>
</ul></li>
<li>drop database 方法实现
<ul>
<li>就是将 DBs 对象的 vector 数组中对应的 Database 对象删除。。</li>
</ul></li>
<li>insert 方法实现
<ul>
<li>通过 vector 的 push_back 方法实现的。。插入的时候先检查要插入行的主码是否与已经存在的行的主码相同。。</li>
</ul></li>
<li>delete 方法实现
<ul>
<li>通过 vector 的 erase 方法实现的。。</li>
</ul></li>
<li>select 方法实现
<ul>
<li>找到对应的数据库，找到对应的表，找到对应的行，然后将行显示出来。</li>
</ul></li>
<li>update 方法实现
<ul>
<li>找到对应的数据库，找到对应的表，找到对应的行，然后将要修改的内容修改了。</li>
</ul></li>
<li>create table 方法实现
<ul>
<li>先检查要创建的表是否存在，然后用 push_back 将新建的 Table 对象加入 Database 对象的记录 Table 的 vector 数组中。。</li>
</ul></li>
<li>drop table 方法实现
<ul>
<li>先检查要创建的表是否存在，然后使用 erase 方法将要删除的表删除。。</li>
</ul></li>
</ul></li>
<li>序列化
<ul>
<li>使用了 boost 库。</li>
<li>之前提到的每一个类都有一个对应的结构，用来序列化。该结构的属性和对应的类的属性相同，有一个用来序列化的函数。</li>
<li>首先将对象转换为对应的结构。然后��序列化。 # Linux 文件系统</li>
</ul></li>
<li>简单介绍 二级文件系统有一个根目录，每个用户在根目录下创建自己的用户目录，用户可以在自己的用户目录下创建文件。使用 C++ 的文件操作函数，对文件进行读、写、删、查操作。</li>
<li>文件系统结构
<ul>
<li>使用一个真正的文件夹模拟磁盘。该文件称为 file system。</li>
<li>规定该文件系统最大 100KB，一个 block 的大小为 1KB，单个文件最大 1KB，系统的 inode 个数为 100。</li>
<li>使用一个名为 superblock 的整数数组记录 inode 和 block 的使用情况。下标 1~100 记录 inode 的使用情况，101~200 记录 block 的使用情况。程序退出时，将该数组写入 file system 目录下的一个名为 superblock.bin 的文件。相当与使用位图管理磁盘空闲块。</li>
<li>使用一个名为 account 的 map&lt;string,string&gt; 记录用户的帐号和密码。程序退出时，写入file system 目录下的一个名为 users.bin 的文件。</li>
<li>使用一个名为 inode 的 map&lt;int,fileAttribute&gt; 记录 inode 结点。fileAttribute 记录了文件的基本属性。程序退出时，写入file system 目录下的一个名为 inode.bin 的文件。</li>
<li>file system 文件夹下有一个 node 文件夹，里面存放 username.bin 文件，记录用户创建的文件名和文件对应的 inode number。相当于系统文件目录。程序启动时读入到一个名为 fileTable 的 map&lt;string,int&gt; 中。</li>
<li>file system 文件夹下有一个 userfiles 文件夹，里面存放用户创建的文件，使用 inode number 命名。</li>
</ul></li>
<li>方法实现
<ul>
<li>signIn 用户注册 就是简单的在 account 中添加一项。添加之前检查该用户是否已经存在。</li>
<li>logIn 用户登陆 检查用户输入的帐号密码是否在 account 中。</li>
<li>createFile 创建文件 找到一个空闲的 inode number，找到一个空闲的 block，然后在 userFiles 目录下创建文件，该文件以 inode number 命名。</li>
<li>deleteFile 删除文件 在 fileTabe 中查找文件是否存在，找到了就删除，释放文件占用的 inode number 和 block。</li>
<li>openFile 打开文件 在 fileTable 中查找文件是否存在，找到了就返回文件的 inode number。</li>
</ul></li>
</ul>
<h1 id="字节跳动-一面">字节跳动 一面</h1>
<h2 id="经验">经验</h2>
<ul>
<li>复习知识点时要全面准确，一定要全面，因为面试官会根据你的回答向深处问！！</li>
<li>不会的要说不会。</li>
<li>算法要有一定的基础，LeetCode 的简单和中等难度的题要能解决。</li>
<li>对面试官的问题有疑惑就直接问清楚。</li>
<li>遇到不会的算法题，自己边想边说，面试官可能会给出一些指导。要会找话头。 ## 内容</li>
<li>自我介绍 就是把自己的简历复述一遍 说的时候有些紧张。。</li>
<li>项目 编译器文法分析模拟器
<ul>
<li>直接跳到了编译器有哪几部分，是怎么实现的</li>
<li>一个可执行的二进制文件从打开到执行的步骤是怎样的（不会）</li>
</ul></li>
<li>项目 内存数据库模型
<ul>
<li>解析 SQL 语句的编译器是怎样实现的</li>
<li>数据库使用什么模拟的？STL 里面的 vector</li>
<li>数据库事务的特征（不会，就答了一个原子性）</li>
</ul></li>
<li>项目 二级文件系统
<ul>
<li>基本功能</li>
<li>进程打开的第一个文件时，对应的文件描述符是什么（3）</li>
<li>文件描述符是什么</li>
<li>系统打开文件表里面存放什么东西（不会）</li>
</ul></li>
<li>说一下 TCP 协议的三次握手和四次挥手</li>
<li>在第四次挥手后为何要有 TIME_WAIT 状态</li>
<li>如果有两个线程，同时修改一个变量 i，使 i 的值增加一，i 的初始值为 0，不加锁，i 会有几个可能结果。为什么会有这样的结果，怎么解决？</li>
<li>信号量是怎么实现的？（硬件实现）怎么用硬件实现？实现在哪个硬件中？用什么硬件实现？</li>
<li>C++ 语言细节
<ul>
<li>const 关键字的用途。（只答了修饰普通变量，指针，函数参数）</li>
</ul></li>
<li>算法题：循环有序数组的二分查找、固定几个数字组成的下一个比当前数字大的数</li>
<li>有啥问题想问面试官，最近在读什么书？</li>
</ul>
<h1 id="字节跳动-二面">字节跳动 二面</h1>
<h2 id="经验-1">经验</h2>
<ul>
<li>刷算法题。见多识广，做的少了就会露馅。要写代码。</li>
<li>基础知识要牢固。 ## 内容</li>
<li>自我介绍</li>
<li>基于简历上的项目提问</li>
<li>项目 编译器文法分析模拟器
<ul>
<li>简述模拟器实现的功能</li>
<li>如何实现一个正则表达式匹配引擎（词法分析）</li>
</ul></li>
<li>项目 内存数据库系统
<ul>
<li>解析 SQL 语句时，如何判断 where 语句中的关系的优先级（不会）</li>
<li>数据库是如何存储在内存中的</li>
</ul></li>
<li>项目 二级文件系统 结合操作系统提问
<ul>
<li>虚拟内存 只有 4G 内存的机器上能运行 8G 大小的程序吗？</li>
<li>虚拟内存的实现细节</li>
<li>页面置换算法</li>
</ul></li>
<li>C++
<ul>
<li>map 容器实现方式-&gt;红黑树-&gt;红黑树的定义-&gt;除了红黑树还可以用什么数据结构实现-&gt;跳表-&gt;还有吗？-&gt;散列表-&gt;实现一个散列表应当注意的细节-&gt;要有一个好的散列函数，要能解决散列冲突-&gt;散列冲突的解决方法有哪些？-&gt; 开哈希和闭哈希</li>
</ul></li>
<li>算法
<ul>
<li>给 2000 万的高考考生按照分数排序（基数排序）</li>
<li>给定 m 个不重复的字符 [a, b, c, d]，以及一个长度为 n 的字符串 tbcacbdata。问能否在这个字符串中找到一个长度为 m 的连续子串，使得这个子串刚好由上面 m 个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3。
<ul>
<li>该题为 leetcode 30.串联所有单词的子串。知识点为哈希表、滑动窗口、字符串。解题文章：[LeetCode 图解|30.串联所有单词的子串-五分钟学算法][link1]</li>
</ul></li>
</ul></li>
<li>有什么想问的吗？ 下次就问自己没做出来的题。。</li>
</ul>
<h1 id="腾讯春招补招">腾讯春招补招</h1>
<ul>
<li>岗位方向 软件开发-后台开发方向</li>
<li>岗位要求 编程基本功扎实，掌握 C/C++/JAVA 等开发语言、常用算法和数据结构； 熟悉 TCP/UDP 网络协议即相关编程，进程间通讯编程； 了解 Python、Shell、Perl 等脚本语言； 了解 MySQL 及 SQL 语言，了解 NoSQL 和 key-value 存储原理； 全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等知识； 了解分布式系统设计与开发、负载均衡技术、系统容灾设计、高可用系统等知识。 [link1]:https://mp.weixin.qq.com/s/OnpzUjnBaUw9Y-tzsralJA</li>
</ul>
<h1 id="字节跳动春招补招">字节跳动春招补招</h1>
<ul>
<li><p>岗位方向 后端开发工程师-抖音、直播、Faceu、轻颜、剪映</p></li>
<li><p>岗位描述 团队介绍：互娱研发包含抖音短视频、抖音火山版、直播、Faceu、轻颜、剪映等，截止2020年1月，抖音日活（DAU）已经突破4亿，并继续保持高速增长。你会支持包括但不限于上述产品研发和相关架构工作，每一行代码都能影响亿万用户。</p></li>
</ul>
<ol type="1">
<li>参与开发公司直播平台，构建通用平台，工具组件；</li>
<li>支持直播生产端业务迭代，提升运营效率与内容生产效率；</li>
<li>能够充分理解业务需求，与各个业务角色配合，负责业务项目的分析、抽象、架构、研发过程及最终质量；</li>
<li>有意愿和能力持续优化性能，提升系统稳定性，同时使用自动化手段提高效率。</li>
</ol>
<ul>
<li>岗位要求</li>
</ul>
<ol type="1">
<li>2020届获得本科及以上学历，计算机相关专业；</li>
<li>热爱计算机科学和互联网技术，对移动产品有浓厚兴趣；</li>
<li>扎实的数据结构和算法基础；熟悉至少一门编程语言，包括但不限于：Java、Objective-C、Swift、C、C++；</li>
<li>关注用户体验，能够积极把技术转化到用户体验改进上；</li>
<li>对新技术保持热情，具备良好的分析、解决问题的能力。</li>
</ol>
<h2 id="一面">一面</h2>
<p>基础知识问题： 对文件系统熟不熟悉？介绍一下 Linux 的文件系统。 如何检测死锁，如何避免死锁。（死锁的四个必要条件：互斥，非抢占，保持请求，循环等待） C++语言细节，move 函数的实现（不会，没听说过这个函数），C++ 有哪几种锁（不会，没用过 C++ 的锁）。 常见的排序算法，哪些是稳定的，哪些是不稳定的？ 进程与线程的区别。 进程间通信的方式，系统是如何实现共享内存这种通信方式的？（不会，只知道原理，不知道实现） 一个文件从打开，然后修改，再到写回硬盘的流程。（不知道，只说出了打开文件的过程，修改到写回的过程不清楚）</p>
<p>编程题： k 个一组反转链表</p>
<h1 id="深信服春招">深信服春招</h1>
<ul>
<li>笔试 选择题：考察数据结构中的栈，树的遍历 填空题：考察程序输出，sizeof() 函数的使用，函数定义的参数与传递的参数不同怎么办，结构体语法，指针的使用，一些概率计算 编程题：模拟题，模拟口罩分配，要自己处理输入；字符串处理，将一连串的空格变为逗号，要自己处理输入；后缀表达式转中缀表达式，不能有多余的括号。</li>
<li>结果 凉了，C++ 基础知识太差，模拟题没思路，输入处理好久不写给忘了。::&gt;_&lt;:: ## 没凉，被捞起来了，一面问题 首先询问项目经历 编译器文法分析模拟器，项目具体做什么，怎么做的项目管理，你负责哪一部分？ Linux 二级文件系统，什么是二级文件系统，怎么做的，是在用户层做的还是在应用层做的？当一个文件需要扩容时，怎么办？ 内存数据库模型，存储引擎怎么做的？存储引擎能不能建立索引？SQL 语句解析的时候有没有考虑异常情况？最终发现，这个其实就是一个 SQL 语句解析器。。 ## 三面 树的前中后序遍历，使用迭代实现。 一个文件打开，修改，再写回磁盘都有哪些系统调用。 宏定义一个三个数比较。</li>
</ul>
<p>C++ 语言细节 堆内存和栈内存的区别 野指针是什么 什么情况下会发生内存泄露</p>
<p>数据结构问题 数组与链表的区别 树的应用，AVL 树，红黑树，B 树，B+ 树 常见排序算法，哪些是稳定的，哪些是不稳定的？快速排序的原理。</p>
<p>面试官给的面试总结 项目管理经验不足，开发时不考虑异常情况，典型的学生思维。二级文件系统做的不够深入，没有在内核上实现。数据库模型的数据存储引擎简陋，主要工作集中在 SQL 语句解析器上。C++ 语言细节不够扎实，在工作中，大多在处理各种异常情况，比如内存泄漏，野指针等。</p>
<h1 id="三七互娱笔试">三七互娱笔试</h1>
<p>RSA、SHA、DES、BASE64 分别是什么。 IPV6 地址的位数 操作系统提供的接口有哪几种？ 缺省的 Linux 系统如何启动后台进程？ Linux 下如何获取文件夹的大小？</p>
<h1 id="华为业务主管面">华为业务主管面</h1>
<p>自我介绍 团队愿景，网络自动驾驶，通信的高速公路，互联网的基础，团队大概有 200 个人 需要学习的技术 1. 设计模式 2. 编程能力，基础的指针，队列，堆栈等知识 3. 数据库的基本知识 4. 大数据的基本知识 3 天左右会收到 HR 的通知</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>a cup of salt</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="hespoon WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="hespoon Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" rel="prev" title="微信小程序开发">
      <i class="fa fa-chevron-left"></i> 微信小程序开发
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/17/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F/" rel="next" title="常见排序">
      常见排序 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#余大佬的面试经验"><span class="nav-number">1.</span> <span class="nav-text">余大佬的面试经验</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络"><span class="nav-number">2.</span> <span class="nav-text">计算机网络</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统基础"><span class="nav-number">3.</span> <span class="nav-text">操作系统基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程的区别"><span class="nav-number">3.1.</span> <span class="nav-text">进程与线程的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库"><span class="nav-number">4.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事务的概念与特性"><span class="nav-number">4.1.</span> <span class="nav-text">事务的概念与特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机组成"><span class="nav-number">5.</span> <span class="nav-text">计算机组成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#补码"><span class="nav-number">5.1.</span> <span class="nav-text">补码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编译器文法分析模拟器"><span class="nav-number">6.</span> <span class="nav-text">编译器文法分析模拟器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存数据库模型"><span class="nav-number">7.</span> <span class="nav-text">内存数据库模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字节跳动-一面"><span class="nav-number">8.</span> <span class="nav-text">字节跳动 一面</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#经验"><span class="nav-number">8.1.</span> <span class="nav-text">经验</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字节跳动-二面"><span class="nav-number">9.</span> <span class="nav-text">字节跳动 二面</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#经验-1"><span class="nav-number">9.1.</span> <span class="nav-text">经验</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#腾讯春招补招"><span class="nav-number">10.</span> <span class="nav-text">腾讯春招补招</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字节跳动春招补招"><span class="nav-number">11.</span> <span class="nav-text">字节跳动春招补招</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一面"><span class="nav-number">11.1.</span> <span class="nav-text">一面</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深信服春招"><span class="nav-number">12.</span> <span class="nav-text">深信服春招</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三七互娱笔试"><span class="nav-number">13.</span> <span class="nav-text">三七互娱笔试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#华为业务主管面"><span class="nav-number">14.</span> <span class="nav-text">华为业务主管面</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hespoon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">hespoon</p>
  <div class="site-description" itemprop="description">全心全意的投入生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hespoon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hespoon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hezaojian@gmail.com" title="E-Mail → mailto:hezaojian@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fas fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hespoon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">116k</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        


  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1279024191&web_id=1279024191"></script>
  </div>






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
