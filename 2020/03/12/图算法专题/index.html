<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-hespoon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-hespoon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-hespoon.png">
  <link rel="mask-icon" href="/images/hespoon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hespoon.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":"//cdn.jsdelivr.net/gh/user/repo@version/file","lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="图的定义与相关术语 图由顶点和边组成。 图分为有向图和无向图。有时可以将无向图看为双向的有向图。 图可以表示为 G(V,E)，V 是顶点的集合，E 是边的集合。 图的存储 图的存储方式有两种：邻接矩阵和邻接表。 邻接矩阵 设图 G(V,E) 的顶点编号为 0、1、…、N-1，则可以令二维数组 G[N][N] 的两维分别表示图的顶点编号。G[i][j] 表示点 i 到点 j 的边的权重">
<meta property="og:type" content="article">
<meta property="og:title" content="图算法专题">
<meta property="og:url" content="http://hespoon.github.io/2020/03/12/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/index.html">
<meta property="og:site_name" content="Spirit">
<meta property="og:description" content="图的定义与相关术语 图由顶点和边组成。 图分为有向图和无向图。有时可以将无向图看为双向的有向图。 图可以表示为 G(V,E)，V 是顶点的集合，E 是边的集合。 图的存储 图的存储方式有两种：邻接矩阵和邻接表。 邻接矩阵 设图 G(V,E) 的顶点编号为 0、1、…、N-1，则可以令二维数组 G[N][N] 的两维分别表示图的顶点编号。G[i][j] 表示点 i 到点 j 的边的权重">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-03-11T22:53:26.000Z">
<meta property="article:modified_time" content="2020-10-18T04:55:45.033Z">
<meta property="article:author" content="hespoon">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hespoon.github.io/2020/03/12/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>图算法专题 | Spirit</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Spirit</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hespoon" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/03/12/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          图算法专题<a href="https://github.com/hespoon/my-blog/tree/master/source/_posts/图算法专题.md" class="post-edit-link" title="Edit this post" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-12 06:53:26" itemprop="dateCreated datePublished" datetime="2020-03-12T06:53:26+08:00">2020-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-18 12:55:45" itemprop="dateModified" datetime="2020-10-18T12:55:45+08:00">2020-10-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="图的定义与相关术语">图的定义与相关术语</h1>
<p>图由顶点和边组成。</p>
<p>图分为有向图和无向图。有时可以将无向图看为双向的有向图。</p>
<p>图可以表示为 G(V,E)，V 是顶点的集合，E 是边的集合。</p>
<h1 id="图的存储">图的存储</h1>
<p>图的存储方式有两种：邻接矩阵和邻接表。</p>
<p><strong>邻接矩阵</strong></p>
<p>设图 G(V,E) 的顶点编号为 0、1、…、N-1，则可以令二维数组 G[N][N] 的两维分别表示图的顶点编号。G[i][j] 表示点 i 到点 j 的边的权重。可以令权重等于一个非法值来表示两点之间不联通。</p>
<p><strong>邻接表</strong></p>
<p>设图 G(V,E) 的顶点编号为 0、1、…、N-1，每个顶点都可能有若干条出边，如果把同一个顶点的所有出边放在一个列表中，那么 N 个顶点就会有 N 个列表（没有出边，则对应空表），这 N 个列表被称为图 G 的邻接表，记为 Adj[N]，其中 Adj[i] 存放顶点 i 的所有出边组成的列表，这样 Adj[0]，Adj[1]，…，Adj[N-1] 就分别都是一个列表。直观上，邻接表可以使用链表实现。但是，使用 vector 实现会更加方便。</p>
<p>对于有 N 个顶点的图，可以申请一个二维 vector 数组 Adj[N]，其中 N 为顶点个数，每个 Adj[i] 都是一个变长数组 vector，存放点 i 的出边。</p>
<p>如果邻接表中只存放顶点之间的连接情况，不存放边权，则可以直接声明为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[N];</span><br></pre></td></tr></table></figure>
<p>如果邻接表中需要存放边权，可以先声明一个结构体 Node，用于存放出边的终点编号和边权</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> v; <span class="comment">// 出边终点编号</span></span><br><span class="line">  <span class="keyword">int</span> w; <span class="comment">// 出边的边权</span></span><br><span class="line">  Node () &#123;&#125;</span><br><span class="line">  Node (<span class="keyword">int</span> _v,<span class="keyword">int</span> _w): v(_v),w(_w) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>邻接表如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[N];</span><br></pre></td></tr></table></figure>
<h1 id="图的遍历">图的遍历</h1>
<p>遍历整个图，就相当于对图中所有的连通块进行遍历。</p>
<p><strong>DFS</strong></p>
<p>DFS 遍历图的基本思想是，将已经访问过的点设为已访问，下次递归到时不再处理，直到整个图的顶点都标记为以访问。</p>
<p>一次 DFS 遍历可以遍历完一个连通块。</p>
<p>如果已知图是一个连通图，则只需要一次 DFS 就可以遍历所有顶点。如果图是不连通的，包含多个连通块，则需要多次 DFS 遍历。DFS 的伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DFS(u)&#123; <span class="comment">// 访问顶点 u 所在的连通块</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(从 u 出发能到达的所有顶点 v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DFSTrave(G)&#123; <span class="comment">// 遍历图 G</span></span><br><span class="line">    <span class="keyword">for</span>(G 的所有顶点 u)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是邻接表和邻接矩阵的 DFS 遍历框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V=<span class="number">1000</span>; <span class="comment">// 定义最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7fffffff</span>; <span class="comment">// 定义一个超大数，在邻接矩阵中表示两点之间不连通</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[MAX_V]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 访问数组，初始化为全 false</span></span><br><span class="line"><span class="comment">/*--------------------邻接矩阵的 DFS 遍历--------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// u 为当前访问顶点，depth 为 DFS 树的深度，n 为节点个数</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为以访问</span></span><br><span class="line">    <span class="comment">// 这里可以对 u 进行一些操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G[u][i]!=INF&amp;&amp;vis[i]==<span class="literal">false</span>)&#123; <span class="comment">// 如果 i 未被访问且 i 可达</span></span><br><span class="line">            DFS(i,depth+<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 遍历图 G，n 为顶点个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(i,<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------邻接表的 DFS 遍历----------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// u 为当前访问顶点，depth 为 DFS 树的深度，n 为节点个数</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 这里可以对 u 进行一些操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].size();i++)&#123; <span class="comment">// 遍历从 u 出发可以到达的所有顶点</span></span><br><span class="line">        <span class="keyword">int</span> v=adj[u][i]; <span class="comment">// 下一个要访问的顶点</span></span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(v,depth+<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 遍历图，n 为顶点个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(i,<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BFS</strong></p>
<p>BFS 以广度为关键词，以扩散的方式向外访问顶点。</p>
<p>BFS 需要使用一个队列，通过反复取出队首，将该顶点可达到的的未曾加入过队列的顶点全部入队，直到队列为空时遍历结束。</p>
<p>一次 BFS 遍历可以遍历一个连通块。</p>
<p>如果图中有多个连通块，则需要多次 BFS 遍历。BFS 的伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BFS(u)&#123; <span class="comment">// 遍历 u 所在的连通块</span></span><br><span class="line">    <span class="built_in">queue</span> q; <span class="comment">// 定义队列 q</span></span><br><span class="line">    将 u 入队;</span><br><span class="line">    inq[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为已进入过队列</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        取出队首元素 s 进行访问;</span><br><span class="line">        <span class="keyword">for</span>(从 s 出发可到达的所有顶点 v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inq[v] == <span class="literal">false</span>)&#123;</span><br><span class="line">                将 v 入队;</span><br><span class="line">                inq[v]=<span class="literal">true</span>; <span class="comment">// 标记 v 为已入过队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFSTrave(G)&#123; <span class="comment">// 遍历图 G</span></span><br><span class="line">	<span class="keyword">for</span>(G 中的所有顶点 u)&#123; <span class="comment">// 枚举 G 中的所有顶点 </span></span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)&#123; <span class="comment">// 如果顶点没有入过队</span></span><br><span class="line">            BFS(u); <span class="comment">// 遍历 u 所在的连通块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面分别是邻接矩阵和邻接表的 BFS 遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V =<span class="number">10000</span>; <span class="comment">// 定义最大顶点个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7fffffff</span>; <span class="comment">// 定义一个超大数，表示不可达</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[MAX_V]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> inq[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 入队标记数组</span></span><br><span class="line"><span class="comment">/*----------邻接矩阵 BFS----------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 当前访问顶点 u 和图中顶点总数 n</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 在这里可以对队首顶点进行操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inq[i]==<span class="literal">false</span>&amp;&amp;G[u][i]!=INF)&#123;</span><br><span class="line">                inq[i]=<span class="literal">true</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 图中节点总数 n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(i,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------邻接表 BFS---------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="comment">// 当前访问顶点 u</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 这里可以对队首顶点进行操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[temp].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=adj[temp][i];</span><br><span class="line">            <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li><p>DFS 和 BFS 两种遍历方式都是一次遍历一个连通块，都使用了一个标记数组以防重复遍历同一个顶点。</p></li>
<li><p>DFS 每次遍历到最后一个顶点时会形成一个遍历路径，与标记数组结合，可以找出图中的环。</p></li>
<li><p>如果能够确定图是一棵树，则 DFS 和 BFS 都能保证每个顶点遍历且仅遍历一次，可以不用标记数组。</p></li>
<li><p>DFS 是以深度作为关键词，通过递归实现。</p></li>
<li><p>BFS 是以广度作为关键词，通过迭代和一个队列实现。</p></li>
</ul>
<h1 id="最短路径">最短路径</h1>
<p>给定图 G(V,E)，求一条从起点到终点的路径，使得这条路径上经过的边的边权之和最小。</p>
<h2 id="单源最短路径">单源最短路径</h2>
<p>给定图 G(V,E) 和起点 s，通过算法得到 s 到达其他每个顶点的最短距离。</p>
<h3 id="dijkstra-算法"><strong>Dijkstra 算法</strong></h3>
<p>Dijkstra 的基本思想是对图 G(V,E) 设置集合 S，存放已经被访问的顶点，然后每次从集合 V-S 中选择与起点 s 的最短距离最小的一个顶点，记为 u，访问 u 并加入集合 S 中。之后，令顶点 u 为中介点，优化起点 s 与所有能从 u 到达的顶点 v 之间的最短距离，这样的操作执行 n 次，n 为顶点个数，直到集合 S 包含所有顶点。</p>
<p>Dijkstra 算法只能处理边权都是非负数的图。如果边权出现负数，Dijkstra 算法就会出现错误。</p>
<p><strong>编码要点</strong></p>
<ol type="1">
<li><p>集合 S 可以使用一个 bool 型数组 vis[] 来实现。</p>
<p>当 vis[i]=true 时，表示顶点 <span class="math inline">\(V_i\)</span> 已经被访问；vis[i]=false 时，表示顶点 <span class="math inline">\(V_i\)</span> 没有被访问</p></li>
<li><p>使用一个 int 型数组 d[] 表示起点 s 到达顶点 <span class="math inline">\(V_i\)</span> 的最短距离。</p>
<p>初始时，起点 s 的 d[s] 赋为 0，表示从起点到起点的距离为 0，其余 d[i] 都赋为一个很大的数，表示其他顶点都是不可达的。</p></li>
</ol>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图 G 设为全局对象，减少传递参数带来的消耗；数组 d[] 为起点到达其他个点的最短路径的长度；s 为起点</span></span><br><span class="line">Dijkstra(G,<span class="keyword">int</span> d[],<span class="keyword">int</span> s)&#123;</span><br><span class="line">    初始化，d[s]=<span class="number">0</span>，其余 d[i]=<span class="number">0x3fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(循环 n 次，n 为顶点个数)&#123;</span><br><span class="line">        u=使 d[u] 最小，且还未访问的顶点的编号;</span><br><span class="line">        标记 u 已经被访问了;</span><br><span class="line">        <span class="keyword">for</span>(从 u 出发能到达的所有顶点 v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v 未被访问且以 u 为中介点使 s 到达 v 的距离更优)&#123;</span><br><span class="line">                优化 d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dijkstra 是一个迭代算法，最外层的 for 循环共循环 n 次，n 为顶点个数。</p>
<p>寻找最小且未被访问的 d[i] 可以通过最小堆来实现，将查找过程的时间复杂度优化为 O(1)，向最小堆中插入数据的时间复杂度为 O(logn)。因此，使用最小堆可以将查找操作的整体时间复杂度优化为 O(logn)。​ C++ 中的最小堆可以使用优先队列代替。</p>
<p><strong>邻接矩阵和邻接表的 Dijkstra 实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V=<span class="number">10000</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大数</span></span><br><span class="line"><span class="keyword">int</span> d[MAX_V]; <span class="comment">// 记录起点到达其他顶点的最短距离的数组</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 标记数组</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="comment">/*--------------------邻接矩阵的 Dijkstra 未优化----------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为顶点个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 填充数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 从起点到达起点的距离为 0</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 填充标记数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 循环 n 次</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF; <span class="comment">// u 使 d[u] 最小，MIN 存放最小的 d[u]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 寻找未访问的顶点中 d[] 最小者</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;</span><br><span class="line">                MIN=d[j];</span><br><span class="line">                u=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到小于 INF 的 d[u]，说明剩余顶点和起点不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 遍历从 u 出发可到达的所有顶点</span></span><br><span class="line">            <span class="comment">// 如果顶点未访问 &amp;&amp; 顶点可达 &amp;&amp; 以 u 为中介点可以使 d[j] 更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;G[u][j]!=INF&amp;&amp;d[u]+G[u][j]&lt;d[j])&#123;</span><br><span class="line">                d[j]=d[u]+G[u][j]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------邻接表的 Dijkstra 未优化-----------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 为边的目标顶点，dis 为边权</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; adj[MAX_V]; <span class="comment">// 邻接表，邻接表中要存储边权</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 是起点，n 是顶点个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 填充距离数组 d</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 起点到起点的距离为 0</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 填充标记数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// n 次循环</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 寻找未访问顶点中 d[] 最小的</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                MIN=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找不到小于 INF 的 d[u]，说明剩余顶点与起点不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为以访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;adj[u].size();j++)&#123;</span><br><span class="line">            <span class="comment">// 如果 j 未访问 &amp;&amp; 以 u 为中介点可以使 d[j] 更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;adj[u][j].dis+d[u]&lt;d[j])&#123;</span><br><span class="line">                d[j]=adj[u][j].dis+d[u]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未优化的 Djikstra 的时间复杂度为 <span class="math inline">\(O(V^2)\)</span> 。其中，最外层的 for 循环需要循环 V 次，寻找 u 则还需要循环 V 次。</p>
<p><strong>使用最小堆优化的 Dijkstra</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V=<span class="number">10000</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大数</span></span><br><span class="line"><span class="keyword">int</span> d[MAX_V]; <span class="comment">// 记录起点到达其他顶点的最短距离的数组</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 标记数组</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 是目标顶点，dis 是边权</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node a1,Node a2)&#123; <span class="comment">// 重载小于号，利用优先队列实现最小堆</span></span><br><span class="line">        <span class="keyword">return</span> a1.dis&gt;a2.dis;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(<span class="keyword">int</span> _v,<span class="keyword">int</span> _dis):v(_v),dis(_dis) &#123;&#125;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; adj[MAX_V]; <span class="comment">// 邻接表，需要存储边权</span></span><br><span class="line"><span class="comment">/*------------邻接矩阵 Dijkstra 堆优化----------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为顶点个数</span></span><br><span class="line">    fill(d,d+n,INF);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node&gt; minHeap; <span class="comment">// 最小堆，堆中记录 u 和 d[u]</span></span><br><span class="line">    minHeap.push(Node(s,d[s])); <span class="comment">// 将起点放入最小堆中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">while</span>(!minHeap.empty())&#123; </span><br><span class="line">            Node temp=minHeap.top(); <span class="comment">// 堆顶是 d[] 最小的</span></span><br><span class="line">            minHead.pop(); <span class="comment">// 将堆顶出堆。因为堆顶要么这次被访问，要么已经被访问过，所以没用了。</span></span><br><span class="line">            <span class="keyword">if</span>(vis[temp.v]==<span class="literal">false</span>)&#123; <span class="comment">// 如果当前顶点没有被访问</span></span><br><span class="line">                u=temp.v;  </span><br><span class="line">            	MIN=temp.dis;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找不到小于 INF 的 d[u]，表示剩余顶点与起点不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 如果 j 未访问 &amp;&amp; j 可达 &amp;&amp; 以 u 为中介点可以使 d[j] 更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;G[u][j]!=INF&amp;&amp;d[u]+G[u][j]&lt;d[j])&#123;</span><br><span class="line">                d[j]=d[u]+G[u][j]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">                <span class="comment">// 将优化过的 d[j] 放入最小堆，这里可能导致 d[j] 多次入队</span></span><br><span class="line">                <span class="comment">// 如果 d[j] 之前已经入过队且还没有出队，则 d[j] 会再次入队</span></span><br><span class="line">                minHeap.push(Node(j,d[j])); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------邻接表 Dijkstra 堆优化--------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    fill(d,d+n,INF);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node&gt; minHeap;</span><br><span class="line">    minHeap.push(Node(s,d[s]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">while</span>(!minHeap.empty())&#123;</span><br><span class="line">            Node temp=minHeap.top();</span><br><span class="line">            minHeap.pop();</span><br><span class="line">            <span class="keyword">if</span>(vis[temp.v]==<span class="literal">false</span>)&#123;</span><br><span class="line">                u=temp.v;</span><br><span class="line">                MIN=temp.dis;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;adj[u].size();j++)&#123;</span><br><span class="line">            <span class="comment">// 如果 j 未被访问 &amp;&amp; 以 u 为中介点 d[j] 可以优化</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[u]+adj[u][j].dis&lt;d[j])&#123;</span><br><span class="line">                d[j]=d[u]+adj[u][j]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">                minHeap.push(Node(j,d[j])); <span class="comment">// 将优化过的 d[j] 放入最小堆中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用最小堆优化过的 Dijkstra 算法的时间复杂度降为 O(VlogV)。因为选择 u 的时间复杂度将为 O(logV) 了。</p>
<p><strong>记录每一条最短路径</strong></p>
<p>数组 d 的更新条件 “以 u 为中介点可以使起点 s 到顶点 v 的最短距离 d[v] 更优” 意味着，使 d[v] 变得更小的方案是让 u 作为 s 到 v 最短路径上 v 的前一个节点，即 s → … → u → v。记录最短路径就是将这个信息记录下来。</p>
<p>设数组 pre[]，令 pre[v] 表示从起点 s 到顶点 v 的最短路径上 v 的前一个顶点（即前驱结点）的编号。在优化 d[v] 时，可以将 u 赋给 pre[v]。最终，最短路径上每一个节点的前驱节点都可以被记录下来。</p>
<p>一般，从起点 s 到顶点 v 的最短路径不止有一条，可以将 pre 数组声明为 <code>vector&lt;int&gt; pre[MAX_V]</code>。这样对每个顶点 v 来说，pre[v] 就是一个变长数组 vector，里面存放顶点 v 的所有能产生最短路径的前驱结点。</p>
<p>二维的 pre 数组不需要被赋初值。</p>
<p>pre 数组的更新过程如下：</p>
<ol type="1">
<li><p>d[u]+G[u][v]&lt;d[v]</p>
<p>此时说明以 u 为中介点，可以使 d[v] 更优，此时 v 的前驱节点为 u。</p>
<p>先将 pre[v] 清空，再将 u 加入到 pre[v] 中。</p></li>
<li><p>d[u]+G[u][v]==d[v]</p>
<p>此时说明以 u 为中介点可以找到一条相同距离的路径，因此直接将 u 添加到 pre[v] 中即可。</p></li>
</ol>
<p>pre 数组计算完成后，使用 DFS 从终点开始遍历 pre 数组，遍历的过程会形成一棵递归树。路径的起点是树的叶子节点。</p>
<p>记录 DFS 遍历过程中的路径，就可以得到最短路径。DFS 递归到起点时终止递归。由于递归的原因，记录在 tempPath 中的路径是从终点到起点倒着存储的。</p>
<h3 id="bellman-ford-算法"><strong>Bellman-Ford 算法</strong></h3>
<p>BF 算法可以处理有负权边的图。</p>
<p><strong>图中的环</strong></p>
<p>环，也就是从某个顶点出发，经过若干个不同的顶点之后可以回到该顶点的情况。</p>
<p>根据环中边的边权之和的正负，环可以分为零环、正环和负环。</p>
<p>零环和正环不会影响最短路径的求解，因为零环和正环不会使最短路径更短。</p>
<p>如果图中有负环，且从起点可以到达，那么就会影响最短路径的求解；如果负环不能从起点到达，则最短路径的求解不会受影响。</p>
<p><strong>基本思想</strong></p>
<p>BF 算法设置一个数组 d，用来存放从起点到达其它各顶点的最短距离。</p>
<p>BF 算法返回一个 bool 值：如果图中存在从起点可达的负环，那么函数返回 false；否则，函数返回 true，此时数组 d 中存放的值就是从起点到达各顶点的最短距离。</p>
<p>BF 算法需要对图中的边进行 V-1 轮操作，每轮都遍历图中的所有边：对每条边 u→v，如果以 u 为中介点可以使 d[v] 更小，即 d[u]+length[u→v]&lt;d[v] 成立时，就用 d[u]+length[u→v] 更新 d[v]。在 V-1 轮操作后，如果图中没有从起点可达的负环，则数组 d 中的所有值都应当已经达到最优。因此，此时在对所有边进行一轮操作，判断是否有某条边依然满足 d[v]&gt;d[u]+length[u→v]，如果有，则说明图中有从起点可达的负环，算法返回 false，表示没有最短路径，路径可以无限缩短；否则，说明数组 d 的所有值已经达到最优，返回 true。</p>
<p>由此可以看出，BF 算法的时间复杂度是 O(VE)，其中 V 是顶点的个数，E 是边的个数。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V<span class="number">-1</span>;i++)&#123; <span class="comment">// 共循环 V-1 次，V 为顶点的个数</span></span><br><span class="line">    <span class="keyword">for</span>(each edge u→v)&#123; <span class="comment">// 每次都遍历所有的边</span></span><br><span class="line">        <span class="keyword">if</span>(d[v]&gt;d[u]+length[u→v])&#123; <span class="comment">// 如果以 u 为中介点，可以使 d[v] 更优</span></span><br><span class="line">            d[v]=d[u]+length[u→v]; <span class="comment">// 松弛 d[v]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(each edge u→v)&#123; <span class="comment">// 最后再遍历一次所有的边</span></span><br><span class="line">    <span class="keyword">if</span>(d[u]+length[u→v]&lt;d[v])&#123; <span class="comment">// 如果依旧可以松弛</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 说明图中有起点可达的负环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 图中没有起点可达的负环，数组 d 的所有值已经更新到最优</span></span><br></pre></td></tr></table></figure>
<p><strong>简单证明 BF 算法</strong></p>
<ol type="1">
<li>如果最短路径存在，则最短路径上顶点的个数不会超过 V 个，因为整个图中顶点个数就只有 V 个。</li>
<li>如果把起点 s 作为一棵树的根节点，把其他节点按照最短路径的节点顺序连接，就会生成一棵最短路径树。最短路径树中节点的个数不会超过 V 个，则最短路径树的高度一定不会超过 V。因为包含 V 个顶点的树的最大高度为 V。</li>
<li>初始状态下 d[s]=0，因此在接下来的步骤中 d[s] 不会改变，即最短路径树的根节点被确定。BF 算法遍历一次所有边后，最短路径树中第二层节点也就被确定下来了。由于最短路径树的高度不超过 V，所以 BF 算法的松弛操作不会超过 V-1 次。</li>
</ol>
<p>由于 BF 算法需要遍历所有边，所以使用邻接矩阵存储表会比较方便。如果使用邻接矩阵，则会使 BF 算法的时间复杂度上升为 <span class="math inline">\(O(V^3)\)</span>。</p>
<p>下面是以邻接表存储图的 BF 算法的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 为邻接边的目标顶点，dis 为邻接边的边权</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">10000</span>; <span class="comment">// 图中顶点的最大个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大的数，表示不可达</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">// 邻接矩阵表示的图</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">// 从起点到达其他顶点的最短路径长度数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BF</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为图中顶点的个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 填充距离数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 起点到达自身的距离为 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123; <span class="comment">// 最外层的 n-1 次循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 遍历每一条边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;Adj[j].size();k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> endNode=Adj[j][k].v; <span class="comment">// 目标顶点</span></span><br><span class="line">                <span class="keyword">int</span> interNode=j; <span class="comment">// 中介顶点</span></span><br><span class="line">                <span class="keyword">int</span> len=Adj[j][k].dis; <span class="comment">// 从中介顶点到目标顶点的的边权</span></span><br><span class="line">                <span class="keyword">if</span>(d[endNode]&lt;d[interNode]+len)&#123; <span class="comment">// 如果以 j 为中介点可以松弛</span></span><br><span class="line">                    d[endNode]=d[interNode]+len; <span class="comment">// 松弛</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断负环是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 遍历每一条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[i].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> endNode=Adj[i][j].v;</span><br><span class="line">            <span class="keyword">int</span> interNode=i;</span><br><span class="line">            <span class="keyword">int</span> len=Adj[i][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[endNode]&lt;d[interNode]+len)&#123; <span class="comment">// 如果依旧可以松弛</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 存在从起点可达的负环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 数组 d 已达到最优，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将 BF 算法优化为 SPFA 算法 Shortest Path Faster Algorithm 快速最短路径算法</strong></p>
<p>BF 算法在每一轮遍历时，都要访问图中所有的边，这会导致大量无效访问。<strong>因为，只有在某个顶点 u 的 d[u] 值改变时，从它出发的边的邻接点 v 的 d[v] 值才有可能改变。</strong></p>
<p>因此，可以对 BF 进行如下优化：建立一个<strong>队列</strong>，每次将队首顶点 u 取出，然后对从 u 出发的所有边 u→v 进行松弛操作，如果可以松弛，则更新 d[v]。此时如果 v 不在队列中，就把 v 加入队列。这样操作直到队列为空（说明图中没有从起点可达的负环），或是某个顶点的入队次数超过 V-1 次（说明图中有从起点可达的负环）。</p>
<p>伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">起点 s 入队;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">    取出队首元素 u;</span><br><span class="line">    <span class="keyword">for</span>(u 的所有邻接边 u→v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">            d[v]=d[u]+dis;</span><br><span class="line">            <span class="keyword">if</span>(v当前不在队列中)&#123;</span><br><span class="line">                v入队;</span><br><span class="line">                <span class="keyword">if</span>(v入队的次数大于 n<span class="number">-1</span>)&#123;</span><br><span class="line">                    说明有可达的负环，<span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编码要点</strong></p>
<ol type="1">
<li>使用一个 int 数组 num[] 记录顶点 v 的入队次数 num[v]</li>
<li>使用一个 bool 数组 inq[] 记录顶点 v 是否在队列中</li>
</ol>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>; <span class="comment">// 图中最大节点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大数，表示不可达</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">// 记录起点到其他节点的最短路径的距离数组</span></span><br><span class="line"><span class="keyword">bool</span> inq[maxv]; <span class="comment">// 记录节点是否在队列中</span></span><br><span class="line"><span class="keyword">int</span> num[maxv]; <span class="comment">// 记录节点的入队次数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// 边的终点和边权</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">// 图 G 的邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为图中顶点的个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 初始化 d 数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 起点 s 到自身的距离为 0</span></span><br><span class="line">    fill(inq,inq+n,<span class="literal">false</span>); <span class="comment">// 初始化入队标记数组</span></span><br><span class="line">    fill(num,num+n,<span class="number">0</span>); <span class="comment">// 初始化记录入队次数的数组</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q; <span class="comment">// 队列</span></span><br><span class="line">    Q.push(s); <span class="comment">// 起点入队</span></span><br><span class="line">    num[s]++; <span class="comment">// 入队次数加一</span></span><br><span class="line">    inq[s]=<span class="literal">true</span>; <span class="comment">// 标记为已入队</span></span><br><span class="line">    <span class="comment">// 算法主体</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=Q.front(); <span class="comment">// 获得队头</span></span><br><span class="line">        Q.pop(); <span class="comment">// 队头出队</span></span><br><span class="line">        inq[u]=<span class="literal">false</span>; <span class="comment">// 标记队头出队</span></span><br><span class="line">        <span class="comment">// 遍历 u 的所有邻接顶点 v</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">            <span class="keyword">int</span> len=Adj[u][i].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+len)&#123; <span class="comment">// 松弛操作</span></span><br><span class="line">                d[v]=d[u]+len;</span><br><span class="line">                <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123; <span class="comment">// 如果 v 不在队列中</span></span><br><span class="line">                    Q.push(v); <span class="comment">// v 入队</span></span><br><span class="line">                    inq[v]=<span class="literal">true</span>; <span class="comment">// 将 v 标记为已入队</span></span><br><span class="line">                    num[v]++; <span class="comment">// v 的入队次数加一</span></span><br><span class="line">                    <span class="keyword">if</span>(num[v]&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果入队次数大于 n-1 次，说明有负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 无可达负环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全源最短路径算法"><strong>全源最短路径算法</strong></h2>
<h3 id="floyd-算法">Floyd 算法</h3>
<p>Floyd 算法用来解决全源最短路径问题。即对给定的图 G(V,E)，求任意两点 u，v 之间的最短路径长度。</p>
<p>时间复杂度为 <span class="math inline">\(O(n^3)\)</span>。</p>
<p>时间复杂度将图的顶点限制到了 200 以内。</p>
<p><strong>Folyd 算法的基本思想</strong></p>
<p>如果存在顶点 k，使得以 k 作为中介点时，顶点 i 和 顶点 j 的当前最短距离缩短，则使用 k 作为顶点 i 与顶点 j 的中介点。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">枚举顶点 k∈[<span class="number">1</span>,n]</span><br><span class="line">    以顶点 k 为中介点，枚举所有顶点对 i 和 j，i ∈ [<span class="number">1</span>,n]，j ∈ [<span class="number">1</span>,n]</span><br><span class="line">    	如果 dis[i][k]+dis[k][j]&lt;dis[i][j] 成立</span><br><span class="line">    		赋值 dis[i][j]=dis[i][k]+dis[k][j]</span><br></pre></td></tr></table></figure>
<p><strong>编码要点</strong></p>
<ol type="1">
<li>使用三层 for 循环 k→i→j</li>
<li>不能将最外层的 k 循环放到内层，即产生 i→j→k 的三重循环，这样会导致出错。因为，如果较后访问的 dis[u][v] 有了优化之后，前面访问的 dis[i][j] 会因为已经被访问而无法获得进一步的优化。</li>
</ol>
<h1 id="最小生成树">最小生成树</h1>
<p>最小生成树是在一个给定的<strong>无向连通图</strong> G(V,E) 中求一棵树 T，使得这棵树拥有图 G 中的所有顶点，且所有边都是来自图 G 中的边，并且满足整棵树的边权和最小。</p>
<p>最小生成树有三个重要性质：</p>
<ol type="1">
<li>最小生成树是树，因此，其边数等于定点数减一，且树内一定不会有环。</li>
<li>对于给定的图 G(V,E)，其最小生成树可以不唯一，但其边权和一定是唯一的。</li>
<li>最小生成树是在无向图上生成的，因此其根节点可以是这棵树上的任意一个节点。</li>
</ol>
<p>求最小生成树一般有两种算法，即 prim 算法和 kruskal 算法。这两个算法都是采用了贪心法的思想，只是贪心的策略不太一样。</p>
<h2 id="prim-算法">Prim 算法</h2>
<p><strong>基本思想</strong></p>
<p>对图 G(V,E) 设置集合 S，存放已经被访问的顶点，然后每次从集合 V-S 中选择与集合 S 的最短距离最小的一个顶点，记为 u，访问并加入到集合 S 中。之后，令顶点 u 为中介点，优化所有从 u 能到达的顶点 v 与集合 S 之间的最短距离。这样的操作重复执行 V 次，直到集合 S 中已包含所有顶点。</p>
<p><strong>编码要点</strong></p>
<ol type="1">
<li>集合 S 的实现。与 Dijkstra 相同，使用一个 bool 型数组 vis[] 标记顶点是否已经被访问过。vis[v]=true 表示顶点 v 已经被访问，vis[v]=false 表示顶点 v 未被访问。以访问的顶点就相当于以加入到 S 中。</li>
<li>顶点 <span class="math inline">\(V_i,(0\le i\le n-1)\)</span> 与集合 S 的最短距离。使用一个 int 数组 d[] 来存放顶点 <span class="math inline">\(V_i,(0\le i\le n-1)\)</span> 与集合 S 的最短距离。初始时，令起点 d[s] 等于 0，其余与顶点都赋为一个很大的数 INF，表示不可达。</li>
</ol>
<p><strong>Prim 算法与 Dijkstra 算法的不同之处</strong>在于，数组 d[] 在 Prim 算法中表示顶点 <span class="math inline">\(V_i,(0\le i\le n-1)\)</span> 与集合 S 的最小距离，在 Dijkstra 算法中表示顶点 <span class="math inline">\(V_i,(0\le i\le n-1)\)</span> 与起点 s 的最小距离。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Prim(G,d[])&#123; <span class="comment">// G 为图，数组 d 存放顶点与集合 S 的最短距离</span></span><br><span class="line">    初始化;</span><br><span class="line">    <span class="keyword">for</span>(循环 n 次)&#123;</span><br><span class="line">        u = 使 d[u] 最小的还未被访问的顶点的编号;</span><br><span class="line">        标记 u 为以访问;</span><br><span class="line">        <span class="keyword">for</span>(从 u 出发能到达的所有顶点 v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v 未访问 &amp;&amp; 以 u 为中介点使得 v 与集合 S 的最短距离 d[v] 更优)&#123;</span><br><span class="line">                将 length[u→v] 赋值给 d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Prim 算法与 Dijkstra 算法实际上是相同的思路，只是数组 d[] 的含义不同</strong></p>
<p><strong>邻接矩阵与邻接表分别实现 Prim 算法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>; <span class="comment">// 图中最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大值，表示不可达</span></span><br><span class="line"><span class="keyword">int</span> G[maxv][maxv]; <span class="comment">// 邻接矩阵，矩阵中的值表示边权</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 为边的目标顶点，dis 为边权</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">// 存放顶点与集合的最小距离的数组</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxv]; <span class="comment">// 标记顶点是否被访问</span></span><br><span class="line"><span class="comment">/*-----------------------------邻接矩阵版---------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为人为指定的最小生成树的根节点，n 为图中的节点总数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 初始化距离数组</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 初始化标记数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 根节点为集合 S 中的第一个节点，距离集合 S 的距离为 0</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="comment">// 记录最小生成树的边权和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 循环 n 次，每次将一个顶点加入集合 S</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minl=INF; <span class="comment">// u 使 d[u] 最小，minl 存放最小的 d[u]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 顶点 j 未访问 &amp;&amp; d[j] 比 minl 小</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minl)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minl=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 u=-1，表示剩余顶点与集合 S 不连通，该图没有最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 标记 u 为已访问，即将顶点 u 加入集合 S</span></span><br><span class="line">        ans+=d[u]; <span class="comment">// 将与集合 S 距离最小的边加入最小生成树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 顶点 j 未访问 &amp;&amp; 从 u 可以到达顶点 j &amp;&amp; 以 u 为中介点可以使 d[j] 更小</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;G[u][j]!=INF&amp;&amp;d[u]+G[u][j]&lt;d[j])&#123;</span><br><span class="line">                d[j]=G[u][j]; <span class="comment">// 松弛 d[j]，这是与 Dijkstra 不同的地方</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------------邻接表版---------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为人为指定的最小生成树的根节点，n 为图中顶点的个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 初始化距离数组</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 初始化标记数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 根节点为集合 S 中的第一个节点，距离集合 S 的距离为 0</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="comment">// 存放最小生成树的边权和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 循环 n 次</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minl=INF; <span class="comment">// u 使 d[u] 最小，minl 记录最小的 d[u]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 顶点 j 未访问 &amp;&amp; d[j] 小于 minl</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minl)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minl=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// u=-1 说明剩余顶点与集合 S 不连通，图 G 不存在最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为以访问，即加入集合 S</span></span><br><span class="line">        ans+=d[u]; <span class="comment">// 记录最小生成树新加的边的边权</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v; <span class="comment">// 通过邻接表直接获得 u 的可达顶点</span></span><br><span class="line">            <span class="comment">// 顶点 v 不在集合 S 中 &amp;&amp; 以 u 为中介点可以使 d[v] 更小</span></span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;d[u]+Adj[u][j].dis&lt;d[v])&#123;</span><br><span class="line">                d[v]=Adj[u][j].dis; <span class="comment">// 松弛，这是与 Dijkstra 不同的地方</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 Dijkstra 相同，这种写法的 prim 算法的时间复杂度为 <span class="math inline">\(O(V^2)\)</span>。其中外层循环共循环 V 次，内层循环寻找 u 也需要 V 次。同样可以使用堆优化降低 prim 算法的时间复杂度。</p>
<h2 id="kruskal-算法-克鲁斯卡尔算法">kruskal 算法 克鲁斯卡尔算法</h2>
<p>kruskal 同样用于计算最小生成树。与 prim 算法不同的是，kruskal 算法使用的是边贪心的策略。</p>
<p><strong>基本思想</strong></p>
<ol type="1">
<li>在初始状态时隐去图中所有的边，这样图中的每个顶点都自成一个连通块。</li>
<li>对所有的边按边权从小到大进行排序。</li>
<li>按边权从小到大测试所有的边，如果当前测试边所连接的两个个顶点不在同一个连通块中，则把这条测试边加入到最小生成树中；否则将边舍弃。</li>
<li>重复执行步骤 3，直到最小生成树中的边数等于总顶点数减 1 或是测试完所有边时结束步骤 4。</li>
<li>当步骤 4 结束时，如果最小生成树的边数小于总顶点数减一，说明该图不连通。</li>
</ol>
<p>简单来说，kruskal 算法的思想就是：每次选择图中边权最小的边，如果边两端的顶点在不同的连通块中，就把这条边加入最小生成树。</p>
<p><strong>编码细节</strong></p>
<ol type="1">
<li><p>由于需要判断边的两个端点是否在同一个连通块中，并且需要寻找边权最小的边。所以需要定义一个结构体，里面存放边的两个端点和边权。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v; <span class="comment">// 边的两个端点编号</span></span><br><span class="line">    <span class="keyword">int</span> cost; <span class="comment">// 边权</span></span><br><span class="line">&#125;E[maxe]; <span class="comment">// 最多有 maxe 条边</span></span><br></pre></td></tr></table></figure></li>
<li><p>定义边的排序函数，使边按照边权从小到大排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost&lt;b.cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用并查集表示连通块。</strong>判断边的两个端点是否在同一个连通块中，就可以转换为判断两个端点是否在同一个集合中。</p></li>
<li><p><strong>将测试边加入最小生成树，可以转换为将测试边的两个端点所在的集合合并。</strong></p></li>
</ol>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans=<span class="number">0</span>; <span class="comment">// 表示最小生成树的边权之和</span></span><br><span class="line">    numEdge=<span class="number">0</span>; <span class="comment">// 表示最小生成树的当前边数</span></span><br><span class="line">    将所有的边按照从小到大排序;</span><br><span class="line">    <span class="keyword">for</span>(按边权从小打大枚举所有边)&#123;</span><br><span class="line">        <span class="keyword">if</span>(当前测试边的两个端点在不同的连通块中)&#123;</span><br><span class="line">            将该测试边加入最小生成树中;</span><br><span class="line">            ans+=测试边的边权;</span><br><span class="line">            numEdge++;</span><br><span class="line">            <span class="keyword">if</span>(当前边数 nunEdge 等于顶点数减 <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>kruskal 算法的代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxn=<span class="number">1000</span>; <span class="comment">// 最大的顶点个数</span></span><br><span class="line"><span class="keyword">const</span> maxe=<span class="number">1000</span>; <span class="comment">// 最大边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v; <span class="comment">// 边的两个端点编号</span></span><br><span class="line">    <span class="keyword">int</span> cost; <span class="comment">// 边权</span></span><br><span class="line">&#125;;</span><br><span class="line">edge E[maxe]; <span class="comment">// 图使用 E 来表示</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span>&#123; <span class="comment">// 边的比较函数，边权小的在前，边权大的在后</span></span><br><span class="line">    <span class="keyword">return</span> a.cost&lt;b.cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> father[N]; <span class="comment">// 并查集数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 并查集查询函数，使用路径压缩</span></span><br><span class="line">    <span class="keyword">int</span> a=x; <span class="comment">// 将 x 记录下来，以便从 x 开始压缩查询路径</span></span><br><span class="line">    <span class="keyword">while</span>(x!=father[x])&#123; <span class="comment">// 找到 x 所在集合的根节点并存储在 x 中</span></span><br><span class="line">        x=father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a!=father[a])&#123; <span class="comment">// 从 a 开始压缩路径</span></span><br><span class="line">        <span class="keyword">int</span> z=a;</span><br><span class="line">        a=father[a];</span><br><span class="line">        father[z]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 返回集合的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// kruskal 算法返回最小生成树的边权之和，参数 n 为顶点个数，m 为图的边数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="comment">// 最小生成树的边权之和</span></span><br><span class="line">    <span class="keyword">int</span> numEdge=<span class="number">0</span>; <span class="comment">// 当前生成树的边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">// 假设图中顶点的编号为 [1,n]</span></span><br><span class="line">        father[i]=i; <span class="comment">// 并查集初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(E,E+m,cmp); <span class="comment">// 所有边按照边权从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123; <span class="comment">// 按边权从小到大的顺讯，枚举所有的边</span></span><br><span class="line">        <span class="keyword">int</span> faU=findFather(E[i].u); <span class="comment">// 顶点 u 所在集合的根节点</span></span><br><span class="line">        <span class="keyword">int</span> faV=findFather(E[i].v); <span class="comment">// 顶点 v 所在集合的根节点</span></span><br><span class="line">        <span class="keyword">if</span>(faU!=faV)&#123; <span class="comment">// 如果两个顶点不在同一个连通块中</span></span><br><span class="line">            father[faU]=faV; <span class="comment">// 集合合并，将测试边加入到最小生成树中</span></span><br><span class="line">            ans+=E[i].cost; <span class="comment">// 边权之和增加测试边的边权</span></span><br><span class="line">            numEdge++; <span class="comment">// 当前生成树的边数加一</span></span><br><span class="line">            <span class="keyword">if</span>(numEdge==n<span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 边数等于顶点数减一时结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numEdge!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 图不是连通图，返回 -1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans; <span class="comment">// 返回最小生成树的边权之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kruskal 算法的时间复杂度主要来自于边的排序，因此，其时间复杂度为 O(ElogE)，E 为图中的边数。</p>
<p>显然 kruskal 算法适用于顶点多，边少的情况。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>a cup of salt</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="hespoon WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="hespoon Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="prev" title="设计模式">
      <i class="fa fa-chevron-left"></i> 设计模式
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" rel="next" title="文件系统">
      文件系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.</span> <span class="nav-text">图的定义与相关术语</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">2.</span> <span class="nav-text">图的存储</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">3.</span> <span class="nav-text">图的遍历</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">4.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">4.1.</span> <span class="nav-text">单源最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dijkstra-%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.1.</span> <span class="nav-text">Dijkstra 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bellman-ford-%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">Bellman-Ford 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">全源最短路径算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#floyd-%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.1.</span> <span class="nav-text">Floyd 算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#prim-%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">Prim 算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kruskal-%E7%AE%97%E6%B3%95-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">kruskal 算法 克鲁斯卡尔算法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hespoon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">hespoon</p>
  <div class="site-description" itemprop="description">全心全意的投入生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hespoon" title="GitHub → https://github.com/hespoon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hezaojian@gmail.com" title="E-Mail → mailto:hezaojian@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fas fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hespoon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">142k</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        


  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1279024191&web_id=1279024191"></script>
  </div>






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
