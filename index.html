<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-hespoon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-hespoon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-hespoon.png">
  <link rel="mask-icon" href="/images/hespoon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hespoon.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":"//cdn.jsdelivr.net/gh/user/repo@version/file","lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="全心全意的投入生活">
<meta property="og:type" content="website">
<meta property="og:title" content="Spirit">
<meta property="og:url" content="http://hespoon.github.io/index.html">
<meta property="og:site_name" content="Spirit">
<meta property="og:description" content="全心全意的投入生活">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="hespoon">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hespoon.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Spirit</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Spirit</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hespoon" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/06/18/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%9F%B9%E8%AE%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%9F%B9%E8%AE%AD/" class="post-title-link" itemprop="url">深信服培训</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-18 11:32:56 / Modified: 15:04:15" itemprop="dateCreated datePublished" datetime="2020-06-18T11:32:56+08:00">2020-06-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="工作内容"><a class="markdownIt-Anchor" href="#工作内容"></a> 工作内容</h2>
<p>使用 C 语言实现了一系列构建 JSON 结构的 API，支持 string、number、bool、array 和 object 五种 JSON 对象。同时实现了 JSON 转 YAML 的功能，用户通过 <code>json_save</code> API 将创建的 JSON 对象转换为 YAML 格式。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/18/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%9F%B9%E8%AE%AD/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/04/20/JSP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/JSP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">JSP 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 09:22:39" itemprop="dateCreated datePublished" datetime="2020-04-20T09:22:39+08:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-14 12:13:02" itemprop="dateModified" datetime="2020-06-14T12:13:02+08:00">2020-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="jsp-learn"><a class="markdownIt-Anchor" href="#jsp-learn"></a> JSP Learn</h1>
<p>JSP 技术以 Java 语言作为脚本语言。</p>
<p>使用 JSP 标签在 HTML 网页中插入 Java 代码。</p>
<p>JSP 标签通常以 <code>&lt;%</code> 开头，以 <code>%&gt;</code> 结尾。</p>
<p>JSP 通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p>
<p>JSP 标签有多种功能，比如访问数据库、记录用户选择信息、访问 JavaBeans 组件等，还可以在不同的网页中传递控制信息和共享信息。</p>
<p>JSP 直接在 HTML 网页中动态嵌入元素。</p>
<p>服务器调用的是已经编译好的 JSP 文件。</p>
<p>JSP 基于 Java Servlet API。</p>
<p>JSP 可以与处理业务逻辑的 Servlet 一起使用。</p>
<p>网络服务器需要一个 JSP 引擎，也就是一个容器来处理 JSP 界面，容器负责截获 JSP 页面的请求。</p>
<p>Apache 内嵌了 JSP 容器。</p>
<p>JSP 容器与 Web 服务器协同合作，为 JSP 的正常运行提供必要的运行环境和其他服务，并且能够正确识别专属于 JSP 网页的特殊元素。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/20/JSP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-17 06:54:14 / Modified: 13:44:00" itemprop="dateCreated datePublished" datetime="2020-03-17T06:54:14+08:00">2020-03-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h1>
<ul>
<li>
<p>TCP 协议 Transmission Control Protocol</p>
</li>
<li>
<p>TCP 是传输层的协议，解决传输的可靠、有序、无丢失和不重复。</p>
</li>
<li>
<p>面向连接的，每条 TCP 连接只有两个端点</p>
</li>
<li>
<p>全双工通信，通信双发在任何时候都能发送数据，有缓存，用于临时存放双向通信数据</p>
</li>
<li>
<p>面向字节流，TCP 将应用程序交付的数据视为一串无结构的字节流</p>
</li>
<li>
<p>TCP 首部最短 20B。</p>
<ul>
<li>源端口，目的端口各占 2B。</li>
<li>序号字段 4B，每个字节都会编号。</li>
<li>确认字段 4B，是期望收到的报文段数据的第一个字节的序号</li>
<li>数据偏移，4 位。单位是 4B。表示首部的长度</li>
<li>保留字段 6 位</li>
<li>6 个状态位。URG 紧急位、ACK 确认位、PSH 推送位、RST 复位位、SYN 同步位、FIN 终止位</li>
<li>窗口字段。指出现在允许对方发送的数据量，单位为字节。</li>
<li>校验和。 2B，校验首部和数据两部分，计算时要加上伪首部。</li>
<li>紧急字段指针，2B。指出本报文段中紧急数据共有多少字节。</li>
<li>选项字段，长度可变。</li>
<li>填充字段。使头部的长度为 4B 的整数倍。</li>
</ul>
</li>
<li>
<p>建立连接的 3 次握手</p>
<ul>
<li>SYN=1，seq=x，不含应用层数据，消耗一个序号</li>
<li>SYN=1，ACK=1，ack=x+1，seq=y，不含应用层数据，消耗一个序号，服务器为连接分配资源，因此易受 SYN 洪泛攻击</li>
<li>ACK=1，seq=x+1，ack=y+1，可以开始携带应用层数据，客户端为连接分配资源</li>
<li>为何要三次握手？为了解决网络中存在延迟的重复分组。比如，客户端发送了一个连接请求，但在网络中长时间的滞留了，以至于延迟到连接结束后的某个时间到达了服务器。服务器会误以为这是一个新的连接请求，然后响应该请求并发出确认，为连接分配资源。如果不采用三次握手，客户端不理睬服务器的确认，不会向服务器传输数据，因此服务器的资源就被浪费了。</li>
</ul>
</li>
<li>
<p>断开连接的 4 次挥手</p>
<ul>
<li>FIN=1，seq=u，客户端主动请求断开连接</li>
<li>ACK=1，seq=v，ack=u+1，此时客户端到服务器的连接已经释放了，TCP 处于半关闭状态，服务器发送数据，客户端依旧要接收。客户端不能发送数据，但可以发送确认报文。</li>
<li>FIN=1，ACK=1，seq=w，ack=u+1，此时服务器请求释放连接</li>
<li>ACK=1，seq=u+1，ack=w+1，客户端收到服务器发来的连接释放报文后，必须要发出确认，然后等待 2 个报文最大生存时间后关闭连接。服务器端在接受到客户端的确认报文后就断开连接。</li>
<li>为何要四次挥手？<br />
因为在客户端主动要求断开连接后，服务器端还可能存在需要发送的数据，要等这些数据发送完后，再断开 TCP 连接。</li>
<li>为何要有 TIME_WAIT 阶段<br />
因为客户端在发送确认报文后，服务器端可能没有收到，此时服务器会再次发送请求断开连接的报文，客户端应当保持 TCP 连接一段时间，以便保证服务器端收到了自己的确认报文。同时，TCP 连接占用了一个套接字，连接释放后，该套接字会被其他连接重复使用。若没有 TIME_WAIT 状态，网络中可能还存在当前连接产生的报文，连接释放后，旧的报文可能会被新的连接接收，造成信息混乱。因此，TIME_WAIT 状态主要是保证当前连接产生的报文在网络中已经全部消失了。</li>
</ul>
</li>
<li>
<p>TCP 可靠传输</p>
<ul>
<li>TCP 通过校验机制保证传输的报文段没有差错</li>
<li>TCP 通过首部的序号字段保证数据能够有序的提交给应用层，对每个字节进行编号，同时会丢弃重复数据。</li>
<li>TCP 通过首部的确认号表示期望收到的下一报文段数据的第一个字节的序号，发送方会在缓存中存储那些已经发送但未确认的报文段，以便在需要时重传。使用累计确认</li>
<li>TCP 重传。
<ul>
<li>超时重传<br />
TCP 为每一个发送的报文段都设置一个计时器。计时器设置的重传时间到期但还没有收到确认，就要重传这一报文段。超时重传时间 RTO，加权平均往返时间 RTTs，RTT 的偏差的加权平均值 RTTd。RTO = RTTs + 4 × RTTd，RTTs = ( 1 - α ) × 旧 RTTs + α × 新 RTT 样本，RTTd = ( 1 - β ) × 旧 RTTd + β × |RTTs - 新 RTT 样本|。α 和 β 都是小于 1 大于 0 的系数。第一个 RTTs 等于测量到的 RTT，第一个 RTTd 等于测量到的 RTT 的值的一半。</li>
<li>冗余 ACK<br />
发送方可以通过冗余 ACK 来检测丢包情况。TCP 规定，每当接收方收到比期望序号大的失序报文段时，就发送一个冗余 ACK，指明下一个期待字节的序号。当发送方收到对同一报文段的三个冗余 ACK 时，就认为该报文段已经丢失。冗余 ACK 也用在了拥塞控制中。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TCP 流量控制</p>
<ul>
<li>TCP 提供一种基于滑动窗口协议的流量控制机制。</li>
<li>接收方根据自己缓存的大小，动态调整接收窗口的大小，就是调整头部中的窗口字段。限制发送方的发送速率。</li>
<li>发送方根据当前网络的拥塞情况调整拥塞窗口的大小。发送方的发送窗口取接收窗口和拥塞窗口两者中的最小值。</li>
</ul>
</li>
<li>
<p>TCP 拥塞控制</p>
<ul>
<li>两个窗口，接收窗口和拥塞窗口。发送窗口 = min(接受窗口，拥塞窗口)</li>
<li>四种算法，慢开始、拥塞避免、快重传、快恢复。四种算法是用来维护拥塞窗口的。
<ul>
<li>慢开始。刚开始发送报文段时，令拥塞窗口 = 1，即一个最长报文段的大小。每收到一个对新报文段的确认后，将拥塞窗口的值加 1，就是增大一个 MSS。一般每经过一个传输轮次，拥塞窗口的大小就会翻倍。慢开始一直把拥塞窗口增加到一个阈值后，就改用拥塞避免算法。</li>
<li>拥塞避免。发送端的拥塞窗口每经过一个 RTT 就增加 1，就是开始线性增加。</li>
<li>网络拥塞处理
<ul>
<li>超时<br />
当发送方检测到超时时，就将慢开始阈值设为当前拥塞窗口大小的一半，但不能小于 2，并将拥塞窗口的大小设为一个 MSS。然后开始执行慢开始算法。这样可以快速减少发送方发到网络中的分组数。</li>
</ul>
</li>
<li>快重传<br />
当发送方连续收到三个冗余 ACK 时，就直接重传接收方未收到的报文段，不用等到超时。</li>
<li>快恢复<br />
当发送方收到三个冗余 ACK 时，就将慢开始阈值设为当前拥塞窗口的一半，将拥塞窗口设为改变后的慢开始阈值，然后执行拥塞避免算法。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>UDP 协议，User Datagram Protocol</p>
</li>
<li>
<p>UDP 的优点</p>
<ul>
<li>UDP 无需建立连接，所以没有建立连接带来的延时，速度比较快。</li>
<li>UDP 不用维护连接状态，就是说不用维护发送接收缓存，不用记录确认序号和拥塞控制参数，消耗的资源就小一些。</li>
<li>分组头部开销小，只有 8B。</li>
<li>发送方的应用层能够更好的控制要发送的数据和发送时间。因为 UDP 没有拥塞控制，所以网络中的拥塞不会影响发送方的发送效率。</li>
</ul>
</li>
<li>
<p>UDP 应用</p>
<ul>
<li>一次性传输数据较少的应用。比如 DNS。</li>
<li>多媒体应用。比如实时视频会议。可靠的数据传输对这些应用来说不是最重要的。</li>
</ul>
</li>
<li>
<p>UDP 不保证可靠交付，数据的可靠性要通过应用层来完成。</p>
</li>
<li>
<p>UDP 面向报文，将应用层传下来的报文添加首部后就交给网络层，将网络层传上来的报文去除首部后就交给应用层。</p>
</li>
<li>
<p>UDP 数据报首部</p>
<ul>
<li>2B 的源端口号。需要对方回复时才会使用。</li>
<li>2B 的目的端口号。</li>
<li>2B 的长度标记，单位为 1B</li>
<li>2B 的校验和。是可选的。计算校验和时要在数据报之前添加 12B 的伪首部。校验整个数据报。</li>
</ul>
</li>
<li>
<p>TCP 与 UDP 的区别</p>
<ol>
<li>TCP 是有连接的，UDP 是无连接的</li>
<li>TCP 是可靠的，UDP 是不可靠的。接收方不会对 UDP 报文发送确认报文。</li>
<li>TCP 是面向字节流的，UDP 是面向报文的。TCP 发送报文时以字节为单位，应用层传来的数据报可拆分。UDP 不能拆分数据报。</li>
<li>TCP 有拥塞控制机制，UDP 没有。</li>
<li>TCP 首部开销大，UDP 首部开销小。</li>
<li>UDP 不需要维护连接状态，消耗资源小。</li>
<li>TCP 只支持点对点通信。UDP 可以一对一、一对多、多对一、多对多</li>
</ol>
</li>
<li>
<p>如何选择 TCP 与 UDP<br />
对实时性要求高，对可靠传输要求低时，一般选用 UDP。比如 DNS 服务，直播。对可靠性要求高时用 TCP。HTTP 协议一般都用 TCP。HTTP3 使用了基于 UDP 协议的QUIC 协议。可能是因为现在网络环境越来越好了吧，设备本身越来越可靠，协议上就可以偷些懒。</p>
</li>
<li>
<p>TCP 粘包</p>
<ul>
<li>指发送方发送的若干数据包在到达接收方时粘成了一包。从接收方缓存来看，后一包数据的头紧挨着前一包数据的尾。如果粘包是同一数据的不同部分，可以不处理。如果粘包之间没有关系，此时就必须要使用合理的拆包机制将包分开。</li>
<li>粘包原因
<ol>
<li>发送方默认使用 Nagle 算法，将多次间隔较小，数据量较小的数据报合并成一个数据量大的数据报发送，用于减少网络中的报文段，尽可能的利用网络带宽。</li>
<li>接收方读取接收缓存的速度比 TCP 写入缓存的速度慢。</li>
</ol>
</li>
<li>解决方法
<ul>
<li>发送方可以尝试关闭 Nagle 算法。接收方可以在应用层处理。将接收缓存的数据全部读完后，再分组。可以通过开始符和结束符的方式分组，也可以在数据报数据部分的开始部分记录数据的长度。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>HTTP HyperText Transfer Protocol</p>
<ul>
<li>HTTP 使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li>
<li>HTTP 是专门用来在两点之间传输数据的约定和规范</li>
<li>超文本就是指超越了普通文本，包含有图片、音频、视频和超链接</li>
<li>HTTP 由两个程序实现，一个客户端程序，一个服务器程序。</li>
<li>URL 地址包含两部分，存放文件的服务器地址和文件的存放路径</li>
<li>HTTP 使用 TCP 作为传输协议，应用通过套接字接口将 HTTP 请求发给 TCP 连接，同时也从套接字接口中接受响应信息。</li>
<li>持续连接。客户端与服务器在一个相当长的时间范围内通信时，所有的请求和相应都通过一个 TCP 连接发送，这种模式称为持续连接。</li>
<li>非持续连接。客户端与服务器在一个相当长的时间范围内通信时，每个请求和相应都通过一个单独的 TCP 连接发送。</li>
<li>HTTP 默认使用持续连接，也可以使用非持续连接。</li>
<li>HTTP 客户端进程运行在 80 号端口。</li>
<li>非持续连接中的 TCP 连接可以是串行的也可以是并行的。</li>
<li>HTTP 有两种报文，请求报文和相应报文。HTTP 的报文是明文传输。是无状态的，服务器不会记录客户端的任何信息。
<ul>
<li>请求报文
<ul>
<li>请求报文的第一行叫做请求行，后续的行叫做首部行。</li>
<li>请求行包含三个字段。方法字段、URL 字段和 HTTP 版本字段。</li>
<li>首部行 Host 指明了对象所在的主机</li>
<li>首部行 Connection 指明了是使用持续连接还是非持续连接</li>
<li>首部行 User-agent 指明了用户代理，即向服务器发送请求的浏览器的类型</li>
<li>Content-Length 字段，表明本次回应的数据长度。</li>
<li>Accept 字段用于声明可接受的数据格式。</li>
<li>Accept-Encoding 声明可接受的压缩方式</li>
<li>首部行后有一个空行。空行后是请求的实体。</li>
<li>GET 方法用与获取服务器内容，向服务器传递的参数加在 URL 中，只允许 ASCII 字符，有长度限制。请求的实体为空。</li>
<li>GET 方法是安全的和幂等的。<br />
幂等是指，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。<br />
安全是指，请求方法不会破坏服务器上的资源。</li>
<li>POST 方法一般用来向指定的资源提交数据进行处理请求，如上传表单和文件。数据包含在请求体中。</li>
<li>POST 方法是不安全和不幂等的。</li>
<li>HEAD 方法用于向服务器索要与 GET 请求相一致的响应，但是响应体不返回，只返回响应消息的头部。</li>
<li>PUT 方法用于向指定资源位置上传其最新内容，是幂等的。</li>
<li>DELETE 方法用于删除 URL 所标识的资源。</li>
</ul>
</li>
<li>响应报文
<ul>
<li>第一行是状态行。包含 HTTP 版本，状态码和状态描述</li>
<li>接下来每一行都表示一个 HTTP 首部，为客户端提供关于所发送数据的一些信息，并以一个空行结束</li>
<li>Content-Type 字段用于说明本次数据是什么格式。</li>
<li>Content-Encoding 说明数据的压缩方式</li>
<li>最后是数据块，包含了响应数据</li>
<li>200 OK 表示请求成功</li>
<li>302 Found 临时重定向</li>
<li>404 Not Found 请求失败，所请求的资源未在服务器上找到</li>
</ul>
</li>
</ul>
</li>
<li>HTTP 常见状态码</li>
</ul>
<ol>
<li>1xx 状态码 信息，服务器收到请求，需要请求者继续执行操作。100 Continue 继续、101 Switching Protocols 切换协议，只能切换到更高级的协议</li>
<li>2xx 状态码 操作成功。200 OK 请求成功、204 No Content 请求成功，但是响应报文的 body 部分没有数据</li>
<li>3xx 状态码 重定向。301 Moved Permanently 永久重定向、302 Found 临时移动、304 Not Modify 资源未修改，重定向至缓存文件。</li>
<li>4xx 状态码 客户端错误。400 Bad Request 客户端请求语法错误、401 Unanuthorized 请求用户的身份认证、403 Forbidden 服务器拒绝执行、404 Not Found 服务器未找到客户端请求的资源</li>
<li>5xx 状态码 服务端错误。500 Internal Server Error 服务器内部错误、501 Not Implemented 服务器不支持请求的功能、502 Bad GateWay 网关或代理服务器执行请求时，从远程服务器接收到了一个无效响应。</li>
</ol>
<ul>
<li>
<p>HTTP 重定向<br />
URL 重定向，也称 URL 转发，是一种当前实际资源，如页面，表单等迁移到新的 URL 下的时候，保持原有链接可用的技术。HTTP 使用 HTTP 重定向来执行此类操作。可以用于网站维护期间的临时跳转或者网站架构改变后为保持外部链接继续可用的永久重定向。<br />
重定向操作由服务器发送特殊的响应而触发，状态码是 3xx。浏览器接受到重定向响应后，会采用响应提供的新的 URL，并立即加载。<br />
永久重定向：表示原 URL 不再使用，应优先选用新的 URL。<br />
临时重定向：资源无法从其标准的地址访问，却可以从另外的地方访问。搜索引擎不会记录这个新的、临时的链接。临时重定向也可以用来显示临时性质的进度页面。<br />
特殊重定向：304 Not Modified 资源未修改，会使页面跳转到本地缓存的版本中。300 Multiple Choice 是一种手工重定向，以 Web 页面的形式呈现消息主题包含的一个可能的重定向链接列表，用户可以从中选择。</p>
</li>
<li>
<p>HTTPS</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw" target="_blank" rel="noopener">GoLang：你真的了解 HTTPS 吗？</a></li>
<li>运行在 SSL （Secure Sockets Layer 安全套接层 位于传输层和应用层之间）上，添加了加密和认证机制，更加安全。</li>
<li>HTTPS = HTTP over SSL/TLS，也就是说，HTTPS 在传输层 TCP 和应用层 HTTP 之间多了一层 SSL/TLS。SSL/TLS 协议作用在传输层和应用层之间，对应用数据进行加密传输。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc494izextj30u00fymyi.jpg" alt="STL+TSL.jpg" /></p>
<p>SSL，全称 Secure Socket Layer，在 1994 年由网景公司最早提出。TLS，全称 Transport Layer Security，在 1999 年基于 SSL3.0 版本上改进而来的。官方建议启用 SSL 而保留和采用 TLS。</p>
<ul>
<li>HTTPS 三大优势：数据加密，防窃听；身份验证，防冒充；完整性校验，防篡改。</li>
<li>通信需要证书，一般是向证书颁发机构购买。证书就是一个公钥和一个私钥。</li>
<li>首先建立 TCP 连接。然后客户端向服务器发送客户端支持的一套加密规则</li>
<li>服务器从中选取出一组加密算法与 Hash 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里包含了网站地址，加密公钥，和证书的颁发机构等信息。</li>
<li>客户端验证服务器的合法性</li>
<li>如果证书受信任，或者客户端接受了不受信任的证书，浏览器会生成一个随机密钥，并用服务器提供的公钥加密。使用 Hash 算法对握手消息进行摘要计算，并对摘要使用之前产生的随机密钥加密。然后，将加密后的随机密钥和摘要发给服务器。</li>
<li>服务器用自己的私钥解开被加密的随机密钥，并用随机密钥解出被加密的 Hash 摘要，验证握手信息是否一致。如果一致，则服务器使用获得的随机密钥加密握手消息发给客户端。</li>
<li>客户端解密并验证摘要，若一致，则握手结束，以后发送的数据都使用该随机密钥进行对称加密。</li>
<li>证书公钥用于加密在握手过程中生成的随机密钥，随机密钥用于加密真正传输的数据，Hash 算法用于验证数据的完整性。</li>
<li>对称加密，加密和解密使用同一个的密钥。</li>
<li>非对称加密，需要两个密钥，公钥和私钥。使用公钥加密的内容用私钥才能解开。</li>
</ul>
</li>
<li>
<p>SSL/TLS 连接建立过程</p>
<ol>
<li>ClientHello</li>
<li>SeverHello</li>
<li>客户端回应</li>
<li>服务器最后回应</li>
</ol>
</li>
<li>
<p>HTTPS 为什么同时需要有对称加密和非对称加密两种加密方式？<br />
对称加密的加密和解密使用的是同样的密钥，所以速度快，但密钥需要在网络中传播，所以安全性不高。<br />
非对称加密使用了一对密钥，公钥和私钥，安全性高，但是加密与解密速度慢。<br />
两者结合起来，可以结合双方的优点，摒弃双方的缺点。即，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双发可以使用对称加密来进行沟通。<br />
HTTPS 最开始就是这样做的。HTTPS 既有非对称加密也有对称加密。对称加密的性能高速度快，因此在数据传输时使用对称加密。对称加密使用的密钥 SK 是在对话前通过网络协商生成的。为了确保 SK 的安全，使用非对称加密来协商 SK。</p>
</li>
<li>
<p>HTTPS 对称加密的密钥 SK 如何产生？<br />
HTTPS 分为两个阶段：</p>
<ol>
<li>协商对称加密密钥 SK 的非对称加密阶段，称为 TLS 握手阶段。</li>
<li>使用 SK 对数据进行对称加密的阶段，称为数据通信阶段。<br />
HTTPS 协商对称加密密钥 SK 的办法有很多种，其中三种最常见的为：</li>
<li>基于非对称加密算法</li>
<li>基于专用密钥交换算法，常见的有 DH，ECDH 等</li>
<li>基于共享的 secret，常见的有 PSK，SRP 等</li>
</ol>
</li>
<li>
<p>非对称加密 RSA 协商密钥的办法，是 HTTPS 最早的办法，其过程如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc5xu6v526j30u00iymyj.jpg" alt="RSA 协商密钥.jpg" /></p>
<ol>
<li>客户端给服务端发送请求</li>
<li>服务端将自己的公钥 PuK 返回给客户端</li>
<li>客户端生成本次对话的对称密钥 SK，并用 PuK 进行加密得到 SK_Enc 后传给服务端</li>
<li>服务端收到 SK_Enc 后用自己的私钥 PrK 解密得到 SK；若成功，则返回客户端 OK，否则终止对话。</li>
<li>接下来，客户端和服务端的对话均用 SK 加密后传输。<br />
这种方法存在中间人攻击的问题，同时，服务端的私钥 PrK 泄露后，HTTPS 的加密也就不安全了。</li>
</ol>
</li>
<li>
<p>密钥交换算法。DH 和 ECDH 协商密钥算法的大致过程如下：</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc5y87dgrrj30u00rzgo7.jpg" alt="DH ECDH 密钥协商.jpg" /></p>
<p>ECDH 算法中的 A 和 B，也别称为 PreMaster-Secret。最终协商得到的密钥 SK 被称为 Master Secret，也被称为 Session Key。<br />
ECDH 比 DH 算法更快，并且 ECDH 比 DH 更难破解，可行性更好。</p>
<ul>
<li>
<p>基于共享的 secret<br />
这列做法就是在客户端和服务端预设好对称加密的密钥，握手阶段只需要传递类似钥匙 id 即可。代表算法有 PSK。</p>
</li>
<li>
<p>HTTPS 有几套非对称加密？目的是什么？是否可以省略？<br />
有两套非对称加密。<br />
一套用于协商对称加密密钥，一套用于数字证书签名加密。<br />
前者是服务器端产生的，私钥在服务器上。后者是 CA 机构产生的，私钥在 CA 机构那里。<br />
两套都不应当省略。</p>
</li>
<li>
<p>HTTPS 的证书</p>
</li>
</ul>
<p>CA、CA 机构：Certificate Authority 机构/组织概念<br />
数字证书、（CA）证书、HTTPS 证书、SSL/TLS 证书：CA 签发的数字证书。<br />
数字签名、证书指纹：CA 签发的证书的内容之一，一段加密的密文。<br />
数字证书用于主体身份验证。<br />
数字证书 = 主体信息 + 数字签名<br />
一张完整的数字证书包括：<br />
1. 主体的必要信息：版本、序列号、签名算法、颁发者、有效期、使用者、公钥信息<br />
2. 主体的扩展信息：密钥标识符、证书策略<br />
如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc639pr8n0j30ku0ofdi6.jpg" alt="数字证书.jpg" /></p>
   <center>数字证书</center>
<p>数字证书用于防范中间人攻击。</p>
<ul>
<li>HTTPS 中间人攻击及防范</li>
</ul>
<p>中间人攻击 MITM（Man-in-the-middle attack）</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc63hpi46qj30u00m1ab3.jpg" alt="中间人攻击.jpg" /></p>
   <center>中间人攻击</center>
<p>中间人攻击是指攻击者与通讯的两端分别建立独立的连接，并交换其收到的数据，使通讯的两端认为他们正在通过一个私密的连接接与对方通讯，但事实上整个会话都被攻击者 控制。攻击者可以截通讯双方的通话并插入新的内容。</p>
<p>客户端请求与服务器发起 HTTPS 通信，信息被中间人获取。服务器把自己的公钥发给客户端，信息被中间人获取，中间人将公钥改为自己的公钥，再发给客户端。客户端收到 公钥，生成随机密钥并用公钥加密随机密钥，然后发给服务器。信息被中间人获取，中间人自己的私钥解密获得随机密钥。现在中间人有服务器的公钥和客端产生的随机密钥。 中间人将随机密钥用服务器的公钥加密，再给服务器。服务器用自己的私钥解密，获得随机密钥。以后客户与服务器的通信都通过随机密钥加密，而中间人有随机密钥，所以中 间人可以获得所有的通信信息。</p>
<p>防范中间人攻击，就是要保证通信中的信息来自正确的发送者且没被修改过。保证客户端收到的信息来自服务器，保证服务器到的信息来自客户端，保证中间没有一个家伙能查 看并修改信息。</p>
<p>可以通过数字签名来保证某段信息确实来自它所声称的那个体。比如，服务器在产生要发送的消息后，通过 Hash 算法计摘要，然后用自己的私钥加密摘要，生成数字签名。消 息接受者到信息和数字签名后，使用同样的 Hash 算法计算信息摘要，用公钥解密数字签名获得服务器端发来的摘要。比对两个摘要查是否一致。如果一致，可以保证信息来自 对方且没被修改过。但这种方式依旧可以被中间人攻击，中间人可以在会话建立阶段将方交换公钥换为自己的公钥，获取双方计算信息摘要的 Hash 法。这样中间人依旧可以修 改信息而不被发现。</p>
<p>为了解决这个问题，通信双方需要找一个双方都信任的第三方为双方确认身份。就是向数字证书机构购买数字证书。</p>
<ul>
<li>数字证书如何工作？</li>
</ul>
<p>这需要从两个角度来说明：<br />
申请证书，即需要被验证身份的一端，需要申请一份能够验证自己身份的证书<br />
验证证书，即需要验证对方身份的一端，拿到证书后验证对端的身份。<br />
这张证书必须是由权威 CA 机构颁发的，且尚在有效期内，或者是一张受信任的私人证书。</p>
<p>申请证书<br />
申请证书的过程：用户向 CA 机构提交自己的信息（如域名）和公钥（用户自己生成的非对称加密公钥，用于 TLS 握手阶段和另一端协商密钥），CA 机构生成数字证书，如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc646iatulj30u00gtwfz.jpg" alt="申请证书.jpg" /></p>
   <center>申请证书</center>
<p>验证证书<br />
收到对端发来的证书，执行证书申请的“逆过程”即可，如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc648lr2d9j30u00am75m.jpg" alt="验证证书.jpg" /></p>
   <center>验证证书</center>
<p>接受证书的一端先对除数字签名的其他部分使用证书中指明的哈希算法计算一次哈希值，记作 H1；获取 CA 机构的公钥对数字签名属性做解码，得到了 CA 机构计算出来的哈希值，记作 H2.对比 H1 和 H2 是否严格相等。若是，则代表该证书的信息未被篡改，证书有效；否则，证书无效。</p>
<p>CA 机构的公钥如何获取？<br />
答案是提前内置。<br />
操作系统和浏览器在软件安装阶段会在其特定目录下放置一堆证书。<br />
查看 win10 的内置证书命令：win+R 然后输入 certmgr.msc<br />
这些证书都是权威 CA 机构颁发的根证书（Root Certificate）。<br />
根证书有如下几个特点：</p>
<ul>
<li>没有上层机构再为其本身作数字签名</li>
<li>证书上的公钥即为 CA 机构发布的公钥</li>
<li>权威 CA 机构的自签证书</li>
</ul>
<p>本地内置了这么多根证书，那要怎么知道我这份证书应该要用哪个根证书来验证呢？<br />
通过证书信任链。<br />
证书信任链上有 3 类证书：根证书、中介证书和用户证书。<br />
根证书就是前面提到的，内置在浏览器和操作系统中的证书。用户证书就是对端发过来的证书，是用户向权威 CA 机构绑定了自己身份（主要指域名）和自己公钥的证书。中介证书可以理解为由权威 CA 机构委派的代理机构签发的数字证书。中介证书或说中介机构的存在是为了保证根证书密钥的安全性。<br />
从用户证书寻找根证书的过程，是一个在树形结构中，从叶子节点搜索根节点的过程。</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc785harqgj30u00itn3s.jpg" alt="搜索根证书.png" /></p>
   <center>搜索根证书</center>
<ul>
<li>完整性校验：HTTPS 的哈希<br />
HTTPS 的哈希用在两个地方：</li>
</ul>
<ol>
<li>证书的数字签名<br />
这里使用哈希的主要目的是减少非对称加密算法在文本上的开销。</li>
<li>对称加密的 Message Digest<br />
在数据通信阶段，SSL/TLS 会对原始消息做一次哈希，的到该消息的摘要，称为消息摘要。对端接受到消息后，使用协商出来的对称加密密钥解密数据包，得到原始信息。接着也做一次相同的哈希算法得到摘要，对比发送过来的消息摘要和计算出的消息摘要是否一致，可以判断通信数据是否被篡改。</li>
</ol>
<ul>
<li>HTTPS 的通信流程</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc79ecgev5j30u00rmwi5.jpg" alt="HTTPS的通信流程.jpg" /></p>
<ul>
<li>如何由 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 跳转至 <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a></li>
</ul>
<p>如果网站启用了 HTTPS，则服务器会将这个请求使用 301 永久重定向或者 302 临时重定向将请求从 HTTP 的 80 端口重定向到 HTTPS 的 443 端口。<br />
此时，如果中间人劫持了使用者的网络请求，那么中间人可以阻止客户端与服务器建立 HTTPS 连接，而一直使用 HTTP 连接，而中间人则和服务器建立正常的 HTTPS 连接，让客户端以为自己在和真正的服务器通信，这种攻击手法称为 SSLTrip。</p>
</li>
<li>
<p>Session 与 Cooike 的区别<br />
Session 是服务器保持状态的方法，Cooike 是客户端保持状态的方法。<br />
Cooike 是本地机器存储的一个小段文本，并随着每一个请求发送至同一个服务器。服务器通过 HTTP 头向客户端发送 Cooike。在客户端，浏览器解析这些 Cooike 并把它们保存为一个本地文件，浏览器会自动的将向同一服务器发送的任何请求上附加这些 Cooike。<br />
Cooike 是用户端的会话状态保存机制。Cooike 的作用是为了解决 HTTP 协议无状态的缺陷。<br />
Cooike 的主要内容包含：名字、值、过期时间、路径和域。路径和域一起组成 Cooike 的作用范围。如果不设置过期时间，则表示 Cooike 的生命周期为浏览器的会话期间，关闭浏览器，Cooike 就消失，这种 Cooike 被称为会话 Cooike，一般存放在内存中。若设置了过期时间，浏览器就会把 Cooike 保存到硬盘上，关闭后再次打开浏览器，这些 Cooike 依旧有效直到超过设定的过期时间。<br />
Session 机制采用的是在服务器端保持状态的解决方案。由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以 Session 机制可能需要借助 Cooike 机制来达到保存状态的目的。<br />
Session 是针对每一个用户的，Session 的值保存在服务器端，使用 SessionID 来区分用户。SessionID 是一个不容易被找到规律的字符串，用来防止仿造。<br />
服务器接受到客户端的请求时，会检查请求中是否包含一个 SessionID，如果包含，则服务器会通过 SessionID 检索 Session，如果检索不到则会新建一个。如果客户端请求中不包含 SessionID，则服务器为次客户端创建一个 Session 并生成一个与该 Session 关联的 SessionID，SessionID 会在本次响应中返回给客户端。<br />
保存这个 SessionID 的方式可以使用 Cooike。当客户端禁止使用 Cooike 时，可以采用 URL 重写的技术，把 SessionID 直接附加在 URL 的路径后，类似于 URL 的参数。还有一种技术称为表单隐藏字段，服务器自动修改表单，增加一个隐藏字段，以便表单在提交时能够把 SessionID 传递给服务器。<br />
Cooike 中只能保存 ASCII 字符串，如果需要存放 Unicode 字符或者二进制数据，则需要先进行编码。因此存储较复杂的状态，使用 Cooike 是比较困难的。<br />
Session 中能存放任何类型的数据，使用起来比较方便。<br />
Cooike 中的信息存放在客户端，因此最好不要存放一些敏感信息，比如帐号密码，因为一些客户端的不良程序可能会窥探甚至修改 Cooike 中的内容。也可以对 Cooike 加密，提交到服务器后再解密。<br />
Session 在服务器端，保存隐私信息很方便。<br />
Cooike 可以设置一个长时间的有效期，来保持状态一直有效，比如保持登陆。<br />
Session 一般依赖一个会话 Cooike，浏览器关闭后，该 Session 就失效了。而且 Session 一般不应维持较长的有效期，因为这样会对服务器带来较大的压力。并且，Session 不适用于访问量超高的网站，因为这种网站使用 Session 保存状态的话，会消耗大量服务器资源。<br />
Cooike 存放在客户端，如果网站的并发量超大，一般都采用 Cooike 保存状态。<br />
Cooike 的有效时间，有效位置容易设置，Session 就不行。<br />
Cooike 支持跨域名访问。Session 不支持跨域名访问。</p>
</li>
<li>
<p>session 的实现<br />
session 由三个组件配合完成，分别为 <code>Manager</code>、<code>Provider</code> 和 <code>Session</code> 这三个类。</p>
</li>
</ul>
<p>下图是一个 HTTP 请求的完整流程</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbq9oo19c7j30u00gwgn8.jpg" alt="http的请求过程.jpg" /></p>
<ol>
<li>Handler 函数用于接收请求，解析 HTTP header  中的 cooike，得到 SessionID，然后把 SessionID 发给 Manager。</li>
<li>Manager 充当一个 Session 管理器的角色，主要用于存储配置信息。比如：session 的存活时间，Cooike 的名字等。Manager 将 SessionID 接着发给 Provider。</li>
<li>Provider 是一个容器，一般是一个散列表，将每个 SessionID 和 Session 的对应关系存储起来。</li>
<li>Session 中存放用户的具体信息，一般是一个散列表。</li>
</ol>
<ul>
<li>
<p>Cross-Origin Resource Sharing（CORS）跨域资源共享<br />
一般是指，一个域下的文档或脚本试图请求另一个域下的资源。</p>
</li>
<li>
<p>从输入 URL 到获得页面的过程</p>
<ul>
<li>浏览器查询 DNS。浏览器自己的 DNS 缓存，本地 Host 文件，操作系统的 DNS 缓存，本地 DNS 服务器，递归查询或迭代查询</li>
<li>浏览器获得 IP 地址后，向服务器建立 TCP 连接。</li>
<li>TCP 连接建立后，浏览器向服务器发送 HTTP 请求。</li>
<li>服务器响应 HTTP 请求。</li>
<li>浏览器不断请求资源，最终渲染出整个页面。</li>
</ul>
</li>
<li>
<p>网络层</p>
</li>
<li>
<p>功能：互联异构网络、路由与转发、拥塞控制</p>
<ul>
<li>异构网络：好多个网络，各个网络由不同厂家生产的计算机组成，使用了不同的协议。</li>
<li>路由与转发：通过路由器实现</li>
<li>拥塞控制：ICMP Internet Control Message Protocol 网络信息控制协议</li>
</ul>
</li>
<li>
<p>路由算法</p>
<ul>
<li>静态：网络管理员手工配置</li>
<li>动态：通过路由器间彼此交换信息来构造路由表，分为距离-向量算法和链路状态算法。
<ul>
<li>距离-向量算法<br />
所有的路由器都定期地将它们自己的整个路由选择表传送给所有与之相连的临近路由器。路由选择表包含每条路径的目的地和路径的代价。</li>
<li>链路状态算法<br />
每个参与该算法的节点都有整个网络的拓扑信息。一个结点检查所有与之直连的链路的状态，并将所得的信息发送给网络上的所有其他节点。其他结点包括和它直连的和不直连的。当一个结点收到其他节点发来的链路状态时，该节点就通过这些信息更新自己维护的整张网络的拓扑图。如果链路状态发生变化，就通过 Dijsktra 算法计算最短路由。只有链路状态发生变化时，结点才会发送此消息。消息传递使用的是洪泛法。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>层次路由<br />
将互联网分为许多较小的自治系统，系统有权决定自己内部使用什么路由协议</p>
<ul>
<li>内部网关协议<br />
自制系统内部使用的协议。比如使用距离向量算法更新路由表的 RIP 协议和使用链路状态算法更新路由表的 OSPF 协议。</li>
<li>外部网关协议<br />
自制系统之间的网关协议。比如 BGP4。</li>
</ul>
</li>
<li>
<p>IPV4</p>
</li>
<li>
<p>首部，固定部分为 20B，还有一部分的变长部分。</p>
</li>
<li>
<p>NAT Network Address Transform 网络地址转换<br />
用于实现专用网络与公共网络之间的地址转换</p>
</li>
<li>
<p>子网划分<br />
使用子网掩码，对物理子网再一次进行划分。IP 地址分为三部分：网络号，子网号，主机号</p>
</li>
<li>
<p>CIDR Classless Inter-Domin Routing 无分类域间路由选择<br />
用于消除传统的 A、B、C类网络划分。IP 地址分为两部分：网络前缀和主机号。需要在 IP 地址后用斜线记录网络前缀占用的比特数。可以合并路由表的表项。</p>
</li>
<li>
<p>路由聚合<br />
将网络前缀相同的连续 IP 地址组成 CIDR 地址块。使得一个地址块可以表示多个地址，减少路由表的表项，从而降低路由器间交换信息的大小</p>
</li>
<li>
<p>ARP address resolution protocol 地址解析协议<br />
对于特定的 IP 地址，查询其对应的物理地址</p>
</li>
<li>
<p>DHCP dynamic host configuration protocol 动态地址配置协议<br />
给网络中的主机动态分配 IP 地址</p>
</li>
<li>
<p>ICMP internet control message protocol 网络控制信息协议<br />
用来给主机和路由器报告差错和异常，用于拥塞控制。</p>
</li>
<li>
<p>IPV6<br />
首部固定 40B，地址长度 16B，用于解决 IPV4 地址耗尽的问题</p>
</li>
<li>
<p>路由协议</p>
<ul>
<li>自制系统内
<ul>
<li>RIP 协议 Routing Information Protocol<br />
基于距离向量算法的路由选择协议。<br />
网络中的每个路由器都要维护从它自身到其他每一个目的网络的距离记录。<br />
距离用跳数表示，路由器与网络直连时跳数为 1。每经过一个路由器，跳数加一。16 跳时，表示网络不可达。<br />
RIP 认为跳数少，则该路径就好。<br />
仅与相邻的路由器交换信息。交换的是整个路由表。每个固定的时间，就交换一次信息。<br />
应用层协议，使用 UDP 传输数据</li>
<li>OSPF 协议 Open Shortest Path First 开放最短路径优先协议<br />
基于链路状态算法的路由选择协议。<br />
使用洪泛法发送信息。<br />
只发送与本路由器直连的链路的状态。<br />
只有链路状态发生变化时，才发送信息。<br />
网络层协议，直接使用 IP 数据报发送信息，此时 IP 数据报首部的协议字段为 89。<br />
每个链路状态都附带一个 32 位的序号，序号越大，状态越新。</li>
</ul>
</li>
<li>自制系统间
<ul>
<li>BGP border gateway protocol 边界网关协议<br />
只力求找到一条能够到达目的网络且比较好的路由，而不是寻找最佳路由。<br />
主要用于处理各 ISP 之间的路由选择。<br />
应用层协议，使用 TCP 传输数据。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IP 组播<br />
一个发送者与多个接受者之间实现一对多的数据传输。使用 UDP 协议传输数据，IP 地址为 D 类地址。</p>
</li>
<li>
<p>计算机网络体系结构</p>
<ul>
<li>原理的体系结构：应用层、传输层、网络层、数据链路层、物理层</li>
<li>IOS 7 层结构：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</li>
<li>TCP\IP 4 层结构：应用层、传输层、网际层、网络接口层</li>
</ul>
</li>
<li>
<p>应用层常见协议</p>
<ul>
<li>FTP 文件传输协议 使用 TCP 21端口为控制端口，20端口是数据连接端口</li>
<li>HTTP 超文本传输协议 80端口</li>
<li>HTTPS 加密的超文本传输协议 443 端口</li>
<li>DNS 地址解析协议 53端口 使用 UDP</li>
<li>STMP 发送邮件协议 客户端向邮件服务器发邮件，邮件服务器向邮件服务器发邮件 25端口 使用 TCP</li>
<li>POP3 接收邮件协议 邮件服务器向客户端发邮件 110端口 使用 TCP</li>
<li>TELNET 远程登录 23端口</li>
</ul>
</li>
</ul>
<h1 id="常见网络攻击"><a class="markdownIt-Anchor" href="#常见网络攻击"></a> 常见网络攻击</h1>
<p><strong>XSS攻击</strong><br />
通过修改网页的 HTML，在浏览器中插入一段恶意的 JavaScript 脚本，从而窃取用户的隐私信息或着仿冒用户进行操作。这就是 XSS 攻击（Cross-Site Scripting，跨站脚本攻击）的原理<br />
XSS 攻击主要有三种类型：反射性 XSS、基于 DOM 的 XSS 和持久型 XSS<br />
<strong>1. 反射型 XSS</strong><br />
黑客诱导用户点击一个链接，该连接会导致用户当前页面的 HTML 中插入一段脚本并执行。使得用户的浏览器被黑客操控，执行黑客的脚本。比如，黑客操控用户浏览器，获取用户浏览器的 Cooike 的隐私信息。具体流程如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gcwofkh5q2j31570migtr.jpg" alt="反射型 XSS.png" /></p>
<p>服务器拼接字符串后返回个客户端，客户端的 HTML 中就被插入了一段恶意脚本。<br />
反射型 XSS 产生在前后端一体的网页中，服务端的逻辑会改变最终的网页代码。</p>
<p><strong>2. 基于 DOM 的 XSS</strong><br />
在前后端分离的网站中，反射型 XSS 一般不会产生作用。但是，网页本身的 JavaScript 仍然是可以改变的，黑客可以利用这一点，在网页中插入自己的脚本。这就是基于 DOM 的 XSS 漏洞。<br />
前后端分离的应用中，前端页面接受到后端发来的数据后，通过修改前端页面的 DOM 来改变页面内容，将后端的信息展示到页面上。<br />
黑客诱导用户点击链接，通过修改 DOM 的方式将恶意脚本插入到前端页面中并执行，从而获取用户的 Cooike 等隐私信息。具体流程如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gcwotef52ij317m0ouq6i.jpg" alt="基于 DOM 的 XSS 攻击.jpg" /></p>
<p><strong>3. 持久性 XSS</strong><br />
这种 XSS 的恶意脚本存储在服务器端。<br />
比如，当用户在搜索一个关键词时，与这个关键词相关的所有搜索结果都会被展示出来。如果这些搜索结果中包含黑客的一些恶意脚本，那这些恶意脚本就会被插入到网页的 HTML 中并执行，从而泄露用户的 Cooike 等隐私信息。<br />
这些恶意的搜索结果会长期的保存在服务器端，因此又被称为存储型 XSS。<br />
在具体的应用中，存储用户的输入并展示它们的地方，都有可能存在持久型 XSS。比如：搜索结果，评论区，博文等。<br />
具体攻击流程如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gcwp1kt5nqj316d0m4n0e.jpg" alt="持久型 XSS 攻击.jpg" /></p>
<p>与前两种 XSS 攻击相比，持久型 XSS 攻击，带来的危害更广。<br />
前两种 XSS 攻击都需要诱导用户点击链接，这对黑客的诱导能力有很大的考验，有经验的用户一般不会随便点击链接。<br />
持久型 XSS 攻击的恶意脚本存储在正常的服务器数据库中，只要用户正常使用业务，就会受到攻击。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/03/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">文件系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-15 06:40:11 / Modified: 06:57:49" itemprop="dateCreated datePublished" datetime="2020-03-15T06:40:11+08:00">2020-03-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h2>
<ul>
<li>文件目录<br />
UNIX 的文件目录由文件名和指向文件对应的 inode 的指针组成。</li>
<li>inode</li>
</ul>
<ol>
<li>存放了文件控制文件所需要的各种基本信息。
<ol>
<li>文件基本信息<br />
文件名、文件物理位置、文件的逻辑结构、文件的物理结构</li>
<li>存取控制信息<br />
文件存取权限</li>
<li>使用信息<br />
文件建立时间、修改时间等</li>
</ol>
</li>
<li>还有文件用到的物理块的地址。</li>
</ol>
<ul>
<li>文件的逻辑结构
<ol>
<li>流式文件。没有结构，将数据按顺序组织成记录并保存，以字节为单位。</li>
<li>有结构文件。顺序文件、索引文件、索引顺序文件、散列文件</li>
</ol>
</li>
<li>文件共享<br />
基于索引节点的硬连接，利用符号链实现的软连接</li>
<li>文件控制访问<br />
为每个文件和目录设置一个访问控制表</li>
<li>文件描述符、文件描述符表、打开文件表、目录项、inode 结点<br />
每个进程在 PCB 中都有一个数组，名叫文件描述符表，文件描述符就是这个数组的下标。文件描述符 0 表示标准输入流文件，文件描述符 1 表示标准输出流文件，文件描述符 2 表示标准错误输出流文件。文件描述符的表项是一个指向系统打开文件表的指针。</li>
<li>系统打开文件表<br />
又叫做系统级的描述符表，表格中的各项条目称为打开文件句柄，是一个 file 对象。一个打开文件句柄存储了与一个打开文件相关的全部信息。如下所示：
<ol>
<li>当前文件偏移量</li>
<li>打开文件时所使用的状态标识</li>
<li>文件访问模式</li>
<li>指向该文件 inode 的指针</li>
<li>文件类型和访问权限</li>
<li>一个指向该文件持有的锁列表的指针</li>
<li>文件的各种属性，包括文件大小以及不同类型操作相关的时间戳</li>
<li>该文件的引用计数，就是指向该表项的文件描述符的个数。关闭一个文件描述符会减少相应的文件的引用计数，当引用计数为零时，内核会删除该文件在系统打开文件表中的表项。</li>
<li>一个指向 file_operations 结构体的指针，结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如：read、write、open 等函数。</li>
<li>一个指向 dentry 结构体的指针。“dentry” 是 directory entry 的缩写。open、stat 等函数的参数是文件路径，这些函数需要通过文件路径找到文件的 inode。为了减少磁盘访问，内核缓存了目录的树状结构，称为 dentry cache。该树状结构的每一个结点就是一个 dentry 结构体。open、stat 等函数可以沿着路径各部分的 dentry 结构体搜索即可。dentry 结构体中有一个指向 inode 结构体的指针。inode 结构体保存着从磁盘上 inode 读出来的信息。如果两个 dentry 结构体指向同一个 inode 结构体，则说明这两个文件是硬连接。<br />
系统只维护一个系统打开文件表，所有进程共享这张表。</li>
</ol>
</li>
<li>虚拟文件系统<br />
Linux 系统中存在很多物理的文件系统，比如 ext2、ext3、ext4 等。每个文件系统都有自己的文件组织方法，操作方法。Linux 系统通过虚拟文件系统使用户能够透明的处理文件，忽视不同物理文件系统之间的差异。<br />
虚拟文件系统中有四个重要对象：超级块（super block)、索引节点（inode）、目录项（dentry）和文件对象（file）</li>
<li>超级块（super block）<br />
一个超级块对应一个真实的物理文件系统，保存文件系统的类型、大小、状态等元信息。不同的物理文件系统对应不同的 super_block，因此对于不同的 super_block 的操作也不同。super_block 结构体中有一个指向 super_operations 结构体的指针，指向某个特定的具体文件系统用于管理这个文件系统中 inode 的操作函数的集合。<br />
内核中的结构处理都是有讲究的，内核单独使用一个简单的结构体将所有 super_block 都连接起来，但这个结构体不是 super_block 本身，因为 super_block 本身太大了，效率不高。<br />
struct file_system_type *s_type 属性：文件系统类型，也就是当前文件系统是属于哪个类型，ext2 还是 ext3。</li>
<li>索引节点 inode<br />
保存的是文件的元数据，就是文件属性的描述。例如：文件大小、设备标识符、用户标识符、文件模式、文件读取或修改的时间戳、指向存储文件数据的磁盘区块的指针。<br />
inode 有两种，一种是虚拟文件系统的 inode，一种是具体文件系统的 inode。前者存在与内存中，后者存在于磁盘中。使用 inode 时，要将磁盘上的 inode 填充到内存中的 inode 中。<br />
每个 inode 结点的大小，一般是 128B 或者 256B。inode 结点的总数在磁盘格式化时就给定。一般每 2KB 的硬盘就设置一个 inode。<br />
inode number 是唯一的，表示不同的文件。文件名是给用户使用的，Linux 的系统文件目录的一个表项就是 “文件名 + inode number”。系统通过文件名，找到文件对应的 inode number，再通过 inode number 找到 inode 信息，最后通过 inode 中的指向磁盘块的指针，找到文件的数据。<br />
创建一个文件时，内核就给该文件分配一个 inode，一个 inode 只对应一个实际文件，一个文件也只有一个 inode。inode 的个数就是系统中文件的最大个数。</li>
<li>目录项（dentry）<br />
目录项是描述文件的逻辑属性，只存在与内存中，没有实际对应的磁盘描述，是存在于内存的目录项缓存，为了提高查找性能而设计的。所有目录项在一起构成一颗庞大的目录树。<br />
一个目录项对应一个 inode 结构，一个 inode 结构可以对应多个 dentry 结构。</li>
<li>文件对象（file）<br />
文件对象描述的是进程已经打开的文件。file 对象组成系统打开文件表。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/03/12/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">图算法专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-12 06:53:26" itemprop="dateCreated datePublished" datetime="2020-03-12T06:53:26+08:00">2020-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-01 21:09:19" itemprop="dateCreated datePublished" datetime="2020-03-01T21:09:19+08:00">2020-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-04 23:05:59" itemprop="dateModified" datetime="2020-03-04T23:05:59+08:00">2020-03-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h1>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/26/C-C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/C-C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">C++/C 基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-26 17:15:23" itemprop="dateCreated datePublished" datetime="2020-02-26T17:15:23+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-28 10:06:01" itemprop="dateModified" datetime="2020-02-28T10:06:01+08:00">2020-02-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="const-关键字"><a class="markdownIt-Anchor" href="#const-关键字"></a> const 关键字</h1>
<ul>
<li>const 修饰普通变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>a 为常量，只能在声明时赋值，不可再次赋值。指向常量的指针和引用，必须被 const 修饰，这样用于防止通过指针或引用修改该常量。</p>
<ul>
<li>指向常量的指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>const 位于 * 的左边，不能通过指针修改指针指向的值。指向常量的指针，可以指向常量也可以指向普通类型。关键是不能通过指针修改指针指向的值。</p>
<ul>
<li>常指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>const 位于 * 的右边，指针是一个指针常量，指针指向的内存地址不能改变，但可以通过指针修改指针指向的值。</p>
<ul>
<li>指向常量的常指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>const 在 * 的两边都有，指针指向的内存地址不能改变，地址中的值不能通过指针改变。<br />
常指针和指针常量的合并。</p>
<ul>
<li>const 修饰函数参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传值参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    a++; <span class="comment">// 错误，不能在函数中修改 a 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> *a)</span></span>&#123;</span><br><span class="line">    *a=<span class="number">10</span>; <span class="comment">// 错误，不能通过指针修改 a 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> a)</span></span>&#123;</span><br><span class="line">    *a=<span class="number">10</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">10</span>;</span><br><span class="line">    a=&amp;b; <span class="comment">// 错误，不可以改变指针指向的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数参数是一个自定义的对象时，按值传参时会构建临时对象复制参数，一般采用传引用，为了防止参数在函数体内被修改，常用 const 修饰参数。</p>
<ul>
<li>const 修饰函数返回值</li>
</ul>
<ol>
<li>const 修饰基本数据类型，修饰与不修饰作用相同。</li>
<li>const 修饰自定义类型。此时返回一个常量，返回值不能做左值。返回值既不能被赋值，也不能被修改。</li>
<li>const 修饰返回的指针或引用。</li>
</ol>
<ul>
<li>
<p>const 修饰类的成员函数<br />
const 加在 () 后面<br />
const 修饰成员函数，是为了防止成员函数修改调用这个函数的对象的值。一个类中，任何不会修改数据成员的函数都应该声明为 const 类型。const 修饰的成员函数称为常成员函数，常成员函数不能调用非常成员函数，用来防止常成员函数修改类的属性。只有常成员函数能够操作常对象，没有 const 修饰的的成员函数不能用来操作常对象。如果对象的某个属性希望被自己的 const 成员函数修改，则可以用 mutable 修饰该属性。</p>
</li>
<li>
<p>const 修饰引用<br />
const 引用是指向 const 对象的引用。同时，普通的引用是无法绑定到 const 对象上的。为了防止通过普通的引用修改 const 对象。</p>
</li>
</ul>
<h1 id="static-关键字"><a class="markdownIt-Anchor" href="#static-关键字"></a> static 关键字</h1>
<ul>
<li>
<p>静态成员变量<br />
类内成员变量声明前加上关键字 static，该数据成员就是类内的静态数据成员。</p>
</li>
<li>
<p>静态成员变量的特点</p>
</li>
</ul>
<ol>
<li>静态成员变量是该类所有对象共有的。静态成员变量只分配一次内存，由该类的所有对象共享访问。</li>
<li>静态数据成员在全局数据区分配内存，不属于特定的对象，不占用对象的内存。在没有类的实例存在前，静态成员变量就已经存在了。</li>
<li>静态成员变量在初始化时分配内存。静态变量必须初始化，并且只能在类体外进行。初始化时可以赋初值，也可以不赋初值。如果不赋初值，则会被默认初始化。静态数据区的变量都有默认的初始值，动态数据区的变量默认是垃圾值。</li>
<li>static 成员变量与普通 static 变量相同，编译时在静态数据区分配内存，到程序结束时才释放。</li>
<li>静态数据成员初始化时可以不加 static，但必须要有数据类型。</li>
<li>静态数据成员可以通过 &lt;类名&gt;::&lt;静态数据成员名&gt; 访问，不需要通过类的对象。</li>
<li>sizeof 运算不会计算静态成员变量的大小。</li>
</ol>
<ul>
<li>
<p>静态成员函数<br />
静态成员函数是为某一个类服务的。静态成员函数不作用于某个具体的对象。普通成员函数隐含了一个 this 指针，该 this 指针指向类的对象本身。函数调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this 是缺省的。<br />
静态成员函数属于类本身，不作用与具体的对象，因此它不具有 this 指针。静态成员函数不能访问非静态成员变量和非静态成员函数，只能访问其余的静态成员变量和函数。</p>
</li>
<li>
<p>静态成员函数的特点</p>
</li>
</ul>
<ol>
<li>出现在类体外的函数定义不能指定关键字 static</li>
<li>静态成员函数仅可以访问静态成员变量和静态成员函数</li>
<li>静态成员函数不能访问非静态成员函数和非静态成员变量</li>
<li>非静态成员函数可以任意的访问静态成员函数和静态成员变量</li>
</ol>
<ul>
<li>
<p>拷贝构造函数的问题<br />
使用包含静态成员的类时，有时会调用拷贝构造函数生成临时的隐藏的类对象，而这个临时类对象消亡时会调用析构函数，析构函数中可能会修改静态成员变量，但是这些临时对象在创建时却没有执行构造函数中的对静态成员变量修改的操作。此时应当在类中写一个拷贝构造函数，让临时对象的创建使用该拷贝构造函数，在拷贝构造函数中规范拷贝对象时的操作。</p>
</li>
<li>
<p>静态全局变量<br />
在全局变量之前加上 static 关键字。</p>
</li>
<li>
<p>静态全局变量的特点</p>
</li>
</ul>
<ol>
<li>该变量在全局数据区分配内存</li>
<li>未经初始化的静态全局变量有一个默认的初始化值。与之相比，普通变量的默认初始化值是垃圾值。</li>
<li>静态全局变量在声明它的整个文件内都是可见的，在文件外不可见。</li>
<li>对于一个完整的程序，在内存中的分布情况如下：【代码区】、【全局数据区】、【堆区】和【栈区】。一般由 new 产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据，包括函数内部的静态局部数据，存放在全局变量区。</li>
<li>静态全局变量不能被其他文件使用。在其他文件中，可以定义相同名字的变量，不会产生冲突。</li>
</ol>
<ul>
<li>
<p>静态局部变量<br />
在局部变量之前加上 static 关键字，该变量就被定义为一个静态局部变量。<br />
函数中的普通局部变量存放在栈中，函数退出时系统会回收栈的内存，局部变量也就失效了。<br />
有时，我们希望在两次调用之间对局部变量的值进行保存，此时就可以使用静态局部变量。<br />
静态局部变量只在第一次函数调用时初始化一次。且存放在全局数据区，每次调用的值保持到下一次调用。<br />
静态局部变量始终驻留在函数的全局数据区中，直到程序运行结束。但其作用域为局部作用域，当定义它的语句块结束时，其作用域随之结束。</p>
</li>
<li>
<p>静态函数<br />
在函数的返回类型前加上 static 关键字，函数被定义为静态函数。静态函数只在声明它的文件中可见，不能被其他文件使用。其他文件中可以定义同名函数，不会发生冲突。</p>
</li>
</ul>
<h1 id="虚函数与纯虚函数"><a class="markdownIt-Anchor" href="#虚函数与纯虚函数"></a> 虚函数与纯虚函数</h1>
<ul>
<li>
<p>虚函数是实现多态的机制。多态性使得程序调用的函数是在运行时动态决定的，而不是编译时静态决定的。其核心理念是通过基类访问派生类实现的函数。使用一个基类类型的指针或引用指向子类对象，进而调用由子类复写的个性化的虚函数。</p>
</li>
<li>
<p>虚函数，在类的成员方法的声明前加 virtual 关键字。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>纯虚函数，在虚函数的声明后加 “= 0”</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>虚函数表<br />
每一个包含虚函数的类都包含一个虚函数表<br />
虚表是一个指针数组，指针是指向虚函数的函数指针。<br />
虚表是属于类的，而不是属于某个对象，一个类只需要一个虚表即可。同一个类的所有对象公用一个虚表。<br />
为了指定对象的虚表，对象内部包含一个指向虚表的指针。类对象在创建时便拥有了指向虚表的指针，指针会自动指向对象所属类的虚表。<br />
对象的虚表指针指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数。</p>
</li>
<li>
<p>对于虚函数，子类可以重写虚函数，也可以不重写。对于纯虚函数，子类必须重写。</p>
</li>
<li>
<p>当使用类指针调用成员函数时，普通函数由指针类型确定，虚函数由指针指向的实际类型确定。</p>
</li>
<li>
<p>含有纯虚函数的类称为抽象类，它不能生成对象。</p>
</li>
<li>
<p>当基类中的某个成员方法，在大多数情况下都应该由子类提供个性化实现，但基类中也可以提供缺省的备选方案时，该方法设计为虚函数。当基类的某个成员方法，必须由子类提供个性化实现时，应该设计为纯虚函数。</p>
</li>
<li>
<p>构造函数不能是虚函数，析构函数可以是虚函数且推荐设置为虚函数。基类的析构函数是虚函数，可以确保，在使用基类指针销毁派生类对象时，派生类的析构函数能够被调用，因为派生类的虚构函数一般会有释放一些派生类对象独有的内存这样的操作。</p>
</li>
</ul>
<h1 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h1>
<p>函数存放在内存的代码区域，同样具有地址。<br />
函数指针指向的函数一定要保持函数的返回值类型，函数参数个数、类型和函数指针一致。<br />
函数指针可以作为参数传递给函数<br />
还可以构成函数指针数组<br />
类成员函数指针和普通函数指针是不同的。<br />
类成员函数指针要通过 <code>.*</code> 或者 <code>-&gt;*</code> 运算符使用。<br />
类成员函数指针指向类中的非静态成员函数时，必须由类的实例对象调用，用于传递给函数 this 指针。<br />
指向类的静态成员函数的函数指针在声明时可以不加类名。调用时可以不使用类的实例对象。<br />
普通成员的函数指针可以通过 <code>*</code> 运算符使用。</p>
<h1 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数"></a> 内联函数</h1>
<p>内联函数是为了解决程序中函数调用的效率问题。如果函数为内联函数，则在程序编译时，编译器会将程序中出现的内联函数表达式用内联函数体进行替换。是一种空间换时间的操作。内联函数一般都比较小。<br />
内联函数中最好不要使用循环语句，内联函数的定义必须出现在内联函数第一次调用之前，类内部定义的函数是内联函数。</p>
<h1 id="函数签名"><a class="markdownIt-Anchor" href="#函数签名"></a> 函数签名</h1>
<p>C++ 的函数签名包含函数名和函数的参数列表，不包含返回类型。函数签名用于识别不同的函数。</p>
<h1 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h1>
<p>构造函数不需要用户调用，而是在建立对象时自动执行。函数名称与类名相同，没有返回值。<br />
声明类数组时，数组中的每一个元素都会调用一次构造函数。假设数组长度为 n，则会调用 n 次构造函数。<br />
声明类的指针数组时，不会调用类的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cls</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> executeCount;</span><br><span class="line">	cls() &#123;</span><br><span class="line">		executeCount++;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; executeCount &lt;&lt; <span class="string">"  "</span>; <span class="comment">// 输出当前是第几次调用构造函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> cls::executeCount = <span class="number">0</span>; <span class="comment">// 静态成员变量初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cls a[<span class="number">5</span>]; <span class="comment">// 会调用 5 次默认构造函数</span></span><br><span class="line">    cls * b[<span class="number">8</span>]; <span class="comment">// 不会调用构造函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>无参数的构造函数</li>
<li>带参数的构造函数，属于构造函数的重载。构造函数的参数可以有默认初值。</li>
</ol>
<h1 id="拷贝构造函数"><a class="markdownIt-Anchor" href="#拷贝构造函数"></a> 拷贝构造函数</h1>
<p>用于对象复制。函数名与类名一致，参数一般是一个本类型对象的引用。</p>
<ul>
<li>拷贝构造函数调用时机</li>
</ul>
<ol>
<li>对象以传值的方式传入函数参数时。</li>
<li>对象以传值的方式从函数返回时。</li>
<li>使用另一个同类型的对象来初始化新创建的对象时。</li>
</ol>
<ul>
<li>深拷贝与浅拷贝<br />
默认的拷贝构造函数没有处理类的静态数据成员。<br />
浅拷贝是指，在对象复制时，只对对象中的数据成员进行简单的赋值，不会正确处理指针，指针只是简单的指向相同的内存空间。此时，拷贝出来的对象会影响原来的对象。<br />
深拷贝时，对象中的成员变量，不再是简单的赋值，而是重新分配内存空间。</li>
</ul>
<h1 id="指针与引用的区别"><a class="markdownIt-Anchor" href="#指针与引用的区别"></a> 指针与引用的区别</h1>
<ul>
<li>指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元。引用跟原来的变量是同一东西，只不过是原变量的一个别名而已。</li>
<li>有 const 指针，没有 const 引用</li>
<li>指针可以有多级，引用只能由一级</li>
<li>指针可以为空，引用不能为空</li>
</ul>
<h1 id="回车与换行-r-n"><a class="markdownIt-Anchor" href="#回车与换行-r-n"></a> 回车与换行 \r \n</h1>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">ASCII码</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">10</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">13</td>
<td style="text-align:center">回车</td>
</tr>
</tbody>
</table>
<p>在 windows 中：<br />
<code>\r</code> 回车，表示回到当前行的行首，而不会换到下一行。如果接着输出，本行的内容会被覆盖<br />
<code>\n</code> 换行，换到当前位置的下一行，而不会回到行首。<br />
按下键盘回车键相当于输入 <code>\r\n</code></p>
<p>在 Unix 系统中：<br />
<code>\n</code> 会换到下一行的行首。<br />
按下回车键相当于输入 <code>\n</code></p>
<p>在 Mac 中：<br />
<code>\r</code> 会换到下一行的行首。<br />
按下回车键相当于输入 <code>\r</code></p>
<p>一般在程序中写 <code>\n</code> 在 Linux\windows 中都能实现换到下一行的行首的功能。只是在文本文件中，Linux 只有 <code>\n</code>，Windows 中是 <code>\r\n</code>。</p>
<h1 id="标准输入输出"><a class="markdownIt-Anchor" href="#标准输入输出"></a> 标准输入输出</h1>
<ul>
<li>scanf 和 printf<br />
头文件：<br />
<cstdio><br />
输入格式：</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/16/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/16/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">《高性能 MySQL》学习笔记 第四章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-16 17:34:36 / Modified: 20:50:17" itemprop="dateCreated datePublished" datetime="2020-02-16T17:34:36+08:00">2020-02-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第四章-schema-与数据类型优化"><a class="markdownIt-Anchor" href="#第四章-schema-与数据类型优化"></a> 第四章 Schema 与数据类型优化</h1>
<h2 id="临时表"><a class="markdownIt-Anchor" href="#临时表"></a> 临时表</h2>
<p>MySQL 临时表用于保存一些临时数据。临时表只在当前连接可见，当关闭连接时，MySQL 会自动删除表并释放所有空间。</p>
<ul>
<li>
<p>外部临时表</p>
<p>通过 <code>CREATE TEMORPARY TABLE</code> 创建的临时表称为外部临时表。这种临时表的命名可与非临时表相同。同名后，非临时表对当前回话不可见，直到临时表被删除。</p>
</li>
<li>
<p>内部临时表</p>
<p>内部临时表是一种特殊的轻量级临时表，由 MySQL 自动创建，用来存储某些操作的中间结果，达到性能优化的目的。该表一般是 Memory 表。如果中间结果太大超出了 Memory 的限制，或者含有 BLOB 或 TEXT 字段，则临时表会转换为 MyISAM 表。</p>
</li>
</ul>
<h2 id="对象关系映射-object-relation-mapping-简称-omp"><a class="markdownIt-Anchor" href="#对象关系映射-object-relation-mapping-简称-omp"></a> 对象关系映射 Object Relation Mapping 简称 OMP</h2>
<p>面向对象的开发方法是当今企业级应用开发环境中的主流方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现方式。业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多的关联和继承关系。因此，对象-关系映射系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>
<h2 id="实体-属性-值模型-entity-attribute-value-model-eav"><a class="markdownIt-Anchor" href="#实体-属性-值模型-entity-attribute-value-model-eav"></a> 实体-属性-值模型 Entity-attribute-value model EAV</h2>
<blockquote>
<p><a href="%5Bhttps://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model%5D(https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model)">Entity-attribute-value mode-wiki</a></p>
</blockquote>
<p>EAV 模型是一种数据模型。主要用于以较高的空间利用率编码一种特殊实体，该实体在整体上包含很多属性，但是具体到某一个个体时，只有有限个的属性有值，其他的属性都为空。这种实体与数学上的稀疏矩阵很相似。</p>
<p>EAV 表通常是瘦长的。瘦表示表的列很少，长表示表的行很多。</p>
<p>EAV 表通常有三列</p>
<ul>
<li>entity 表示被描述的实体，该列一般是关联到实体定义表的外键。</li>
<li>attribute 该列一般是关联到一个属性定义表的外键。该属性定义表用来定义该属性，表格可能包含如下几种列：属性ID、属性名、属性描述、数据类型和用于辅助输入验证的列，比如，最大字符串长度、正则表达式或这一个包含有效数据的集合。</li>
<li>value 该列存放属性的值</li>
</ul>
<p>使用 EAV 模型的两个例子：医院的病历记录，超市的销售数据。</p>
<p>EAV 使用了行模型。行模型表示一个实体被记录在很多行而不是很多列中，每行通常有三列：entity、attribute 和 value。</p>
<h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2>
<blockquote>
<p><a href="https://www.zhihu.com/question/24696366" target="_blank" rel="noopener">常见范式设计</a></p>
</blockquote>
<ul>
<li>依赖：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>。</li>
<li>完全函数依赖：在一张表中，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>，且对于 X 的任何真子集 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">X&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><mo mathvariant="normal">′</mo></msup><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X&#x27; \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 不成立，那么我们称 Y 完全依赖于 X，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mover><mo><mo>→</mo></mo><mi>F</mi></mover><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\stackrel{F}{\to}Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452010000000001em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452010000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5668699999999998em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>。</li>
<li>部分函数依赖：Y 函数依赖于 X，同时 Y 不完全依赖于 X，则称 Y 部分依赖于 X，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mover><mo><mo>→</mo></mo><mi>P</mi></mover><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\stackrel{P}{\to}Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452010000000001em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452010000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5668699999999998em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>。</li>
<li>传递函数依赖：Z 函数依赖于 Y，且 Y 函数依赖于 X，且 Y 不包含于 X，且 X 不函数依赖于 Y，则称 Z 传递依赖于 X，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mover><mo><mo>→</mo></mo><mi>T</mi></mover><mi>Z</mi></mrow><annotation encoding="application/x-tex">X\stackrel{T}{\to}Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452010000000001em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452010000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5668699999999998em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span>。</li>
<li>码：设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都有完全函数依赖于 K，那么我们称 K 为候选码，简称为码。通常可以这样理解：假如 K 确定的情况下，该表除 K 之外的所有属性的值也就确定，那么 K 就是码。一张表中可以有超过一个码，通常选择其中的一个码作为主码。</li>
<li>主属性：包含在任何一个码中的属性为主属性</li>
<li>判断表格符合那一个范式步骤
<ol>
<li>找出表中的所有码</li>
<li>根据第一步的码，找出所有主属性</li>
<li>除去所有的主属性，剩下的都是非主属性</li>
<li>查看函数依赖</li>
</ol>
</li>
</ul>
<ol>
<li>
<p>第一范式</p>
<p>所有属性都是不可分割的原子值。</p>
<p>数据库表的每一列都是不可分割的原子数据项，不能是集合，数组，记录等非原子数据项。</p>
</li>
<li>
<p>第二范式</p>
<p>在第一范式的基础上，要求非主属性都要<mark>完全</mark>依赖于码。</p>
</li>
<li>
<p>第三范式</p>
<p>任何非主属性不依赖于其他非主键属性。</p>
<p>第三范式是在第二范式的基础上建立起来的，消除了非主属性对于码的传递函数依赖。</p>
</li>
<li>
<p>BC 范式</p>
<p>在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。</p>
</li>
</ol>
<h2 id="选择数据类型的原则"><a class="markdownIt-Anchor" href="#选择数据类型的原则"></a> 选择数据类型的原则</h2>
<ol>
<li>
<p>更小的通常更好</p>
<p>更小的数据类型通常占用更少的存储空间，处理时需要的 CPU 周期更少。</p>
<p>同时要确保没有低估需要存储的值的范围。在 schema 中的多个地方增加数据类型是一个代价很高的操作。</p>
</li>
<li>
<p>简单就好</p>
<p>简单的数据类型操作通常需要更少的 CPU 周期。</p>
<p>使用 MySQL 内建的数据类型存储日期和时间，而不是使用字符串。</p>
<p>使用整形存储 IP 地址。</p>
</li>
<li>
<p>尽量避免 NULL</p>
<p>可为 NULL 是列的默认属性。</p>
<p>通常情况下最好指定 NOT NULL，除非真的需要存储 NULL 值。</p>
<p>包含 NULL 的列，对 MySQL 来说更难优化。</p>
<p>可为 NULL 的列使得索引、索引统计和值比较都更加复杂。</p>
<p>但是，通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小。所以，在调优时，没有必要首先修改这种情况。但是，在设计表格时要尽量避免 NULL。</p>
</li>
<li>
<p>第一步，确定适合的大类型：数字、字符串、时间等。然后确定具体类型。MySQL 为了兼容性支持很多基本数据类型的别名，例如 INTEGER、BOOL 以及 NUMERIC。这些别名不会影响性能。</p>
</li>
</ol>
<h2 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型"></a> 整数类型</h2>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">位数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TINYINT</td>
<td style="text-align:center">8 位</td>
</tr>
<tr>
<td style="text-align:center">SMALLINT</td>
<td style="text-align:center">16 位</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMINT</td>
<td style="text-align:center">24 位</td>
</tr>
<tr>
<td style="text-align:center">INT</td>
<td style="text-align:center">32 位</td>
</tr>
<tr>
<td style="text-align:center">BIGINT</td>
<td style="text-align:center">64 位</td>
</tr>
</tbody>
</table>
<p>可存储的值的范围：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>∼</mo><msup><mn>2</mn><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2^{(N-1)}\thicksim2^{(N-1)}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，N 为位数。</p>
<p>有可选的 UNSIGNED 属性，表示无符号整数。可存储的值的范围：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>∼</mo><msup><mn>2</mn><mi>N</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \thicksim 2^N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，N   为位数。</p>
<p>数据类型决定整数是如何存储的。而整数计算一般使用 64 位的 BIGINT 整数，即使在 32 位环境中也是如此。一些聚合函数是例外，它们使用 DECIMAL 或 DOUBLE 进行计算。</p>
<p>可以为整数类型指定宽度，例如 INT(11)。这对大多数应用没有意义，这不会改变值的合法范围，只是规定了 MySQL 的一些交互工具用来显示字符的个数。对于存储和计算来讲 INT(1) 与 INT(20) 没有区别。</p>
<h2 id="实数类型"><a class="markdownIt-Anchor" href="#实数类型"></a> 实数类型</h2>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">位数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FLOAT</td>
<td style="text-align:center">32 位</td>
</tr>
<tr>
<td style="text-align:center">DOUBLE</td>
<td style="text-align:center">64 位</td>
</tr>
<tr>
<td style="text-align:center">DECIMAL</td>
<td style="text-align:center">128 位</td>
</tr>
</tbody>
</table>
<p>DECIMAL(a,b)</p>
<p>参数说明：a 指定小数点左边和右边可以存储的十进制数字的最大个数。b 指定小数点右边可以存储的十进制数字的最大个数。</p>
<p>DECIMAL 只是一种存储格式，在实际计算中，DECIMAL 会转换为 DOUBLE。</p>
<p>CUP 不支持 DECIMAL 的直接运算，DECIMAL 的运算要在服务器层实现。相对而言，CUP 原生支持的浮点数运算更快。</p>
<p>MySQL 使用 DOUBLE 作为内部浮点计算的类型。</p>
<p>推荐只指定数据类型，不指定精度。</p>
<p>尽量只在对小数进行精确计算时才使用 DECIMAL，例如财务数据。</p>
<p>在数据量比较大时，可以使用 BIGINT 代替 DECIMAL，只需要将 DECIMAL 乘以合适的倍数将其转换为整数即可。这样可以避免浮点数计算精度问题和 DECIMAL 计算代价大的问题。</p>
<h2 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h2>
<p>MySQL 4.1 开始，每个字符串列可以自定义自己的字符集和排序规则，这些东西会很大程度上影响性能。</p>
<h3 id="varchar-和-char-类型"><a class="markdownIt-Anchor" href="#varchar-和-char-类型"></a> VARCHAR 和 CHAR 类型</h3>
<p>这两个数据类型在磁盘和内存中的存储方式与存储引擎的具体实现有关。以下以 InnoDB 和 MyISAM 在磁盘上的存储为例。</p>
<ul>
<li>
<p>VARCHAR</p>
<p>用于存储可变长的字符串。</p>
<p>比定长类型节省空间，因为它仅使用必要的空间。</p>
<p>例外：如果表使用 ROW_FORMAT = FIXED 创建，每一行都会使用定长储存，这会很浪费存储空间。</p>
<p>VARCHAR 需要使用额外的字节记录字符串的长度，如果列的最大长度小于等于 255 字节，则使用 1 个字节记录，否则使用 2 字节。</p>
<p>由于行是变长的，在 UPDATE 时可能使行变得比原来长，这会导致额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间存储，在这种情况下，不同的存储引擎的处理方式不同。InnoDB 会分裂页来使行可以放入页内，MyISAM 会将行拆分成不同的片段存储。</p>
<p>适用 VARCHAR 的情况：</p>
<ol>
<li>字符串列的最大长度比平均长度大很多</li>
<li>列的更新很少</li>
<li>使用了像 UTF-8 这样的复杂字符集，每个字符都使用不同的字节进行存储。</li>
</ol>
<p>MySQL 5.0 及以上在存储和检索时会保留末尾空格。</p>
<p>InnoDB 会把过长的 VARCHAR 存储为 BLOB。</p>
</li>
<li>
<p>CHAR</p>
<p>CHAR 是定长的。MySQL 总是根据定义的字符串长度为 CHAR 分配足够的空间。</p>
<p>存储时，MySQL 会删除所有的末尾空格。</p>
<p>CHAR 值会根据需要使用空格进行填充以便进行比较。</p>
<p>适用 CHAR 的情况：</p>
<ol>
<li>很短的字符串。</li>
<li>所有值都接近同一长度的字符串。比如 MD5 值。</li>
<li>对于经常变更的数据，CHAR 比 VARCHAR 更有效率，因为不容易产生碎片。</li>
</ol>
</li>
</ul>
<p>填充和截取空格的行为在不同的存储引擎中都是一样的，因为这是在服务器层处理的。</p>
<h3 id="binary-和-varbinary"><a class="markdownIt-Anchor" href="#binary-和-varbinary"></a> BINARY 和 VARBINARY</h3>
<p>与 CHAR 和 VARCHAR 很像。</p>
<p>这两个数据类型存储的是二进制的字符串，即存储的是字节码而不是字符。</p>
<p>填充时使用 \0 而不是空格。</p>
<p>二进制比较比字符比较简单很多，也就快很多。</p>
<h3 id="慷慨是不明智的-最好的策略是只分配真正需要的空间"><a class="markdownIt-Anchor" href="#慷慨是不明智的-最好的策略是只分配真正需要的空间"></a> 慷慨是不明智的 最好的策略是只分配真正需要的空间</h3>
<h3 id="blob-和-text-类型"><a class="markdownIt-Anchor" href="#blob-和-text-类型"></a> BLOB 和 TEXT 类型</h3>
<p>用于存储很大的数据。</p>
<p>BLOB 存储二进制数据，没有字符集和排序规则。</p>
<p>TEXT 存储字符数据，有字符集和排序规则。</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符类型</th>
<th style="text-align:center">二进制类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TINYTEXT</td>
<td style="text-align:center">TINYBLOB</td>
</tr>
<tr>
<td style="text-align:center">SMALLTEXT(TEXT)</td>
<td style="text-align:center">SMALLBLOB(BLOB)</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMTEXT</td>
<td style="text-align:center">MEDIUMBLOB</td>
</tr>
<tr>
<td style="text-align:center">LONGTEXT</td>
<td style="text-align:center">LONGBLOB</td>
</tr>
</tbody>
</table>
<p>InnoDB 在 BLOB 或 TEXT 太大时，使用专用的外部存储区域存储，在行内只存储一个指向外部存储区域的指针。</p>
<p>只对每列最前的 max_sort_lenght 字节做排序而不是对整个字符串。</p>
<p>不能将 BLOB 和 TEXT 全部长度的字符串进行索引，也不能使用这些索引消除排序。</p>
<h3 id="使用枚举类型代替字符串类型"><a class="markdownIt-Anchor" href="#使用枚举类型代替字符串类型"></a> 使用枚举类型代替字符串类型</h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/14/Manacher-%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/14/Manacher-%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Manacher 算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-14 17:21:49" itemprop="dateCreated datePublished" datetime="2020-02-14T17:21:49+08:00">2020-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-17 15:50:50" itemprop="dateModified" datetime="2020-02-17T15:50:50+08:00">2020-02-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h1>
<p>查找一个字符串的最长回文子串的线性算法</p>
<h1 id="算法原理与实现"><a class="markdownIt-Anchor" href="#算法原理与实现"></a> 算法原理与实现</h1>
<ol>
<li>
<p>将长度为奇数和偶数的回文串一起处理</p>
<p>Manacher 使用一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑。具体做法是，在原字符串的每个相邻字符中间插入一个分隔符，同时在首尾也要各添加一个分隔符。要求分隔符不在原字符串中出现。如下图所示，其中，原始字符串为 S，转换后的字符串为 T：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxczgeenuj34a10x3jvu.jpg" alt="" /></p>
</li>
<li>
<p>使用额外空间存储必要信息 Len 数组</p>
<p>辅助数组 Len 是算法的核心。</p>
<p>Len[i] 表示以字符 T[i] 为中心的最长回文子串的最右端字符到字符 T[i] 的字符个数。</p>
<p>比如，以 T[i] 为中心的最长回文子串是 T[l,r]，则 Len[i] = r - i + 1。</p>
<p>对于上面的例子，可以得出如下的 Len 数组：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxdeb6mxqj33uo0shjvo.jpg" alt="" /></p>
<p>Len 数组的性质：Len[i] - 1 等于该回文子串在原字符 S 中的长度。</p>
<p>证明如下：首先，在转换得到的字符串 T 中，所有的回文串的长度都为奇数。那么，对于以字符 T[i] 为中心的最长回文子串，其长度就是 2 × Len[i] -1。经过观察可知，T 中的所有回文子串，其中分隔符的数量一定比其他字符的数量多一。所以， 2 × Len[i] -1 的长度中，有 Len[i] 个分隔符，剩下 Len[i] - 1 个字符来自原字符串。综上所述，该回文串在原字符串中的长度为 Len[i] - 1。</p>
</li>
<li>
<p>Len 数组的计算</p>
<p>从左向右依次计算 Len 数组。当计算 Len[i] 时，Len[0] ~ Len[i-1] 已经计算完毕。</p>
<p>设 P 为之前计算中最长回文子串的右端点的最大值。并且，设取得这个最大值的位置为 Po。</p>
<p>分为两种情况计算：</p>
<ol>
<li>
<p>i &lt; P</p>
<p>找到 i 相对于 Po 的对称位置，设为 j。再分为三种情况。</p>
<ul>
<li>
<p>Len[j] &lt; P - i + 1 如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxdx60uxbj34r827w0ys.jpg" alt="" /></p>
<p>此时说明，以 j 为中心的回文串一定在以 Po 为中心的回文串的内部。j 和 i 关于位置 Po 对称，并且，由回文串的定义可知，一个回文串反过来还是一个回文串。所以，以 i 为中心的回文串的长度至少和以 j 为中心的回文串的长度一样长，即 Len[i] ≥ Len[j]。由对称性可知，Len[i] = Len[j]。</p>
</li>
<li>
<p>Len[j] &gt; P - i + 1 如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxe6lr6amj34r827wwki.jpg" alt="" /></p>
<p>此时，Len[i] = P - i + 1</p>
<p>证明如下：由图可知，Len[i] ≥ P - i + 1。</p>
<p>假设 Len[i] &gt; P - i + 1，则 Len[Po] &gt; P - Po +1，即以 Po 为中心的回文子串是可以更长的，这与 Len[Po] 的原值不符，所以假设错误。</p>
<p>综上所述，Len[i] = P - i + 1</p>
</li>
<li>
<p>Len[j] = P - i + 1 如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxgfvlv0pj30h2083wed.jpg" alt="" /></p>
<p>此时，以 i 为中心的回文串可能会延伸到 P 之外，对于大于 P 的部分，我们还未匹配。因此，要从 P + 1 开始一个一个的匹配，直到发生失配，得出 Len[i] 的值。</p>
</li>
</ul>
</li>
<li>
<p>i &gt;= P 如下图所示：<br />
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbzf37mcc7j348t1g1wgo.jpg" alt="" /><br />
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbzfxdznfuj30hl07mglf.jpg" alt="" /><br />
这两种情况下，对于中点为 i 的回文串还一点都没有匹配。因此，只能一个一个的匹配得出 Len[i] 的值。</p>
</li>
</ol>
</li>
<li>
<p>时间复杂度分析</p>
<p>该算法只有在遇到没有匹配的位置时才进行匹配，已经匹配过的位置不再匹配。因此，对于字符串 T 中的每一个位置，只进行一次匹配，算法整体复杂度为 O(n)，其中 n 为字符串 T 的长度。由于 T 的长度实际上是原字符串 S 的长度的两倍，所以时间复杂度依旧是线性的。</p>
</li>
<li>
<p>算法实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串 s 中的任意一个最长回文子串 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">     <span class="comment">// 初始化辅助字符串</span></span><br><span class="line">     <span class="built_in">string</span> T=<span class="string">"#"</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">         T+=s.substr(i,<span class="number">1</span>)+<span class="string">"#"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 初始化辅助数组</span></span><br><span class="line">     <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Len</span><span class="params">(T.length())</span></span>;</span><br><span class="line">     Len[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> aimIndex=<span class="number">0</span>,Po=<span class="number">0</span>,P=<span class="number">0</span>; <span class="comment">// aimIndex 存放最长回文子串的中心字符在 T 中的下标</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;T.length();i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(i&lt;P)&#123;</span><br><span class="line">             <span class="keyword">int</span> j=Po-i+Po;</span><br><span class="line">             <span class="keyword">int</span> threshold=P-i+<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span>(Len[j]&lt;threshold)&#123;</span><br><span class="line">                 Len[i]=Len[j];</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Len[j]&gt;threshold)&#123;</span><br><span class="line">                 Len[i]=P-i+<span class="number">1</span>;</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Len[j]==threshold)&#123;</span><br><span class="line">                 <span class="keyword">int</span> left=i-P+i<span class="number">-1</span>;</span><br><span class="line">                 <span class="keyword">int</span> right=P+<span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;T.length()&amp;&amp;T[left]==T[right])&#123;</span><br><span class="line">                     right++;</span><br><span class="line">                     left--;</span><br><span class="line">                 &#125;</span><br><span class="line">                 Len[i]=right-i;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> left=i<span class="number">-1</span>;</span><br><span class="line">             <span class="keyword">int</span> right=i+<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;T.length()&amp;&amp;T[left]==T[right])&#123;</span><br><span class="line">                 right++;</span><br><span class="line">                 left--;</span><br><span class="line">             &#125;</span><br><span class="line">             Len[i]=right-i;</span><br><span class="line">         &#125;</span><br><span class="line">         aimIndex=Len[i]&gt;=Len[aimIndex]?i:aimIndex;</span><br><span class="line">         <span class="keyword">if</span>(i+Len[i]<span class="number">-1</span>&gt;P)&#123;</span><br><span class="line">             P=i+Len[i]<span class="number">-1</span>;</span><br><span class="line">             Po=i;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 从 T 中提取最长回文子串</span></span><br><span class="line">     <span class="built_in">string</span> ans=<span class="string">""</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=aimIndex-Len[aimIndex]+<span class="number">1</span>;i&lt;=aimIndex+Len[aimIndex]<span class="number">-1</span>;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(T[i]!=<span class="string">'#'</span>)&#123;</span><br><span class="line">             ans+=T.substr(i,<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/01/leetcode-%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/01/leetcode-%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">leetcode 刷题经验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-01 16:20:40" itemprop="dateCreated datePublished" datetime="2020-02-01T16:20:40+08:00">2020-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-05 21:20:04" itemprop="dateModified" datetime="2020-02-05T21:20:04+08:00">2020-02-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c-不要用局部静态变量-在多个测试用例的调用过程中局部静态变量只会被初始化一次导致测试用例之间的结果相互影响出现-bug"><a class="markdownIt-Anchor" href="#c-不要用局部静态变量-在多个测试用例的调用过程中局部静态变量只会被初始化一次导致测试用例之间的结果相互影响出现-bug"></a> C++ 不要用局部静态变量。在多个测试用例的调用过程中，局部静态变量只会被初始化一次，导致测试用例之间的结果相互影响，出现 bug。</h1>
<h1 id="想要所有的递归函数使用同一个变量有三种方法全局变量局部静态变量参数传引用"><a class="markdownIt-Anchor" href="#想要所有的递归函数使用同一个变量有三种方法全局变量局部静态变量参数传引用"></a> 想要所有的递归函数使用同一个变量有三种方法，全局变量，局部静态变量，参数传引用。</h1>
<h1 id="string-转-int"><a class="markdownIt-Anchor" href="#string-转-int"></a> string 转 int</h1>
<ol>
<li>使用 C++ 11 中的全局函数 std::to_string</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用 sstream 中定义的字符串流对象来实现</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ostringstream</span> os; <span class="comment">// 构造一个输出字符串流，流的内容为空</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">12</span>;</span><br><span class="line">os&lt;&lt;i; <span class="comment">// 向输出字符串流中输入 int 型整数 i 的内容</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;os.str()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1 id="c-stringstream-使用"><a class="markdownIt-Anchor" href="#c-stringstream-使用"></a> C++ stringstream 使用</h1>
<p>C++ 的输入输出分为三种</p>
<ol>
<li>基于控制台的 I/O</li>
</ol>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>istream 从流中读取、ostream 写到流中去、iostream 对流进行读写</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>基于文件的 I/O</li>
</ol>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>fstream</td>
<td>ifstream 从文件中读取、ofstream 写到文件中去、fstream 对文件进行读写</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>基于字符串的 I/O</li>
</ol>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>sstream</td>
<td>istringstream 从 string 对象中读取、ostringstream 写到 string 对象中去、stringstream 对 string 对象进行读写</td>
</tr>
</tbody>
</table>
<p>ostringstream、istringstream、stringstream 这三个类包含在 sstream.h 文件中。<br />
istringstream 类用于执行 C++ 风格的串流的输入操作。<br />
ostringstream 类用于执行 C++ 风格的串流的输出操作。<br />
stringstream 类同时支持 C++ 风格的串流的输入输出操作。</p>
<ul>
<li>istringstream 类<br />
从字符串中提取数据，支持 &gt;&gt; 操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">istringstream</span>::<span class="built_in">istringstream</span>(<span class="built_in">string</span> str); <span class="comment">// 构造函数原型</span></span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">istr</span><span class="params">(<span class="string">"1 56.3"</span>)</span></span>; <span class="comment">// 初始化一个 istringstream 对象</span></span><br><span class="line">istr.str(<span class="string">"1100 2.3"</span>); <span class="comment">// 把字符串写入 istr 中。可以使用分界点获取不同的数据，完成字符串到其他数据类型的转换。</span></span><br><span class="line">istr.str(); <span class="comment">// 使 istringstream 返回一个字符串</span></span><br><span class="line"><span class="comment">// 举例 把字符串转换为其他数据类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">istr</span><span class="params">(<span class="string">"1 56.7"</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;istr.str()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//直接输出字符串的数据 "1 56.7"   </span></span><br><span class="line">      </span><br><span class="line">    <span class="built_in">string</span> str = istr.str();<span class="comment">//函数str()返回一个字符串   </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="keyword">double</span> d;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//以空格为界，把istringstream中数据取出，应进行类型转换   </span></span><br><span class="line">    istr&gt;&gt;n;<span class="comment">//第一个数为整型数据，输出1   </span></span><br><span class="line">    istr&gt;&gt;d;<span class="comment">//第二个数位浮点数，输出56.7   </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//假设换下存储类型   </span></span><br><span class="line">    istr&gt;&gt;d;<span class="comment">//istringstream第一个数要自动变成浮点型，输出仍为1   </span></span><br><span class="line">    istr&gt;&gt;n;<span class="comment">//istringstream第二个数要自动变成整型，有数字的阶段，输出为56   </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//测试输出   </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    system(<span class="string">"pause"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hespoon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">hespoon</p>
  <div class="site-description" itemprop="description">全心全意的投入生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hespoon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hespoon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hezaojian@gmail.com" title="E-Mail → mailto:hezaojian@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fas fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hespoon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">113k</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
