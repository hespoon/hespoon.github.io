<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-hespoon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-hespoon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-hespoon.png">
  <link rel="mask-icon" href="/images/hespoon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hespoon.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":"//cdn.jsdelivr.net/gh/user/repo@version/file","lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="全心全意的投入生活">
<meta property="og:type" content="website">
<meta property="og:title" content="Spirit">
<meta property="og:url" content="http://hespoon.github.io/index.html">
<meta property="og:site_name" content="Spirit">
<meta property="og:description" content="全心全意的投入生活">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="hespoon">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hespoon.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Spirit</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Spirit</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hespoon" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2021/01/01/2020-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/01/2020-summary/" class="post-title-link" itemprop="url">2020-summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-01 12:57:14 / Modified: 15:48:49" itemprop="dateCreated datePublished" datetime="2021-01-01T12:57:14+08:00">2021-01-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天是 2021 年 1 月 1 日，辛丑牛年，是一个标准的平年，共 365 天。新年伊始，应当辞旧迎新，总结 2020，拥抱 2021。</p>
<p>意识流总结开始​ 😜</p>
<p>首先，我缺少面对困难的勇气。</p>
<p>2020 年的新年，就是除夕夜，我已经没有太多印象了。大致记得我依旧是在担心那些长久不变的担心，什么朋友怎么不给我发新年问候呢，大家把我忘了吗，巴拉巴拉的乱想，与过去的 21 年并无太大变化，心智明显不太成熟，不知向前看。</p>
<p>2020 年一月份爆发了疫情，由于家庭问题，我和爸爸，弟弟在山西大同过年，并被困在了大同。在大同的日子里，我的日常是啥呢？每天背单词，并将每天的单词量增加到了 200，200 中包括需要复习的和新背的，实际平均下来每天最多新背 10 个单词。我对英语的信念是，单词量上去了，看英文资料就没问题了，就可以接触更广阔的世界了。</p>
<p>除了背单词，最重要的事情就是找工作。</p>
<p>找工作是因为我即将本科毕业，考研也失败了。本人参加了 2020 年的研究生考试，现在已经查不到成绩了，我也记不得准确分数了，只记得大概是 250 分左右，其中数学尤其差，只考了 50 分左右。说实在，应当在 2020 年年初的时候做一个总结，不过现在补上也还行，就是不太详细了。一句话总结 2020 年准备考研的经历，我充分发现了我好吃懒做，没有耐心，没有定力，拖延严重，不知事情轻重缓急的下等人本质。做事容易沉迷细枝末节，不想，甚至有些逃避一件事的最重要的部分。准备考研的日子里，没有将精力集中于复习知识，没有整体的复习计划，反而为占座投入太多，专门买了厚坐垫，买了各种考研的周边物品。自己的课桌，宿舍书桌被整理的很整洁，而内心中却一团乱麻，总是不敢面对事情的重点。反观石先生，虽然书桌经常乱乱的，电脑中的文件也总是乱放，但是，石先生做事很稳健，敢于直面困难，直面事情的重点，任何事情总能顺利完成，有毅力，能很好的和自己相处。我希望石先生是我的好朋友，但我的实际行动可能并没有将石先生当作好朋友对待，甚至有时候还会恰恰相反，这是我这人为人处世的一个败笔，缺失也造成了石先生对我的远离。客观来看，石先生现在只是我的一般朋友。这种人际关系的进展在我的生活中曾经出现过多次，我认为是我的性格在作妖，希望我能在新的一年中有所改变。与朋友交，而信。</p>
<p>总之，反观我的考研经历，我的人性弱点暴露无遗。2020 年正是以考研失败，开始找工作开始的。</p>
<p>在找工作的过程中，我的本性又开始左右我的行为了。找工作是当时最重要的一件事，这件事主要由三部分组成，投简历，在 leetCode 上刷题，参加面试并总结面试过程。我的本性使我消极对待刷题，每天总是将刷题放在最后再做。为啥说是我的本性在作怪呢，我描述个现象，各位就能够简单的看出来了。在准备考研时，最重要的是复习初试要考的基础知识，我却花费了接近两个月的时间刷题，准备 PAT 考试，该考试只有在初试通过后才有作用，对于准备考研的我来说，是不重要的事；在找工作时，我每天花费大量时间背单词，看魔书 1031，参加高性能 MySQL 读书会，这些无关紧要的事情压缩了每天的刷题时间。显然，我在逃避，我在害怕。我讨厌刷题吗？在刷题不重要时，我喜欢刷题；在刷题重要时，我逃避刷题。更抽象一点，在没人监督我的情况下，我会逃避那些重要的事，用其他的事塞满我的时间，使我不用面对真正重要的问题。这种性格使我总是忽略重要且紧急的事，使我的生活总是紧紧张张的，使我错过我本能获得东西，我讨厌这种性格，我需要改变我自己。</p>
<p>2020 年 3、4 月，可能是我运气足够好，耗时足够长，即使不断逃避那些重要的事，但最终还是做了一部分并起到了作用，我拿到了华为的 offer。找工作告一段落，接下来是完成毕业设计，使我能够顺利毕业。那么新的问题出现了。</p>
<p>我缺少解决问题的耐心。</p>
<p>现在想想，我的毕业设计要做什么呢？其实，就是在现有的系统中，添加一个新的功能。这个功能需求明确，且不会变更，因为已经在开题报告中将需求写死了，不能修改了。实现一个明确且不会变更的需求，这不就是软件开发中最简单的事吗？为了完成这个需求，我需要了解现有系统是怎么运作的，需要学习 JSP 来使用 Java 开发前端页面，学习前后端是如何交互的。做完这三步，我就可以开发新的功能了。但实际上，在完成毕业设计的 3 个月中，我的精神始终是紧绷的。最开始的时候，我认为时间充足，所以一直在玩，根本没有投入到毕业设计中。一个多月过后，我开始紧张，并开始着手完成毕业设计。但是由于我急着想开始着手开发功能，导致必要知识的准备工作被我一带而过，这就造成了功能开发缓慢，需要边开发边查文档。最后，当同组的同学已经提交毕设终稿时，我的压力到达了顶峰。这时我的功能还没开发完，只能硬着头皮写毕设论文，论文中的图片都是一些未达到效果强行实现的前端页面，没有任何意义。受疫情的影响，毕设答辩是远程进行的，每人只有 8 分钟的时间来讲解毕设论文，这也给了我可乘之机。虽然我做的新功能基本不能用，但讲解时根本没有时间演示，只能通过图片介绍该功能。最终，我险之又险的通过了毕业答辩，走完了我在华工的最后一段路。</p>
<p>拖延，逃避，没有耐心，没有责任心，它们使简单的事情变复杂，使生活变糟糕，压力变大，头发变少。自作自受，不可活。😞</p>
<p>后来，我不够主动，不够坚定，十分冷血，十分精致利己。</p>
<p>我毕业了。疫情原因，学校没有大型的毕业典礼，学院自己准备的毕业典礼也取消了。大学最后，我没有和任何人拍照，也没有能够聚一聚的朋友。现在想想，真是可怜呐。班里的同学是有一起拍照的噢，只是没人来邀请我罢了。没人觉得我是一个值得交往的人？有点可悲哦。但我有八成的把握，如果我主动邀请别人拍照，他们是不会拒绝的。是他们有礼貌的不回绝呢，还是他们也是希望能和我拍照留下一个纪念，只是不好意思跟我说呢？这种问题是真的没有答案啊。为啥说我冷血和精致利己呢？我描述两件事情吧。大学四年，我是宿舍长，宿舍的卫生一直是我打扫，宿舍一直保持着干净整洁，辅导员每次来都会夸赞，四年的电费水费都是我跑腿去水电中心交的，宿舍内的设备损坏，百分之九十是我来保修的，宿舍的厕所，在我的一位室友刷过一次后，一直都是我来刷，宿舍的浴室，倒是我的另一个室友隔段时间打扫一次，我没有打扫过，宿舍的洗衣机，每个学期我都会买清洗粉清洗。我这样为别人付出，为啥还是精致利己呢？因为，我做这些事情，全都是因为我罢了，我喜欢干净，就会主动维护卫生，我讨厌突然没电，所以每个学期都会主动跑腿去交电费。我的所做作为和我的室友是谁没有关系，只是符合我的利益罢了。第二件事，毕业后，我在广州的姑姑家住着，等着入职，这期间，姑姑和姐姐大吵了一架，然后两人就没在说过话。后来姐姐跟我聊天，解释了为啥她俩会搞得这么严重，我嘴上说着安慰的话，心里却认为是我姐太懒了，心口不一，却又不敢说出实情。这种人际关系的发展在我的生活中出现过多次，我害怕与人争吵，所以经常说一些违心的话。会不会是我的话不够真诚，导致也很少有人真诚待我呢？</p>
<p>终于，我开始工作了。</p>
<p>工作确实不容易。到今天，我已经入职 4 个月了，下个月要转正答辩。前面说的问题，我一个都没丢，如果不是现在写总结，我可能会继续浑浑噩噩的过下去，直到所有的问题积累过头，全部一下子猛地爆发出来，把我炸的体无完肤。不能这样，我应当去改变了。改变很难，甚至我会逃避改变逃避。但我也缺失做过成功的改变，根据我的经验，消除恐惧的最好办法就是直面恐惧，加油啊。</p>
<p>我希望，我在 2021 年中，鼓起勇气，直面生活，不再逃避，不再逃避，不再逃避，不再逃避。</p>
<p>具体做什么呢？减肥，将体重控制到 70kg，通过跑步和控制饮食来完成。精进工作所需的专业技术，至少一次转测拿 A，通过可信专业级考试。背单词，每天 100 个，坚持不断。诚以待人，诚以待人。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/10/14/C-sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/C-sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">C++ sizeof 运算符</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-14 23:14:39 / Modified: 23:39:02" itemprop="dateCreated datePublished" datetime="2020-10-14T23:14:39+08:00">2020-10-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h1>
<p>计算对象或类型的大小，单位为字节 byte。</p>
<p>被计算大小的对象或类型的大小必须是明确的，不能是不可知的。</p>
<h1 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(type);</span><br><span class="line"><span class="keyword">sizeof</span> expression;</span><br></pre></td></tr></table></figure>
<p>在不同的计算机体系结构下，一个字节占用的 bit 数是不确定的，可能是 8bit 或者更多，具体数值由宏 CHAR_BIT 定义。但是，无论一个 byte 占用多少个 bit，下列表达式的值都是 1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span>)==<span class="keyword">sizeof</span>(<span class="keyword">char8_t</span>)==<span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">char</span>)==<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)==<span class="keyword">sizeof</span>(<span class="built_in">std</span>::byte)==<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>sizeof 不能计算函数类型，不完整类型和 glvalues 的大小，强行计算会报错。</p>
<p>当用 sizeof 计算引用的大小时，实际上计算的是被引用的类型的大小。</p>
<p>当用 sizeof 计算一个类的大小时，返回值是一个该类的对象的大小加上将一个该类的对象放入数组中时所要填充的空间的大小。也就是会返回该类的对象在按照字节对齐后的大小。</p>
<p>sizeof 的结果永远不会是 0，即使计算一个空类的大小也不是 0。</p>
<p>当使用 <code>sizeof expression</code> 时，sizeof 不会判断 expression 是否是有效的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/10/08/C-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/08/C-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">C++ 安全编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-08 21:49:39 / Modified: 21:53:16" itemprop="dateCreated datePublished" datetime="2020-10-08T21:49:39+08:00">2020-10-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="整数"><a class="markdownIt-Anchor" href="#整数"></a> 整数</h1>
<p>以函数封装的形式调用安全函数，降低了代码的可读性，会引发误用风险</p>
<p>不能用立即数充当 destMax，这会导致代码不明确</p>
<p>destMax 一定要正确填写为目的缓冲区的长度</p>
<p>安全函数的返回值是保证安全性的一部分，一般情况下不能忽略对返回值的检查</p>
<p>有符号整数的溢出可能会导致符号变化，无符号整数的溢出会导致大数变小数。</p>
<p>C++ 和 C 中的溢出是未定义的行为，是不能基于溢出结果做假设的。</p>
<p>整数溢出可以被利用做 DoS 和 执行任意代码</p>
<p>大整数强制转换类型时，如果该大整数超出了新的类型可表示的最大值，会发生截断，导致失真</p>
<p>当有符号数强制转换为无符号数时，必须考虑范围问题。比如一个负的有符号数强制转换为一个无符号数时，会得到一个超大的无符号数，引发意想不到的结果。</p>
<p>将整形表达式赋值给较大类型前，没有显示转换为较大类型，会造成数据溢出。</p>
<p>对有符号整数进行位操作可能会出现数据反转。</p>
<p>C 语言标准中制定了 uintptr_t 来表示指针的整数类型。</p>
<h1 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h1>
<p>危险操作</p>
<p>内存拷贝时未判断目标内存长度的有效性</p>
<p>内存申请后未判断返回值</p>
<p>使用已经释放的内存</p>
<p>调用不匹配的内存管理操作，new、delete 和 malloc、free 混用</p>
<p>重复释放内存</p>
<p>windows 使用一个双向链表管理管理正在使用的堆内存</p>
<p>当程序中申请 10 字节的堆内存时，实际耗费了 20 字节的物理内存，其中各部分组成如下：</p>
<ol>
<li>分配内存头，包含一个前向指针和一个后向指针，共占用 8 字节</li>
<li>分配内存体，按照 4 字节对齐原则，分配给申请者 12 字节的内存</li>
</ol>
<p>指针在定义时要初始化，内存在分配后要立即初始化。分配内存后不初始化，可能导致内存中原有的信息泄露。</p>
<p>访问以释放的内存的危险主要分为两种的情况：</p>
<ol>
<li>堆内存：一块内存释放后，就归还给了内存池，就不应该再访问了。这块内存可能被其他代码申请使用，通过原来的指针访问这块内存可能导致其他使用该内存的函数功能不正常。因此，内存释放后要及时将指针置为 nullptr 或指向其他有效内存。</li>
<li>栈内存：函数执行时的临时变量存储在栈上，如果函数将临时变量的地址返回了，则可能导致程序崩溃或者执行恶意代码。</li>
</ol>
<p>重复释放内存可能会导致管理堆内存的双向链表发生混乱，产生不可预计的错误。</p>
<p>申请内存之前要检验表示被申请内存大小的整数值，否则会出现下列三种可能的错误：</p>
<ol>
<li>使用 0 字节长度申请内存的行为是没有意义的</li>
<li>若申请的内存长度大于最大值，则可能导致内存申请失败，造成 DoS</li>
<li>若使用负数长度申请内存，负数会被隐式转换为一个很大的无符号整数，同样可能导致内存分配失败。</li>
</ol>
<p>申请内存后要检查是否申请成功</p>
<p>不应当使用 alloca 函数申请内存。</p>
<p>因为 alloca 函数是在栈上申请内存的，而栈一般很小，很容易耗尽，而且分配的内存很容易越过栈的边界而无法预知。</p>
<p>POSIX 和 C99 中均未定义 alloca 的行为。</p>
<p>应当与 malloc 申请内存，然后用 memset_s 函数初始化内存。</p>
<p>应当尽量少的使用 realloc 函数调整内存大小。</p>
<p>realloc 函数实现非常复杂，功能不单一，不是一个好的函数实现。</p>
<p>realloc 函数原型如下：</p>
<p>void* realloc(void* ptr, size_t size)</p>
<p>参数不同，realloc 函数的行行为也不同：</p>
<ul>
<li>当 ptr !=     nullptr &amp;&amp; size != 0 时，realloc 会重新调整内存大小，并返回指向新内存的指针。调整后内存中的内容与新旧两块内存大小较小者保持一致。如果是将原内存调大，而申请新的内存失败了，则返回 nullptr，并且保持原内存有效，依旧可以通过 ptr 访问原内存。</li>
<li>当 ptr ==     nullptr &amp;&amp; size !=0 时，realloc 相当于 malloc(size)。</li>
<li>当 size ==     0 时，C<ins>98 中相当于 free(ptr)，C</ins>11 中则是一种未定义的行为。</li>
</ul>
<h1 id="不安全函数"><a class="markdownIt-Anchor" href="#不安全函数"></a> 不安全函数</h1>
<p>不安全函数包括未指定目的缓冲区大小的内存操作函数和各种容易用错的函数。</p>
<p>可能导致命令注入的函数</p>
<p>#include &lt;cstdlib&gt;</p>
<p>int system(const char* command);</p>
<p>system 函数可以调起命令解析器执行命令。</p>
<p>command 为 nullptr 时，该函数用于检查是否可以成功调起命令解释器，如果调起成功，则返回一个非零值，失败则返回零。</p>
<p>command 不为 nullptr 时，该函数用于执行命令，返回值与 system 函数的实现有关。</p>
<p>#include &lt;cstdio&gt;</p>
<p>FILE* popen(const char* command, const char* type);</p>
<p>popen() 会调用 fork() 产生子进程，然后从子进程中调用 /bin/sh -c 来执行参数 command 的指令。参数 type 的可取值为 “r” 和 “w”。“r” 代表读取，“w” 代表写入。依据 type 的值，popen() 会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可以利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输出设备中。</p>
<p>不应当使用外部输入的参数作为命令直接执行或者直接拼接到命令中执行。如果必须要使用，则要对外部输入做白名单校验或者做硬编码。</p>
<p>使用 Win32 API 中的 CreateProcess() 函数或者 POSIX 的 exec 系列函数代替 system 函数。</p>
<p>如果使用 system 函数，则应使用硬编码的函数入参或对外部输入中的命令分隔符进行过滤或转义。</p>
<p>多线程下的线程不安全函数</p>
<p>这些函数中可能有静态变量或者全局变量，导致函数不可重入。</p>
<p>执行的时序不同，函数的执行结果也可能不同。</p>
<ol>
<li>函数 strtok 使用了一个静态局部变量标记当前位置，导致不可重入。printf 和 cout 混用，printf 和 cout 在 C++ 标准下是同步的，但是有的编译器可能没有按照标准来处理，所以混用 printf 和 cout 可能发生因时序导致的错误。</li>
<li>信号处理程序中使用异步不安全函数，比如 I/O 函数，自定义的异步不安全函数等。这会造成信号阻塞，使程序执行结果不可预测。</li>
</ol>
<p>使用 strtok_r 代替 strtok，或者华为的 strtok_s 代替 strtok</p>
<p>异步信号安全</p>
<p>异步信号安全操作可以保证不会干扰正被中断的操作。</p>
<p>当信号处理程序干扰正被中断的操作时，就会引发异步信号安全问题。</p>
<p>在信号处理程序与正被同步的操作之间执行的任何同步尝试都将立即产生死锁。</p>
<p>获取安全随机数</p>
<p>Unix/Linux 下可以读取 /dev/random 文件获取安全随机数</p>
<p>Windows 使用随机数生成函数 CryptGenRandom() 生成安全随机数</p>
<p>使用开源组件 openssl 获取安全随机数</p>
<p>使用华为的 iPSI 组件</p>
<h1 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h1>
<p>常见问题</p>
<ul>
<li>文件操作返回值判断有误</li>
<li>文件创建时没有指定合适的文件权限</li>
<li>对文件的路径校验不够完全</li>
</ul>
<p>尽量使用文件句柄作为文件的操作对象。</p>
<p>std::string 是不适合用来保存敏感信息的。</p>
<p>C 中的 realpath 函数</p>
<p>#include &lt;limits.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>char* realpath(const char *path,char *resolved_path)</p>
<p>realpath()函数用来将参数 path 所指的相对路径转换为绝对路径后存与参数 resolved_path 所指的字符串数组或指针中</p>
<p>成功则返回指向 resolved_path 的指针，失败则返回 NULL，错误代码存于 errno 中</p>
<p>该函数可能存在缓冲区溢出的风险。</p>
<p>malloc 是线程安全的。malloc 在访问内存链表时会加锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/10/04/C-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/04/C-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">C++ 风格的强制类型转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-04 18:25:10" itemprop="dateCreated datePublished" datetime="2020-10-04T18:25:10+08:00">2020-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-05 20:24:25" itemprop="dateModified" datetime="2020-10-05T20:24:25+08:00">2020-10-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c-风格的强制类型转换"><a class="markdownIt-Anchor" href="#c-风格的强制类型转换"></a> C++ 风格的强制类型转换</h1>
<p>强制类型转换运算符是一种特殊的运算符，它把一种数据类型转换为另一种数据类型。</p>
<p>强制类型转换运算符是一元运算符，它的优先级与其他一元运算符相同。</p>
<p>**static_cast&lt;type&gt;(expression) **</p>
<p>static_cast 可用于各种隐式转换，比如 double 转 int，int 转 unsigned int 等，效果与隐式转换一样，可能有各种奇怪的错误，需要用户保证转换是正确的。</p>
<p>static_cast 可用于基类指针（引用）与派生类指针（引用）之间的相互转换。与 dynamic_cast 不同，在将基类指针转换为派生类指针时，编译器不会检查该基类指针是否指向了一个派生类对象，会强行将基类指针转换为派生类指针，即使这种转换是错误的。因此，使用 static_cast 将基类指针转换为派生类指针时，要保证转换是可行的。</p>
<p>static_cast 可用于将具有显示构造函数（explicit 修饰的构造函数）或者显示函数的类转换为隐式构造函数的类。</p>
<p><strong>const_cast&lt;type&gt;(expression)</strong></p>
<p>用于 const 与非 const、volatile 与非 volatile 之间的转换。</p>
<p>可以将一个非常指针（引用）转换为常指针（引用），也可以将一个常指针（引用）转换为非常指针（引用）。</p>
<p><em><strong>const_cast is evil!</strong></em></p>
<p>const_cast 可以破坏 const 关键字对参数的限定，使得函数可以修改 const 关键字修饰的参数。</p>
<p>例 1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *a)</span> <span class="comment">// 接收常指针，不能通过指针修改指针指向的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * int *b = a; 将常指针赋给普通指针是不合法的，会报错无法编译</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(a); <span class="comment">// 将常指针转换为非常指针</span></span><br><span class="line">    *b = <span class="number">100</span>; <span class="comment">// 修改常指针 a 指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;before: &quot;</span> &lt;&lt; *a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    fun(a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; *a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before: 10</span><br><span class="line">after: 100</span><br></pre></td></tr></table></figure>
<p>常指针 a 指向的值被函数 fun 修改了。</p>
<p>例 2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span> <span class="comment">// 一般情况下 const 关键字表明 fun 不会修改 a 的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * int *b = &amp;a; 将常引用赋给普通指针是不合法的，会报错无法编译</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(&amp;a); <span class="comment">// 将常引用转换为普通指针</span></span><br><span class="line">    *b = <span class="number">100</span>; <span class="comment">// 通过指针修改 a 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;before: &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    fun(a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before: 10</span><br><span class="line">after: 100</span><br></pre></td></tr></table></figure>
<p>a 的值被函数 fun 修改了。</p>
<p>如果没有 const_cast，则函数 fun 的参数用 const 修饰后，表明函数 fun 不会也无法修改参数的值，而现在可以通过 const_cast 将常量转换为非常量，导致 const 关键字修饰的参数可以被修改了，使 const 关键字失去了应有的约束力。</p>
<p><strong>reinterpret_cast&lt;type&gt;(expression)</strong></p>
<p>reinterpret_cast 用于将一种类型的指针强行转换为另一种类型的指针，不管这两个类型是否有关系。</p>
<p>比如 reinterpret_cast 可以将一个指向苹果类的指针转换为指向潜水艇类的指针。明显苹果与潜水艇之间没有一点关系，转换后的指针根本不能用。</p>
<p>reinterpret_cast 也可以实现指针和整形之间相互转换。可以将一个整数转换为指针，也可以将指针转换为整数。指针本质就是一个无符号整数，是指针指向变量的地址。将指针转换为整数仅仅是想表达指针转换后的值是可以存储为 int 类型的数据。</p>
<p>它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。</p>
<p>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整。</p>
<p><strong>dynamic_cast&lt;type&gt;(expression)</strong></p>
<p>只能用于转换不同类型的指针或者转换不同类型的引用。</p>
<p>转换指针失败时返回空指针。转换引用失败时抛出 bad_cast 异常。</p>
<p>借助 RTTI Run-Time Type Information，用于类型安全的向下转型（Downcasting），有些编译器的 RTTI 默认是关闭的，在使用 dynamic_cast 是要保证编译器的 RTTI 是开启的。</p>
<p>将派生类指针或引用转换为基类指针或饮用时，dynamic_cast 保证转换总是成功的。</p>
<p>一般情况下，用 dynamic_cast 将基类指针（引用）转换为派生类指针（引用）是会报编译错误的，除非基类指针指向了一个派生类对象。</p>
<p>dynamic_cast 在运行时执行转换，转换时会验证有效性。</p>
<p>如果转换未执行，则转换失败，表达式 expression 被判定为 null。</p>
<p>dynamic_cast 执行动态转换时，type 必须是类的指针、类的引用或者 void*。</p>
<p>如果 type 是类指针，则 expression 也必须是类指针；如果 type 是一个引用，则 expression 也必须是一个引用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/06/26/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/26/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">数学公式测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-26 17:55:17 / Modified: 19:41:22" itemprop="dateCreated datePublished" datetime="2020-06-26T17:55:17+08:00">2020-06-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">e=mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: equation at position 7: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲}̲
e=mc^2
\end{eq…'>\begin{equation}
e=mc^2
\end{equation}
</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: equation at position 7: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲}̲ \label{eq2}
\b…'>\begin{equation} \label{eq2}
\begin{aligned}
a &amp;= b + c \\
  &amp;= d + e + f + g \\
  &amp;= h + i
\end{aligned}
\end{equation}
</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/06/18/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%9F%B9%E8%AE%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%9F%B9%E8%AE%AD/" class="post-title-link" itemprop="url">深信服培训</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-18 11:32:56 / Modified: 15:23:01" itemprop="dateCreated datePublished" datetime="2020-06-18T11:32:56+08:00">2020-06-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="工作内容"><a class="markdownIt-Anchor" href="#工作内容"></a> 工作内容</h2>
<p>使用 C 语言实现了一系列构建 JSON 结构的 API，支持 string、number、bool、array 和 object 五种 JSON 对象。同时实现了 JSON 转 YAML 的功能，用户通过 <code>json_save</code> API 将创建的 JSON 对象转换为 YAML 格式。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/18/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%9F%B9%E8%AE%AD/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/04/20/JSP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/JSP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">JSP 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 09:22:39" itemprop="dateCreated datePublished" datetime="2020-04-20T09:22:39+08:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-14 12:13:02" itemprop="dateModified" datetime="2020-06-14T12:13:02+08:00">2020-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="jsp-learn"><a class="markdownIt-Anchor" href="#jsp-learn"></a> JSP Learn</h1>
<p>JSP 技术以 Java 语言作为脚本语言。</p>
<p>使用 JSP 标签在 HTML 网页中插入 Java 代码。</p>
<p>JSP 标签通常以 <code>&lt;%</code> 开头，以 <code>%&gt;</code> 结尾。</p>
<p>JSP 通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p>
<p>JSP 标签有多种功能，比如访问数据库、记录用户选择信息、访问 JavaBeans 组件等，还可以在不同的网页中传递控制信息和共享信息。</p>
<p>JSP 直接在 HTML 网页中动态嵌入元素。</p>
<p>服务器调用的是已经编译好的 JSP 文件。</p>
<p>JSP 基于 Java Servlet API。</p>
<p>JSP 可以与处理业务逻辑的 Servlet 一起使用。</p>
<p>网络服务器需要一个 JSP 引擎，也就是一个容器来处理 JSP 界面，容器负责截获 JSP 页面的请求。</p>
<p>Apache 内嵌了 JSP 容器。</p>
<p>JSP 容器与 Web 服务器协同合作，为 JSP 的正常运行提供必要的运行环境和其他服务，并且能够正确识别专属于 JSP 网页的特殊元素。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/20/JSP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-17 06:54:14 / Modified: 13:44:00" itemprop="dateCreated datePublished" datetime="2020-03-17T06:54:14+08:00">2020-03-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h1>
<ul>
<li>
<p>TCP 协议 Transmission Control Protocol</p>
</li>
<li>
<p>TCP 是传输层的协议，解决传输的可靠、有序、无丢失和不重复。</p>
</li>
<li>
<p>面向连接的，每条 TCP 连接只有两个端点</p>
</li>
<li>
<p>全双工通信，通信双发在任何时候都能发送数据，有缓存，用于临时存放双向通信数据</p>
</li>
<li>
<p>面向字节流，TCP 将应用程序交付的数据视为一串无结构的字节流</p>
</li>
<li>
<p>TCP 首部最短 20B。</p>
<ul>
<li>源端口，目的端口各占 2B。</li>
<li>序号字段 4B，每个字节都会编号。</li>
<li>确认字段 4B，是期望收到的报文段数据的第一个字节的序号</li>
<li>数据偏移，4 位。单位是 4B。表示首部的长度</li>
<li>保留字段 6 位</li>
<li>6 个状态位。URG 紧急位、ACK 确认位、PSH 推送位、RST 复位位、SYN 同步位、FIN 终止位</li>
<li>窗口字段。指出现在允许对方发送的数据量，单位为字节。</li>
<li>校验和。 2B，校验首部和数据两部分，计算时要加上伪首部。</li>
<li>紧急字段指针，2B。指出本报文段中紧急数据共有多少字节。</li>
<li>选项字段，长度可变。</li>
<li>填充字段。使头部的长度为 4B 的整数倍。</li>
</ul>
</li>
<li>
<p>建立连接的 3 次握手</p>
<ul>
<li>SYN=1，seq=x，不含应用层数据，消耗一个序号</li>
<li>SYN=1，ACK=1，ack=x+1，seq=y，不含应用层数据，消耗一个序号，服务器为连接分配资源，因此易受 SYN 洪泛攻击</li>
<li>ACK=1，seq=x+1，ack=y+1，可以开始携带应用层数据，客户端为连接分配资源</li>
<li>为何要三次握手？为了解决网络中存在延迟的重复分组。比如，客户端发送了一个连接请求，但在网络中长时间的滞留了，以至于延迟到连接结束后的某个时间到达了服务器。服务器会误以为这是一个新的连接请求，然后响应该请求并发出确认，为连接分配资源。如果不采用三次握手，客户端不理睬服务器的确认，不会向服务器传输数据，因此服务器的资源就被浪费了。</li>
</ul>
</li>
<li>
<p>断开连接的 4 次挥手</p>
<ul>
<li>FIN=1，seq=u，客户端主动请求断开连接</li>
<li>ACK=1，seq=v，ack=u+1，此时客户端到服务器的连接已经释放了，TCP 处于半关闭状态，服务器发送数据，客户端依旧要接收。客户端不能发送数据，但可以发送确认报文。</li>
<li>FIN=1，ACK=1，seq=w，ack=u+1，此时服务器请求释放连接</li>
<li>ACK=1，seq=u+1，ack=w+1，客户端收到服务器发来的连接释放报文后，必须要发出确认，然后等待 2 个报文最大生存时间后关闭连接。服务器端在接受到客户端的确认报文后就断开连接。</li>
<li>为何要四次挥手？<br />
因为在客户端主动要求断开连接后，服务器端还可能存在需要发送的数据，要等这些数据发送完后，再断开 TCP 连接。</li>
<li>为何要有 TIME_WAIT 阶段<br />
因为客户端在发送确认报文后，服务器端可能没有收到，此时服务器会再次发送请求断开连接的报文，客户端应当保持 TCP 连接一段时间，以便保证服务器端收到了自己的确认报文。同时，TCP 连接占用了一个套接字，连接释放后，该套接字会被其他连接重复使用。若没有 TIME_WAIT 状态，网络中可能还存在当前连接产生的报文，连接释放后，旧的报文可能会被新的连接接收，造成信息混乱。因此，TIME_WAIT 状态主要是保证当前连接产生的报文在网络中已经全部消失了。</li>
</ul>
</li>
<li>
<p>TCP 可靠传输</p>
<ul>
<li>TCP 通过校验机制保证传输的报文段没有差错</li>
<li>TCP 通过首部的序号字段保证数据能够有序的提交给应用层，对每个字节进行编号，同时会丢弃重复数据。</li>
<li>TCP 通过首部的确认号表示期望收到的下一报文段数据的第一个字节的序号，发送方会在缓存中存储那些已经发送但未确认的报文段，以便在需要时重传。使用累计确认</li>
<li>TCP 重传。
<ul>
<li>超时重传<br />
TCP 为每一个发送的报文段都设置一个计时器。计时器设置的重传时间到期但还没有收到确认，就要重传这一报文段。超时重传时间 RTO，加权平均往返时间 RTTs，RTT 的偏差的加权平均值 RTTd。RTO = RTTs + 4 × RTTd，RTTs = ( 1 - α ) × 旧 RTTs + α × 新 RTT 样本，RTTd = ( 1 - β ) × 旧 RTTd + β × |RTTs - 新 RTT 样本|。α 和 β 都是小于 1 大于 0 的系数。第一个 RTTs 等于测量到的 RTT，第一个 RTTd 等于测量到的 RTT 的值的一半。</li>
<li>冗余 ACK<br />
发送方可以通过冗余 ACK 来检测丢包情况。TCP 规定，每当接收方收到比期望序号大的失序报文段时，就发送一个冗余 ACK，指明下一个期待字节的序号。当发送方收到对同一报文段的三个冗余 ACK 时，就认为该报文段已经丢失。冗余 ACK 也用在了拥塞控制中。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TCP 流量控制</p>
<ul>
<li>TCP 提供一种基于滑动窗口协议的流量控制机制。</li>
<li>接收方根据自己缓存的大小，动态调整接收窗口的大小，就是调整头部中的窗口字段。限制发送方的发送速率。</li>
<li>发送方根据当前网络的拥塞情况调整拥塞窗口的大小。发送方的发送窗口取接收窗口和拥塞窗口两者中的最小值。</li>
</ul>
</li>
<li>
<p>TCP 拥塞控制</p>
<ul>
<li>两个窗口，接收窗口和拥塞窗口。发送窗口 = min(接受窗口，拥塞窗口)</li>
<li>四种算法，慢开始、拥塞避免、快重传、快恢复。四种算法是用来维护拥塞窗口的。
<ul>
<li>慢开始。刚开始发送报文段时，令拥塞窗口 = 1，即一个最长报文段的大小。每收到一个对新报文段的确认后，将拥塞窗口的值加 1，就是增大一个 MSS。一般每经过一个传输轮次，拥塞窗口的大小就会翻倍。慢开始一直把拥塞窗口增加到一个阈值后，就改用拥塞避免算法。</li>
<li>拥塞避免。发送端的拥塞窗口每经过一个 RTT 就增加 1，就是开始线性增加。</li>
<li>网络拥塞处理
<ul>
<li>超时<br />
当发送方检测到超时时，就将慢开始阈值设为当前拥塞窗口大小的一半，但不能小于 2，并将拥塞窗口的大小设为一个 MSS。然后开始执行慢开始算法。这样可以快速减少发送方发到网络中的分组数。</li>
</ul>
</li>
<li>快重传<br />
当发送方连续收到三个冗余 ACK 时，就直接重传接收方未收到的报文段，不用等到超时。</li>
<li>快恢复<br />
当发送方收到三个冗余 ACK 时，就将慢开始阈值设为当前拥塞窗口的一半，将拥塞窗口设为改变后的慢开始阈值，然后执行拥塞避免算法。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>UDP 协议，User Datagram Protocol</p>
</li>
<li>
<p>UDP 的优点</p>
<ul>
<li>UDP 无需建立连接，所以没有建立连接带来的延时，速度比较快。</li>
<li>UDP 不用维护连接状态，就是说不用维护发送接收缓存，不用记录确认序号和拥塞控制参数，消耗的资源就小一些。</li>
<li>分组头部开销小，只有 8B。</li>
<li>发送方的应用层能够更好的控制要发送的数据和发送时间。因为 UDP 没有拥塞控制，所以网络中的拥塞不会影响发送方的发送效率。</li>
</ul>
</li>
<li>
<p>UDP 应用</p>
<ul>
<li>一次性传输数据较少的应用。比如 DNS。</li>
<li>多媒体应用。比如实时视频会议。可靠的数据传输对这些应用来说不是最重要的。</li>
</ul>
</li>
<li>
<p>UDP 不保证可靠交付，数据的可靠性要通过应用层来完成。</p>
</li>
<li>
<p>UDP 面向报文，将应用层传下来的报文添加首部后就交给网络层，将网络层传上来的报文去除首部后就交给应用层。</p>
</li>
<li>
<p>UDP 数据报首部</p>
<ul>
<li>2B 的源端口号。需要对方回复时才会使用。</li>
<li>2B 的目的端口号。</li>
<li>2B 的长度标记，单位为 1B</li>
<li>2B 的校验和。是可选的。计算校验和时要在数据报之前添加 12B 的伪首部。校验整个数据报。</li>
</ul>
</li>
<li>
<p>TCP 与 UDP 的区别</p>
<ol>
<li>TCP 是有连接的，UDP 是无连接的</li>
<li>TCP 是可靠的，UDP 是不可靠的。接收方不会对 UDP 报文发送确认报文。</li>
<li>TCP 是面向字节流的，UDP 是面向报文的。TCP 发送报文时以字节为单位，应用层传来的数据报可拆分。UDP 不能拆分数据报。</li>
<li>TCP 有拥塞控制机制，UDP 没有。</li>
<li>TCP 首部开销大，UDP 首部开销小。</li>
<li>UDP 不需要维护连接状态，消耗资源小。</li>
<li>TCP 只支持点对点通信。UDP 可以一对一、一对多、多对一、多对多</li>
</ol>
</li>
<li>
<p>如何选择 TCP 与 UDP<br />
对实时性要求高，对可靠传输要求低时，一般选用 UDP。比如 DNS 服务，直播。对可靠性要求高时用 TCP。HTTP 协议一般都用 TCP。HTTP3 使用了基于 UDP 协议的QUIC 协议。可能是因为现在网络环境越来越好了吧，设备本身越来越可靠，协议上就可以偷些懒。</p>
</li>
<li>
<p>TCP 粘包</p>
<ul>
<li>指发送方发送的若干数据包在到达接收方时粘成了一包。从接收方缓存来看，后一包数据的头紧挨着前一包数据的尾。如果粘包是同一数据的不同部分，可以不处理。如果粘包之间没有关系，此时就必须要使用合理的拆包机制将包分开。</li>
<li>粘包原因
<ol>
<li>发送方默认使用 Nagle 算法，将多次间隔较小，数据量较小的数据报合并成一个数据量大的数据报发送，用于减少网络中的报文段，尽可能的利用网络带宽。</li>
<li>接收方读取接收缓存的速度比 TCP 写入缓存的速度慢。</li>
</ol>
</li>
<li>解决方法
<ul>
<li>发送方可以尝试关闭 Nagle 算法。接收方可以在应用层处理。将接收缓存的数据全部读完后，再分组。可以通过开始符和结束符的方式分组，也可以在数据报数据部分的开始部分记录数据的长度。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>HTTP HyperText Transfer Protocol</p>
<ul>
<li>HTTP 使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li>
<li>HTTP 是专门用来在两点之间传输数据的约定和规范</li>
<li>超文本就是指超越了普通文本，包含有图片、音频、视频和超链接</li>
<li>HTTP 由两个程序实现，一个客户端程序，一个服务器程序。</li>
<li>URL 地址包含两部分，存放文件的服务器地址和文件的存放路径</li>
<li>HTTP 使用 TCP 作为传输协议，应用通过套接字接口将 HTTP 请求发给 TCP 连接，同时也从套接字接口中接受响应信息。</li>
<li>持续连接。客户端与服务器在一个相当长的时间范围内通信时，所有的请求和相应都通过一个 TCP 连接发送，这种模式称为持续连接。</li>
<li>非持续连接。客户端与服务器在一个相当长的时间范围内通信时，每个请求和相应都通过一个单独的 TCP 连接发送。</li>
<li>HTTP 默认使用持续连接，也可以使用非持续连接。</li>
<li>HTTP 客户端进程运行在 80 号端口。</li>
<li>非持续连接中的 TCP 连接可以是串行的也可以是并行的。</li>
<li>HTTP 有两种报文，请求报文和相应报文。HTTP 的报文是明文传输。是无状态的，服务器不会记录客户端的任何信息。
<ul>
<li>请求报文
<ul>
<li>请求报文的第一行叫做请求行，后续的行叫做首部行。</li>
<li>请求行包含三个字段。方法字段、URL 字段和 HTTP 版本字段。</li>
<li>首部行 Host 指明了对象所在的主机</li>
<li>首部行 Connection 指明了是使用持续连接还是非持续连接</li>
<li>首部行 User-agent 指明了用户代理，即向服务器发送请求的浏览器的类型</li>
<li>Content-Length 字段，表明本次回应的数据长度。</li>
<li>Accept 字段用于声明可接受的数据格式。</li>
<li>Accept-Encoding 声明可接受的压缩方式</li>
<li>首部行后有一个空行。空行后是请求的实体。</li>
<li>GET 方法用与获取服务器内容，向服务器传递的参数加在 URL 中，只允许 ASCII 字符，有长度限制。请求的实体为空。</li>
<li>GET 方法是安全的和幂等的。<br />
幂等是指，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。<br />
安全是指，请求方法不会破坏服务器上的资源。</li>
<li>POST 方法一般用来向指定的资源提交数据进行处理请求，如上传表单和文件。数据包含在请求体中。</li>
<li>POST 方法是不安全和不幂等的。</li>
<li>HEAD 方法用于向服务器索要与 GET 请求相一致的响应，但是响应体不返回，只返回响应消息的头部。</li>
<li>PUT 方法用于向指定资源位置上传其最新内容，是幂等的。</li>
<li>DELETE 方法用于删除 URL 所标识的资源。</li>
</ul>
</li>
<li>响应报文
<ul>
<li>第一行是状态行。包含 HTTP 版本，状态码和状态描述</li>
<li>接下来每一行都表示一个 HTTP 首部，为客户端提供关于所发送数据的一些信息，并以一个空行结束</li>
<li>Content-Type 字段用于说明本次数据是什么格式。</li>
<li>Content-Encoding 说明数据的压缩方式</li>
<li>最后是数据块，包含了响应数据</li>
<li>200 OK 表示请求成功</li>
<li>302 Found 临时重定向</li>
<li>404 Not Found 请求失败，所请求的资源未在服务器上找到</li>
</ul>
</li>
</ul>
</li>
<li>HTTP 常见状态码</li>
</ul>
<ol>
<li>1xx 状态码 信息，服务器收到请求，需要请求者继续执行操作。100 Continue 继续、101 Switching Protocols 切换协议，只能切换到更高级的协议</li>
<li>2xx 状态码 操作成功。200 OK 请求成功、204 No Content 请求成功，但是响应报文的 body 部分没有数据</li>
<li>3xx 状态码 重定向。301 Moved Permanently 永久重定向、302 Found 临时移动、304 Not Modify 资源未修改，重定向至缓存文件。</li>
<li>4xx 状态码 客户端错误。400 Bad Request 客户端请求语法错误、401 Unanuthorized 请求用户的身份认证、403 Forbidden 服务器拒绝执行、404 Not Found 服务器未找到客户端请求的资源</li>
<li>5xx 状态码 服务端错误。500 Internal Server Error 服务器内部错误、501 Not Implemented 服务器不支持请求的功能、502 Bad GateWay 网关或代理服务器执行请求时，从远程服务器接收到了一个无效响应。</li>
</ol>
<ul>
<li>
<p>HTTP 重定向<br />
URL 重定向，也称 URL 转发，是一种当前实际资源，如页面，表单等迁移到新的 URL 下的时候，保持原有链接可用的技术。HTTP 使用 HTTP 重定向来执行此类操作。可以用于网站维护期间的临时跳转或者网站架构改变后为保持外部链接继续可用的永久重定向。<br />
重定向操作由服务器发送特殊的响应而触发，状态码是 3xx。浏览器接受到重定向响应后，会采用响应提供的新的 URL，并立即加载。<br />
永久重定向：表示原 URL 不再使用，应优先选用新的 URL。<br />
临时重定向：资源无法从其标准的地址访问，却可以从另外的地方访问。搜索引擎不会记录这个新的、临时的链接。临时重定向也可以用来显示临时性质的进度页面。<br />
特殊重定向：304 Not Modified 资源未修改，会使页面跳转到本地缓存的版本中。300 Multiple Choice 是一种手工重定向，以 Web 页面的形式呈现消息主题包含的一个可能的重定向链接列表，用户可以从中选择。</p>
</li>
<li>
<p>HTTPS</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ibwNtDc2zd2tdhMN7iROJw">GoLang：你真的了解 HTTPS 吗？</a></li>
<li>运行在 SSL （Secure Sockets Layer 安全套接层 位于传输层和应用层之间）上，添加了加密和认证机制，更加安全。</li>
<li>HTTPS = HTTP over SSL/TLS，也就是说，HTTPS 在传输层 TCP 和应用层 HTTP 之间多了一层 SSL/TLS。SSL/TLS 协议作用在传输层和应用层之间，对应用数据进行加密传输。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc494izextj30u00fymyi.jpg" alt="STL+TSL.jpg" /></p>
<p>SSL，全称 Secure Socket Layer，在 1994 年由网景公司最早提出。TLS，全称 Transport Layer Security，在 1999 年基于 SSL3.0 版本上改进而来的。官方建议启用 SSL 而保留和采用 TLS。</p>
<ul>
<li>HTTPS 三大优势：数据加密，防窃听；身份验证，防冒充；完整性校验，防篡改。</li>
<li>通信需要证书，一般是向证书颁发机构购买。证书就是一个公钥和一个私钥。</li>
<li>首先建立 TCP 连接。然后客户端向服务器发送客户端支持的一套加密规则</li>
<li>服务器从中选取出一组加密算法与 Hash 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里包含了网站地址，加密公钥，和证书的颁发机构等信息。</li>
<li>客户端验证服务器的合法性</li>
<li>如果证书受信任，或者客户端接受了不受信任的证书，浏览器会生成一个随机密钥，并用服务器提供的公钥加密。使用 Hash 算法对握手消息进行摘要计算，并对摘要使用之前产生的随机密钥加密。然后，将加密后的随机密钥和摘要发给服务器。</li>
<li>服务器用自己的私钥解开被加密的随机密钥，并用随机密钥解出被加密的 Hash 摘要，验证握手信息是否一致。如果一致，则服务器使用获得的随机密钥加密握手消息发给客户端。</li>
<li>客户端解密并验证摘要，若一致，则握手结束，以后发送的数据都使用该随机密钥进行对称加密。</li>
<li>证书公钥用于加密在握手过程中生成的随机密钥，随机密钥用于加密真正传输的数据，Hash 算法用于验证数据的完整性。</li>
<li>对称加密，加密和解密使用同一个的密钥。</li>
<li>非对称加密，需要两个密钥，公钥和私钥。使用公钥加密的内容用私钥才能解开。</li>
</ul>
</li>
<li>
<p>SSL/TLS 连接建立过程</p>
<ol>
<li>ClientHello</li>
<li>SeverHello</li>
<li>客户端回应</li>
<li>服务器最后回应</li>
</ol>
</li>
<li>
<p>HTTPS 为什么同时需要有对称加密和非对称加密两种加密方式？<br />
对称加密的加密和解密使用的是同样的密钥，所以速度快，但密钥需要在网络中传播，所以安全性不高。<br />
非对称加密使用了一对密钥，公钥和私钥，安全性高，但是加密与解密速度慢。<br />
两者结合起来，可以结合双方的优点，摒弃双方的缺点。即，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双发可以使用对称加密来进行沟通。<br />
HTTPS 最开始就是这样做的。HTTPS 既有非对称加密也有对称加密。对称加密的性能高速度快，因此在数据传输时使用对称加密。对称加密使用的密钥 SK 是在对话前通过网络协商生成的。为了确保 SK 的安全，使用非对称加密来协商 SK。</p>
</li>
<li>
<p>HTTPS 对称加密的密钥 SK 如何产生？<br />
HTTPS 分为两个阶段：</p>
<ol>
<li>协商对称加密密钥 SK 的非对称加密阶段，称为 TLS 握手阶段。</li>
<li>使用 SK 对数据进行对称加密的阶段，称为数据通信阶段。<br />
HTTPS 协商对称加密密钥 SK 的办法有很多种，其中三种最常见的为：</li>
<li>基于非对称加密算法</li>
<li>基于专用密钥交换算法，常见的有 DH，ECDH 等</li>
<li>基于共享的 secret，常见的有 PSK，SRP 等</li>
</ol>
</li>
<li>
<p>非对称加密 RSA 协商密钥的办法，是 HTTPS 最早的办法，其过程如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc5xu6v526j30u00iymyj.jpg" alt="RSA 协商密钥.jpg" /></p>
<ol>
<li>客户端给服务端发送请求</li>
<li>服务端将自己的公钥 PuK 返回给客户端</li>
<li>客户端生成本次对话的对称密钥 SK，并用 PuK 进行加密得到 SK_Enc 后传给服务端</li>
<li>服务端收到 SK_Enc 后用自己的私钥 PrK 解密得到 SK；若成功，则返回客户端 OK，否则终止对话。</li>
<li>接下来，客户端和服务端的对话均用 SK 加密后传输。<br />
这种方法存在中间人攻击的问题，同时，服务端的私钥 PrK 泄露后，HTTPS 的加密也就不安全了。</li>
</ol>
</li>
<li>
<p>密钥交换算法。DH 和 ECDH 协商密钥算法的大致过程如下：</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc5y87dgrrj30u00rzgo7.jpg" alt="DH ECDH 密钥协商.jpg" /></p>
<p>ECDH 算法中的 A 和 B，也别称为 PreMaster-Secret。最终协商得到的密钥 SK 被称为 Master Secret，也被称为 Session Key。<br />
ECDH 比 DH 算法更快，并且 ECDH 比 DH 更难破解，可行性更好。</p>
<ul>
<li>
<p>基于共享的 secret<br />
这列做法就是在客户端和服务端预设好对称加密的密钥，握手阶段只需要传递类似钥匙 id 即可。代表算法有 PSK。</p>
</li>
<li>
<p>HTTPS 有几套非对称加密？目的是什么？是否可以省略？<br />
有两套非对称加密。<br />
一套用于协商对称加密密钥，一套用于数字证书签名加密。<br />
前者是服务器端产生的，私钥在服务器上。后者是 CA 机构产生的，私钥在 CA 机构那里。<br />
两套都不应当省略。</p>
</li>
<li>
<p>HTTPS 的证书</p>
</li>
</ul>
<p>CA、CA 机构：Certificate Authority 机构/组织概念<br />
数字证书、（CA）证书、HTTPS 证书、SSL/TLS 证书：CA 签发的数字证书。<br />
数字签名、证书指纹：CA 签发的证书的内容之一，一段加密的密文。<br />
数字证书用于主体身份验证。<br />
数字证书 = 主体信息 + 数字签名<br />
一张完整的数字证书包括：<br />
1. 主体的必要信息：版本、序列号、签名算法、颁发者、有效期、使用者、公钥信息<br />
2. 主体的扩展信息：密钥标识符、证书策略<br />
如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc639pr8n0j30ku0ofdi6.jpg" alt="数字证书.jpg" /></p>
   <center>数字证书</center>
<p>数字证书用于防范中间人攻击。</p>
<ul>
<li>HTTPS 中间人攻击及防范</li>
</ul>
<p>中间人攻击 MITM（Man-in-the-middle attack）</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc63hpi46qj30u00m1ab3.jpg" alt="中间人攻击.jpg" /></p>
   <center>中间人攻击</center>
<p>中间人攻击是指攻击者与通讯的两端分别建立独立的连接，并交换其收到的数据，使通讯的两端认为他们正在通过一个私密的连接接与对方通讯，但事实上整个会话都被攻击者 控制。攻击者可以截通讯双方的通话并插入新的内容。</p>
<p>客户端请求与服务器发起 HTTPS 通信，信息被中间人获取。服务器把自己的公钥发给客户端，信息被中间人获取，中间人将公钥改为自己的公钥，再发给客户端。客户端收到 公钥，生成随机密钥并用公钥加密随机密钥，然后发给服务器。信息被中间人获取，中间人自己的私钥解密获得随机密钥。现在中间人有服务器的公钥和客端产生的随机密钥。 中间人将随机密钥用服务器的公钥加密，再给服务器。服务器用自己的私钥解密，获得随机密钥。以后客户与服务器的通信都通过随机密钥加密，而中间人有随机密钥，所以中 间人可以获得所有的通信信息。</p>
<p>防范中间人攻击，就是要保证通信中的信息来自正确的发送者且没被修改过。保证客户端收到的信息来自服务器，保证服务器到的信息来自客户端，保证中间没有一个家伙能查 看并修改信息。</p>
<p>可以通过数字签名来保证某段信息确实来自它所声称的那个体。比如，服务器在产生要发送的消息后，通过 Hash 算法计摘要，然后用自己的私钥加密摘要，生成数字签名。消 息接受者到信息和数字签名后，使用同样的 Hash 算法计算信息摘要，用公钥解密数字签名获得服务器端发来的摘要。比对两个摘要查是否一致。如果一致，可以保证信息来自 对方且没被修改过。但这种方式依旧可以被中间人攻击，中间人可以在会话建立阶段将方交换公钥换为自己的公钥，获取双方计算信息摘要的 Hash 法。这样中间人依旧可以修 改信息而不被发现。</p>
<p>为了解决这个问题，通信双方需要找一个双方都信任的第三方为双方确认身份。就是向数字证书机构购买数字证书。</p>
<ul>
<li>数字证书如何工作？</li>
</ul>
<p>这需要从两个角度来说明：<br />
申请证书，即需要被验证身份的一端，需要申请一份能够验证自己身份的证书<br />
验证证书，即需要验证对方身份的一端，拿到证书后验证对端的身份。<br />
这张证书必须是由权威 CA 机构颁发的，且尚在有效期内，或者是一张受信任的私人证书。</p>
<p>申请证书<br />
申请证书的过程：用户向 CA 机构提交自己的信息（如域名）和公钥（用户自己生成的非对称加密公钥，用于 TLS 握手阶段和另一端协商密钥），CA 机构生成数字证书，如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc646iatulj30u00gtwfz.jpg" alt="申请证书.jpg" /></p>
   <center>申请证书</center>
<p>验证证书<br />
收到对端发来的证书，执行证书申请的“逆过程”即可，如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc648lr2d9j30u00am75m.jpg" alt="验证证书.jpg" /></p>
   <center>验证证书</center>
<p>接受证书的一端先对除数字签名的其他部分使用证书中指明的哈希算法计算一次哈希值，记作 H1；获取 CA 机构的公钥对数字签名属性做解码，得到了 CA 机构计算出来的哈希值，记作 H2.对比 H1 和 H2 是否严格相等。若是，则代表该证书的信息未被篡改，证书有效；否则，证书无效。</p>
<p>CA 机构的公钥如何获取？<br />
答案是提前内置。<br />
操作系统和浏览器在软件安装阶段会在其特定目录下放置一堆证书。<br />
查看 win10 的内置证书命令：win+R 然后输入 certmgr.msc<br />
这些证书都是权威 CA 机构颁发的根证书（Root Certificate）。<br />
根证书有如下几个特点：</p>
<ul>
<li>没有上层机构再为其本身作数字签名</li>
<li>证书上的公钥即为 CA 机构发布的公钥</li>
<li>权威 CA 机构的自签证书</li>
</ul>
<p>本地内置了这么多根证书，那要怎么知道我这份证书应该要用哪个根证书来验证呢？<br />
通过证书信任链。<br />
证书信任链上有 3 类证书：根证书、中介证书和用户证书。<br />
根证书就是前面提到的，内置在浏览器和操作系统中的证书。用户证书就是对端发过来的证书，是用户向权威 CA 机构绑定了自己身份（主要指域名）和自己公钥的证书。中介证书可以理解为由权威 CA 机构委派的代理机构签发的数字证书。中介证书或说中介机构的存在是为了保证根证书密钥的安全性。<br />
从用户证书寻找根证书的过程，是一个在树形结构中，从叶子节点搜索根节点的过程。</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc785harqgj30u00itn3s.jpg" alt="搜索根证书.png" /></p>
   <center>搜索根证书</center>
<ul>
<li>完整性校验：HTTPS 的哈希<br />
HTTPS 的哈希用在两个地方：</li>
</ul>
<ol>
<li>证书的数字签名<br />
这里使用哈希的主要目的是减少非对称加密算法在文本上的开销。</li>
<li>对称加密的 Message Digest<br />
在数据通信阶段，SSL/TLS 会对原始消息做一次哈希，的到该消息的摘要，称为消息摘要。对端接受到消息后，使用协商出来的对称加密密钥解密数据包，得到原始信息。接着也做一次相同的哈希算法得到摘要，对比发送过来的消息摘要和计算出的消息摘要是否一致，可以判断通信数据是否被篡改。</li>
</ol>
<ul>
<li>HTTPS 的通信流程</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gc79ecgev5j30u00rmwi5.jpg" alt="HTTPS的通信流程.jpg" /></p>
<ul>
<li>如何由 <a target="_blank" rel="noopener" href="http://www.example.com">www.example.com</a> 跳转至 <a target="_blank" rel="noopener" href="https://www.example.com">https://www.example.com</a></li>
</ul>
<p>如果网站启用了 HTTPS，则服务器会将这个请求使用 301 永久重定向或者 302 临时重定向将请求从 HTTP 的 80 端口重定向到 HTTPS 的 443 端口。<br />
此时，如果中间人劫持了使用者的网络请求，那么中间人可以阻止客户端与服务器建立 HTTPS 连接，而一直使用 HTTP 连接，而中间人则和服务器建立正常的 HTTPS 连接，让客户端以为自己在和真正的服务器通信，这种攻击手法称为 SSLTrip。</p>
</li>
<li>
<p>Session 与 Cooike 的区别<br />
Session 是服务器保持状态的方法，Cooike 是客户端保持状态的方法。<br />
Cooike 是本地机器存储的一个小段文本，并随着每一个请求发送至同一个服务器。服务器通过 HTTP 头向客户端发送 Cooike。在客户端，浏览器解析这些 Cooike 并把它们保存为一个本地文件，浏览器会自动的将向同一服务器发送的任何请求上附加这些 Cooike。<br />
Cooike 是用户端的会话状态保存机制。Cooike 的作用是为了解决 HTTP 协议无状态的缺陷。<br />
Cooike 的主要内容包含：名字、值、过期时间、路径和域。路径和域一起组成 Cooike 的作用范围。如果不设置过期时间，则表示 Cooike 的生命周期为浏览器的会话期间，关闭浏览器，Cooike 就消失，这种 Cooike 被称为会话 Cooike，一般存放在内存中。若设置了过期时间，浏览器就会把 Cooike 保存到硬盘上，关闭后再次打开浏览器，这些 Cooike 依旧有效直到超过设定的过期时间。<br />
Session 机制采用的是在服务器端保持状态的解决方案。由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以 Session 机制可能需要借助 Cooike 机制来达到保存状态的目的。<br />
Session 是针对每一个用户的，Session 的值保存在服务器端，使用 SessionID 来区分用户。SessionID 是一个不容易被找到规律的字符串，用来防止仿造。<br />
服务器接受到客户端的请求时，会检查请求中是否包含一个 SessionID，如果包含，则服务器会通过 SessionID 检索 Session，如果检索不到则会新建一个。如果客户端请求中不包含 SessionID，则服务器为次客户端创建一个 Session 并生成一个与该 Session 关联的 SessionID，SessionID 会在本次响应中返回给客户端。<br />
保存这个 SessionID 的方式可以使用 Cooike。当客户端禁止使用 Cooike 时，可以采用 URL 重写的技术，把 SessionID 直接附加在 URL 的路径后，类似于 URL 的参数。还有一种技术称为表单隐藏字段，服务器自动修改表单，增加一个隐藏字段，以便表单在提交时能够把 SessionID 传递给服务器。<br />
Cooike 中只能保存 ASCII 字符串，如果需要存放 Unicode 字符或者二进制数据，则需要先进行编码。因此存储较复杂的状态，使用 Cooike 是比较困难的。<br />
Session 中能存放任何类型的数据，使用起来比较方便。<br />
Cooike 中的信息存放在客户端，因此最好不要存放一些敏感信息，比如帐号密码，因为一些客户端的不良程序可能会窥探甚至修改 Cooike 中的内容。也可以对 Cooike 加密，提交到服务器后再解密。<br />
Session 在服务器端，保存隐私信息很方便。<br />
Cooike 可以设置一个长时间的有效期，来保持状态一直有效，比如保持登陆。<br />
Session 一般依赖一个会话 Cooike，浏览器关闭后，该 Session 就失效了。而且 Session 一般不应维持较长的有效期，因为这样会对服务器带来较大的压力。并且，Session 不适用于访问量超高的网站，因为这种网站使用 Session 保存状态的话，会消耗大量服务器资源。<br />
Cooike 存放在客户端，如果网站的并发量超大，一般都采用 Cooike 保存状态。<br />
Cooike 的有效时间，有效位置容易设置，Session 就不行。<br />
Cooike 支持跨域名访问。Session 不支持跨域名访问。</p>
</li>
<li>
<p>session 的实现<br />
session 由三个组件配合完成，分别为 <code>Manager</code>、<code>Provider</code> 和 <code>Session</code> 这三个类。</p>
</li>
</ul>
<p>下图是一个 HTTP 请求的完整流程</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbq9oo19c7j30u00gwgn8.jpg" alt="http的请求过程.jpg" /></p>
<ol>
<li>Handler 函数用于接收请求，解析 HTTP header  中的 cooike，得到 SessionID，然后把 SessionID 发给 Manager。</li>
<li>Manager 充当一个 Session 管理器的角色，主要用于存储配置信息。比如：session 的存活时间，Cooike 的名字等。Manager 将 SessionID 接着发给 Provider。</li>
<li>Provider 是一个容器，一般是一个散列表，将每个 SessionID 和 Session 的对应关系存储起来。</li>
<li>Session 中存放用户的具体信息，一般是一个散列表。</li>
</ol>
<ul>
<li>
<p>Cross-Origin Resource Sharing（CORS）跨域资源共享<br />
一般是指，一个域下的文档或脚本试图请求另一个域下的资源。</p>
</li>
<li>
<p>从输入 URL 到获得页面的过程</p>
<ul>
<li>浏览器查询 DNS。浏览器自己的 DNS 缓存，本地 Host 文件，操作系统的 DNS 缓存，本地 DNS 服务器，递归查询或迭代查询</li>
<li>浏览器获得 IP 地址后，向服务器建立 TCP 连接。</li>
<li>TCP 连接建立后，浏览器向服务器发送 HTTP 请求。</li>
<li>服务器响应 HTTP 请求。</li>
<li>浏览器不断请求资源，最终渲染出整个页面。</li>
</ul>
</li>
<li>
<p>网络层</p>
</li>
<li>
<p>功能：互联异构网络、路由与转发、拥塞控制</p>
<ul>
<li>异构网络：好多个网络，各个网络由不同厂家生产的计算机组成，使用了不同的协议。</li>
<li>路由与转发：通过路由器实现</li>
<li>拥塞控制：ICMP Internet Control Message Protocol 网络信息控制协议</li>
</ul>
</li>
<li>
<p>路由算法</p>
<ul>
<li>静态：网络管理员手工配置</li>
<li>动态：通过路由器间彼此交换信息来构造路由表，分为距离-向量算法和链路状态算法。
<ul>
<li>距离-向量算法<br />
所有的路由器都定期地将它们自己的整个路由选择表传送给所有与之相连的临近路由器。路由选择表包含每条路径的目的地和路径的代价。</li>
<li>链路状态算法<br />
每个参与该算法的节点都有整个网络的拓扑信息。一个结点检查所有与之直连的链路的状态，并将所得的信息发送给网络上的所有其他节点。其他结点包括和它直连的和不直连的。当一个结点收到其他节点发来的链路状态时，该节点就通过这些信息更新自己维护的整张网络的拓扑图。如果链路状态发生变化，就通过 Dijsktra 算法计算最短路由。只有链路状态发生变化时，结点才会发送此消息。消息传递使用的是洪泛法。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>层次路由<br />
将互联网分为许多较小的自治系统，系统有权决定自己内部使用什么路由协议</p>
<ul>
<li>内部网关协议<br />
自制系统内部使用的协议。比如使用距离向量算法更新路由表的 RIP 协议和使用链路状态算法更新路由表的 OSPF 协议。</li>
<li>外部网关协议<br />
自制系统之间的网关协议。比如 BGP4。</li>
</ul>
</li>
<li>
<p>IPV4</p>
</li>
<li>
<p>首部，固定部分为 20B，还有一部分的变长部分。</p>
</li>
<li>
<p>NAT Network Address Transform 网络地址转换<br />
用于实现专用网络与公共网络之间的地址转换</p>
</li>
<li>
<p>子网划分<br />
使用子网掩码，对物理子网再一次进行划分。IP 地址分为三部分：网络号，子网号，主机号</p>
</li>
<li>
<p>CIDR Classless Inter-Domin Routing 无分类域间路由选择<br />
用于消除传统的 A、B、C类网络划分。IP 地址分为两部分：网络前缀和主机号。需要在 IP 地址后用斜线记录网络前缀占用的比特数。可以合并路由表的表项。</p>
</li>
<li>
<p>路由聚合<br />
将网络前缀相同的连续 IP 地址组成 CIDR 地址块。使得一个地址块可以表示多个地址，减少路由表的表项，从而降低路由器间交换信息的大小</p>
</li>
<li>
<p>ARP address resolution protocol 地址解析协议<br />
对于特定的 IP 地址，查询其对应的物理地址</p>
</li>
<li>
<p>DHCP dynamic host configuration protocol 动态地址配置协议<br />
给网络中的主机动态分配 IP 地址</p>
</li>
<li>
<p>ICMP internet control message protocol 网络控制信息协议<br />
用来给主机和路由器报告差错和异常，用于拥塞控制。</p>
</li>
<li>
<p>IPV6<br />
首部固定 40B，地址长度 16B，用于解决 IPV4 地址耗尽的问题</p>
</li>
<li>
<p>路由协议</p>
<ul>
<li>自制系统内
<ul>
<li>RIP 协议 Routing Information Protocol<br />
基于距离向量算法的路由选择协议。<br />
网络中的每个路由器都要维护从它自身到其他每一个目的网络的距离记录。<br />
距离用跳数表示，路由器与网络直连时跳数为 1。每经过一个路由器，跳数加一。16 跳时，表示网络不可达。<br />
RIP 认为跳数少，则该路径就好。<br />
仅与相邻的路由器交换信息。交换的是整个路由表。每个固定的时间，就交换一次信息。<br />
应用层协议，使用 UDP 传输数据</li>
<li>OSPF 协议 Open Shortest Path First 开放最短路径优先协议<br />
基于链路状态算法的路由选择协议。<br />
使用洪泛法发送信息。<br />
只发送与本路由器直连的链路的状态。<br />
只有链路状态发生变化时，才发送信息。<br />
网络层协议，直接使用 IP 数据报发送信息，此时 IP 数据报首部的协议字段为 89。<br />
每个链路状态都附带一个 32 位的序号，序号越大，状态越新。</li>
</ul>
</li>
<li>自制系统间
<ul>
<li>BGP border gateway protocol 边界网关协议<br />
只力求找到一条能够到达目的网络且比较好的路由，而不是寻找最佳路由。<br />
主要用于处理各 ISP 之间的路由选择。<br />
应用层协议，使用 TCP 传输数据。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IP 组播<br />
一个发送者与多个接受者之间实现一对多的数据传输。使用 UDP 协议传输数据，IP 地址为 D 类地址。</p>
</li>
<li>
<p>计算机网络体系结构</p>
<ul>
<li>原理的体系结构：应用层、传输层、网络层、数据链路层、物理层</li>
<li>IOS 7 层结构：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</li>
<li>TCP\IP 4 层结构：应用层、传输层、网际层、网络接口层</li>
</ul>
</li>
<li>
<p>应用层常见协议</p>
<ul>
<li>FTP 文件传输协议 使用 TCP 21端口为控制端口，20端口是数据连接端口</li>
<li>HTTP 超文本传输协议 80端口</li>
<li>HTTPS 加密的超文本传输协议 443 端口</li>
<li>DNS 地址解析协议 53端口 使用 UDP</li>
<li>STMP 发送邮件协议 客户端向邮件服务器发邮件，邮件服务器向邮件服务器发邮件 25端口 使用 TCP</li>
<li>POP3 接收邮件协议 邮件服务器向客户端发邮件 110端口 使用 TCP</li>
<li>TELNET 远程登录 23端口</li>
</ul>
</li>
</ul>
<h1 id="常见网络攻击"><a class="markdownIt-Anchor" href="#常见网络攻击"></a> 常见网络攻击</h1>
<p><strong>XSS攻击</strong><br />
通过修改网页的 HTML，在浏览器中插入一段恶意的 JavaScript 脚本，从而窃取用户的隐私信息或着仿冒用户进行操作。这就是 XSS 攻击（Cross-Site Scripting，跨站脚本攻击）的原理<br />
XSS 攻击主要有三种类型：反射性 XSS、基于 DOM 的 XSS 和持久型 XSS<br />
<strong>1. 反射型 XSS</strong><br />
黑客诱导用户点击一个链接，该连接会导致用户当前页面的 HTML 中插入一段脚本并执行。使得用户的浏览器被黑客操控，执行黑客的脚本。比如，黑客操控用户浏览器，获取用户浏览器的 Cooike 的隐私信息。具体流程如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gcwofkh5q2j31570migtr.jpg" alt="反射型 XSS.png" /></p>
<p>服务器拼接字符串后返回个客户端，客户端的 HTML 中就被插入了一段恶意脚本。<br />
反射型 XSS 产生在前后端一体的网页中，服务端的逻辑会改变最终的网页代码。</p>
<p><strong>2. 基于 DOM 的 XSS</strong><br />
在前后端分离的网站中，反射型 XSS 一般不会产生作用。但是，网页本身的 JavaScript 仍然是可以改变的，黑客可以利用这一点，在网页中插入自己的脚本。这就是基于 DOM 的 XSS 漏洞。<br />
前后端分离的应用中，前端页面接受到后端发来的数据后，通过修改前端页面的 DOM 来改变页面内容，将后端的信息展示到页面上。<br />
黑客诱导用户点击链接，通过修改 DOM 的方式将恶意脚本插入到前端页面中并执行，从而获取用户的 Cooike 等隐私信息。具体流程如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gcwotef52ij317m0ouq6i.jpg" alt="基于 DOM 的 XSS 攻击.jpg" /></p>
<p><strong>3. 持久性 XSS</strong><br />
这种 XSS 的恶意脚本存储在服务器端。<br />
比如，当用户在搜索一个关键词时，与这个关键词相关的所有搜索结果都会被展示出来。如果这些搜索结果中包含黑客的一些恶意脚本，那这些恶意脚本就会被插入到网页的 HTML 中并执行，从而泄露用户的 Cooike 等隐私信息。<br />
这些恶意的搜索结果会长期的保存在服务器端，因此又被称为存储型 XSS。<br />
在具体的应用中，存储用户的输入并展示它们的地方，都有可能存在持久型 XSS。比如：搜索结果，评论区，博文等。<br />
具体攻击流程如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gcwp1kt5nqj316d0m4n0e.jpg" alt="持久型 XSS 攻击.jpg" /></p>
<p>与前两种 XSS 攻击相比，持久型 XSS 攻击，带来的危害更广。<br />
前两种 XSS 攻击都需要诱导用户点击链接，这对黑客的诱导能力有很大的考验，有经验的用户一般不会随便点击链接。<br />
持久型 XSS 攻击的恶意脚本存储在正常的服务器数据库中，只要用户正常使用业务，就会受到攻击。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/03/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">文件系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-15 06:40:11 / Modified: 06:57:49" itemprop="dateCreated datePublished" datetime="2020-03-15T06:40:11+08:00">2020-03-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h2>
<ul>
<li>文件目录<br />
UNIX 的文件目录由文件名和指向文件对应的 inode 的指针组成。</li>
<li>inode</li>
</ul>
<ol>
<li>存放了文件控制文件所需要的各种基本信息。
<ol>
<li>文件基本信息<br />
文件名、文件物理位置、文件的逻辑结构、文件的物理结构</li>
<li>存取控制信息<br />
文件存取权限</li>
<li>使用信息<br />
文件建立时间、修改时间等</li>
</ol>
</li>
<li>还有文件用到的物理块的地址。</li>
</ol>
<ul>
<li>文件的逻辑结构
<ol>
<li>流式文件。没有结构，将数据按顺序组织成记录并保存，以字节为单位。</li>
<li>有结构文件。顺序文件、索引文件、索引顺序文件、散列文件</li>
</ol>
</li>
<li>文件共享<br />
基于索引节点的硬连接，利用符号链实现的软连接</li>
<li>文件控制访问<br />
为每个文件和目录设置一个访问控制表</li>
<li>文件描述符、文件描述符表、打开文件表、目录项、inode 结点<br />
每个进程在 PCB 中都有一个数组，名叫文件描述符表，文件描述符就是这个数组的下标。文件描述符 0 表示标准输入流文件，文件描述符 1 表示标准输出流文件，文件描述符 2 表示标准错误输出流文件。文件描述符的表项是一个指向系统打开文件表的指针。</li>
<li>系统打开文件表<br />
又叫做系统级的描述符表，表格中的各项条目称为打开文件句柄，是一个 file 对象。一个打开文件句柄存储了与一个打开文件相关的全部信息。如下所示：
<ol>
<li>当前文件偏移量</li>
<li>打开文件时所使用的状态标识</li>
<li>文件访问模式</li>
<li>指向该文件 inode 的指针</li>
<li>文件类型和访问权限</li>
<li>一个指向该文件持有的锁列表的指针</li>
<li>文件的各种属性，包括文件大小以及不同类型操作相关的时间戳</li>
<li>该文件的引用计数，就是指向该表项的文件描述符的个数。关闭一个文件描述符会减少相应的文件的引用计数，当引用计数为零时，内核会删除该文件在系统打开文件表中的表项。</li>
<li>一个指向 file_operations 结构体的指针，结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如：read、write、open 等函数。</li>
<li>一个指向 dentry 结构体的指针。“dentry” 是 directory entry 的缩写。open、stat 等函数的参数是文件路径，这些函数需要通过文件路径找到文件的 inode。为了减少磁盘访问，内核缓存了目录的树状结构，称为 dentry cache。该树状结构的每一个结点就是一个 dentry 结构体。open、stat 等函数可以沿着路径各部分的 dentry 结构体搜索即可。dentry 结构体中有一个指向 inode 结构体的指针。inode 结构体保存着从磁盘上 inode 读出来的信息。如果两个 dentry 结构体指向同一个 inode 结构体，则说明这两个文件是硬连接。<br />
系统只维护一个系统打开文件表，所有进程共享这张表。</li>
</ol>
</li>
<li>虚拟文件系统<br />
Linux 系统中存在很多物理的文件系统，比如 ext2、ext3、ext4 等。每个文件系统都有自己的文件组织方法，操作方法。Linux 系统通过虚拟文件系统使用户能够透明的处理文件，忽视不同物理文件系统之间的差异。<br />
虚拟文件系统中有四个重要对象：超级块（super block)、索引节点（inode）、目录项（dentry）和文件对象（file）</li>
<li>超级块（super block）<br />
一个超级块对应一个真实的物理文件系统，保存文件系统的类型、大小、状态等元信息。不同的物理文件系统对应不同的 super_block，因此对于不同的 super_block 的操作也不同。super_block 结构体中有一个指向 super_operations 结构体的指针，指向某个特定的具体文件系统用于管理这个文件系统中 inode 的操作函数的集合。<br />
内核中的结构处理都是有讲究的，内核单独使用一个简单的结构体将所有 super_block 都连接起来，但这个结构体不是 super_block 本身，因为 super_block 本身太大了，效率不高。<br />
struct file_system_type *s_type 属性：文件系统类型，也就是当前文件系统是属于哪个类型，ext2 还是 ext3。</li>
<li>索引节点 inode<br />
保存的是文件的元数据，就是文件属性的描述。例如：文件大小、设备标识符、用户标识符、文件模式、文件读取或修改的时间戳、指向存储文件数据的磁盘区块的指针。<br />
inode 有两种，一种是虚拟文件系统的 inode，一种是具体文件系统的 inode。前者存在与内存中，后者存在于磁盘中。使用 inode 时，要将磁盘上的 inode 填充到内存中的 inode 中。<br />
每个 inode 结点的大小，一般是 128B 或者 256B。inode 结点的总数在磁盘格式化时就给定。一般每 2KB 的硬盘就设置一个 inode。<br />
inode number 是唯一的，表示不同的文件。文件名是给用户使用的，Linux 的系统文件目录的一个表项就是 “文件名 + inode number”。系统通过文件名，找到文件对应的 inode number，再通过 inode number 找到 inode 信息，最后通过 inode 中的指向磁盘块的指针，找到文件的数据。<br />
创建一个文件时，内核就给该文件分配一个 inode，一个 inode 只对应一个实际文件，一个文件也只有一个 inode。inode 的个数就是系统中文件的最大个数。</li>
<li>目录项（dentry）<br />
目录项是描述文件的逻辑属性，只存在与内存中，没有实际对应的磁盘描述，是存在于内存的目录项缓存，为了提高查找性能而设计的。所有目录项在一起构成一颗庞大的目录树。<br />
一个目录项对应一个 inode 结构，一个 inode 结构可以对应多个 dentry 结构。</li>
<li>文件对象（file）<br />
文件对象描述的是进程已经打开的文件。file 对象组成系统打开文件表。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/03/12/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">图算法专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-12 06:53:26" itemprop="dateCreated datePublished" datetime="2020-03-12T06:53:26+08:00">2020-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-18 12:55:45" itemprop="dateModified" datetime="2020-10-18T12:55:45+08:00">2020-10-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="图的定义与相关术语"><a class="markdownIt-Anchor" href="#图的定义与相关术语"></a> 图的定义与相关术语</h1>
<p>图由顶点和边组成。</p>
<p>图分为有向图和无向图。有时可以将无向图看为双向的有向图。</p>
<p>图可以表示为 G(V,E)，V 是顶点的集合，E 是边的集合。</p>
<h1 id="图的存储"><a class="markdownIt-Anchor" href="#图的存储"></a> 图的存储</h1>
<p>图的存储方式有两种：邻接矩阵和邻接表。</p>
<p><strong>邻接矩阵</strong></p>
<p>设图 G(V,E) 的顶点编号为 0、1、…、N-1，则可以令二维数组 G[N][N] 的两维分别表示图的顶点编号。G[i][j] 表示点 i 到点 j 的边的权重。可以令权重等于一个非法值来表示两点之间不联通。</p>
<p><strong>邻接表</strong></p>
<p>设图 G(V,E) 的顶点编号为 0、1、…、N-1，每个顶点都可能有若干条出边，如果把同一个顶点的所有出边放在一个列表中，那么 N 个顶点就会有 N 个列表（没有出边，则对应空表），这 N 个列表被称为图 G 的邻接表，记为 Adj[N]，其中 Adj[i] 存放顶点 i 的所有出边组成的列表，这样 Adj[0]，Adj[1]，…，Adj[N-1] 就分别都是一个列表。直观上，邻接表可以使用链表实现。但是，使用 vector 实现会更加方便。</p>
<p>对于有 N 个顶点的图，可以申请一个二维 vector 数组 Adj[N]，其中 N 为顶点个数，每个 Adj[i] 都是一个变长数组 vector，存放点 i 的出边。</p>
<p>如果邻接表中只存放顶点之间的连接情况，不存放边权，则可以直接声明为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[N];</span><br></pre></td></tr></table></figure>
<p>如果邻接表中需要存放边权，可以先声明一个结构体 Node，用于存放出边的终点编号和边权</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> v; <span class="comment">// 出边终点编号</span></span><br><span class="line">  <span class="keyword">int</span> w; <span class="comment">// 出边的边权</span></span><br><span class="line">  Node () &#123;&#125;</span><br><span class="line">  Node (<span class="keyword">int</span> _v,<span class="keyword">int</span> _w): v(_v),w(_w) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>邻接表如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[N];</span><br></pre></td></tr></table></figure>
<h1 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历</h1>
<p>遍历整个图，就相当于对图中所有的连通块进行遍历。</p>
<p><strong>DFS</strong></p>
<p>DFS 遍历图的基本思想是，将已经访问过的点设为已访问，下次递归到时不再处理，直到整个图的顶点都标记为以访问。</p>
<p>一次 DFS 遍历可以遍历完一个连通块。</p>
<p>如果已知图是一个连通图，则只需要一次 DFS 就可以遍历所有顶点。如果图是不连通的，包含多个连通块，则需要多次 DFS 遍历。DFS 的伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DFS(u)&#123; <span class="comment">// 访问顶点 u 所在的连通块</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(从 u 出发能到达的所有顶点 v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DFSTrave(G)&#123; <span class="comment">// 遍历图 G</span></span><br><span class="line">    <span class="keyword">for</span>(G 的所有顶点 u)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是邻接表和邻接矩阵的 DFS 遍历框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V=<span class="number">1000</span>; <span class="comment">// 定义最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7fffffff</span>; <span class="comment">// 定义一个超大数，在邻接矩阵中表示两点之间不连通</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[MAX_V]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 访问数组，初始化为全 false</span></span><br><span class="line"><span class="comment">/*--------------------邻接矩阵的 DFS 遍历--------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// u 为当前访问顶点，depth 为 DFS 树的深度，n 为节点个数</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为以访问</span></span><br><span class="line">    <span class="comment">// 这里可以对 u 进行一些操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G[u][i]!=INF&amp;&amp;vis[i]==<span class="literal">false</span>)&#123; <span class="comment">// 如果 i 未被访问且 i 可达</span></span><br><span class="line">            DFS(i,depth+<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 遍历图 G，n 为顶点个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(i,<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------邻接表的 DFS 遍历----------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// u 为当前访问顶点，depth 为 DFS 树的深度，n 为节点个数</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 这里可以对 u 进行一些操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].size();i++)&#123; <span class="comment">// 遍历从 u 出发可以到达的所有顶点</span></span><br><span class="line">        <span class="keyword">int</span> v=adj[u][i]; <span class="comment">// 下一个要访问的顶点</span></span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(v,depth+<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 遍历图，n 为顶点个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(i,<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BFS</strong></p>
<p>BFS 以广度为关键词，以扩散的方式向外访问顶点。</p>
<p>BFS 需要使用一个队列，通过反复取出队首，将该顶点可达到的的未曾加入过队列的顶点全部入队，直到队列为空时遍历结束。</p>
<p>一次 BFS 遍历可以遍历一个连通块。</p>
<p>如果图中有多个连通块，则需要多次 BFS 遍历。BFS 的伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BFS(u)&#123; <span class="comment">// 遍历 u 所在的连通块</span></span><br><span class="line">    <span class="built_in">queue</span> q; <span class="comment">// 定义队列 q</span></span><br><span class="line">    将 u 入队;</span><br><span class="line">    inq[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为已进入过队列</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        取出队首元素 s 进行访问;</span><br><span class="line">        <span class="keyword">for</span>(从 s 出发可到达的所有顶点 v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inq[v] == <span class="literal">false</span>)&#123;</span><br><span class="line">                将 v 入队;</span><br><span class="line">                inq[v]=<span class="literal">true</span>; <span class="comment">// 标记 v 为已入过队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFSTrave(G)&#123; <span class="comment">// 遍历图 G</span></span><br><span class="line">	<span class="keyword">for</span>(G 中的所有顶点 u)&#123; <span class="comment">// 枚举 G 中的所有顶点 </span></span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)&#123; <span class="comment">// 如果顶点没有入过队</span></span><br><span class="line">            BFS(u); <span class="comment">// 遍历 u 所在的连通块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面分别是邻接矩阵和邻接表的 BFS 遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V =<span class="number">10000</span>; <span class="comment">// 定义最大顶点个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7fffffff</span>; <span class="comment">// 定义一个超大数，表示不可达</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[MAX_V]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> inq[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 入队标记数组</span></span><br><span class="line"><span class="comment">/*----------邻接矩阵 BFS----------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 当前访问顶点 u 和图中顶点总数 n</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 在这里可以对队首顶点进行操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inq[i]==<span class="literal">false</span>&amp;&amp;G[u][i]!=INF)&#123;</span><br><span class="line">                inq[i]=<span class="literal">true</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 图中节点总数 n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(i,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------邻接表 BFS---------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="comment">// 当前访问顶点 u</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 这里可以对队首顶点进行操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[temp].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=adj[temp][i];</span><br><span class="line">            <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>
<p>DFS 和 BFS 两种遍历方式都是一次遍历一个连通块，都使用了一个标记数组以防重复遍历同一个顶点。</p>
</li>
<li>
<p>DFS 每次遍历到最后一个顶点时会形成一个遍历路径，与标记数组结合，可以找出图中的环。</p>
</li>
<li>
<p>如果能够确定图是一棵树，则 DFS 和 BFS 都能保证每个顶点遍历且仅遍历一次，可以不用标记数组。</p>
</li>
<li>
<p>DFS 是以深度作为关键词，通过递归实现。</p>
</li>
<li>
<p>BFS 是以广度作为关键词，通过迭代和一个队列实现。</p>
</li>
</ul>
<h1 id="最短路径"><a class="markdownIt-Anchor" href="#最短路径"></a> 最短路径</h1>
<p>给定图 G(V,E)，求一条从起点到终点的路径，使得这条路径上经过的边的边权之和最小。</p>
<h2 id="单源最短路径"><a class="markdownIt-Anchor" href="#单源最短路径"></a> 单源最短路径</h2>
<p>给定图 G(V,E) 和起点 s，通过算法得到 s 到达其他每个顶点的最短距离。</p>
<h3 id="dijkstra-算法"><a class="markdownIt-Anchor" href="#dijkstra-算法"></a> <strong>Dijkstra 算法</strong></h3>
<p>Dijkstra 的基本思想是对图 G(V,E) 设置集合 S，存放已经被访问的顶点，然后每次从集合 V-S 中选择与起点 s 的最短距离最小的一个顶点，记为 u，访问 u 并加入集合 S 中。之后，令顶点 u 为中介点，优化起点 s 与所有能从 u 到达的顶点 v 之间的最短距离，这样的操作执行 n 次，n 为顶点个数，直到集合 S 包含所有顶点。</p>
<p>Dijkstra 算法只能处理边权都是非负数的图。如果边权出现负数，Dijkstra 算法就会出现错误。</p>
<p><strong>编码要点</strong></p>
<ol>
<li>
<p>集合 S 可以使用一个 bool 型数组 vis[] 来实现。</p>
<p>当 vis[i]=true 时，表示顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 已经被访问；vis[i]=false 时，表示顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 没有被访问</p>
</li>
<li>
<p>使用一个 int 型数组 d[] 表示起点 s 到达顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的最短距离。</p>
<p>初始时，起点 s 的 d[s] 赋为 0，表示从起点到起点的距离为 0，其余 d[i] 都赋为一个很大的数，表示其他顶点都是不可达的。</p>
</li>
</ol>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图 G 设为全局对象，减少传递参数带来的消耗；数组 d[] 为起点到达其他个点的最短路径的长度；s 为起点</span></span><br><span class="line">Dijkstra(G,<span class="keyword">int</span> d[],<span class="keyword">int</span> s)&#123;</span><br><span class="line">    初始化，d[s]=<span class="number">0</span>，其余 d[i]=<span class="number">0x3fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(循环 n 次，n 为顶点个数)&#123;</span><br><span class="line">        u=使 d[u] 最小，且还未访问的顶点的编号;</span><br><span class="line">        标记 u 已经被访问了;</span><br><span class="line">        <span class="keyword">for</span>(从 u 出发能到达的所有顶点 v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v 未被访问且以 u 为中介点使 s 到达 v 的距离更优)&#123;</span><br><span class="line">                优化 d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dijkstra 是一个迭代算法，最外层的 for 循环共循环 n 次，n 为顶点个数。</p>
<p>寻找最小且未被访问的 d[i] 可以通过最小堆来实现，将查找过程的时间复杂度优化为 O(1)，向最小堆中插入数据的时间复杂度为 O(logn)。因此，使用最小堆可以将查找操作的整体时间复杂度优化为 O(logn)。​ C++ 中的最小堆可以使用优先队列代替。</p>
<p><strong>邻接矩阵和邻接表的 Dijkstra 实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V=<span class="number">10000</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大数</span></span><br><span class="line"><span class="keyword">int</span> d[MAX_V]; <span class="comment">// 记录起点到达其他顶点的最短距离的数组</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 标记数组</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="comment">/*--------------------邻接矩阵的 Dijkstra 未优化----------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为顶点个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 填充数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 从起点到达起点的距离为 0</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 填充标记数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 循环 n 次</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF; <span class="comment">// u 使 d[u] 最小，MIN 存放最小的 d[u]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 寻找未访问的顶点中 d[] 最小者</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;</span><br><span class="line">                MIN=d[j];</span><br><span class="line">                u=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到小于 INF 的 d[u]，说明剩余顶点和起点不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 遍历从 u 出发可到达的所有顶点</span></span><br><span class="line">            <span class="comment">// 如果顶点未访问 &amp;&amp; 顶点可达 &amp;&amp; 以 u 为中介点可以使 d[j] 更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;G[u][j]!=INF&amp;&amp;d[u]+G[u][j]&lt;d[j])&#123;</span><br><span class="line">                d[j]=d[u]+G[u][j]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------邻接表的 Dijkstra 未优化-----------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 为边的目标顶点，dis 为边权</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; adj[MAX_V]; <span class="comment">// 邻接表，邻接表中要存储边权</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 是起点，n 是顶点个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 填充距离数组 d</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 起点到起点的距离为 0</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 填充标记数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// n 次循环</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 寻找未访问顶点中 d[] 最小的</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                MIN=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找不到小于 INF 的 d[u]，说明剩余顶点与起点不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为以访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;adj[u].size();j++)&#123;</span><br><span class="line">            <span class="comment">// 如果 j 未访问 &amp;&amp; 以 u 为中介点可以使 d[j] 更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;adj[u][j].dis+d[u]&lt;d[j])&#123;</span><br><span class="line">                d[j]=adj[u][j].dis+d[u]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未优化的 Djikstra 的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。其中，最外层的 for 循环需要循环 V 次，寻找 u 则还需要循环 V 次。</p>
<p><strong>使用最小堆优化的 Dijkstra</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V=<span class="number">10000</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大数</span></span><br><span class="line"><span class="keyword">int</span> d[MAX_V]; <span class="comment">// 记录起点到达其他顶点的最短距离的数组</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 标记数组</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 是目标顶点，dis 是边权</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node a1,Node a2)&#123; <span class="comment">// 重载小于号，利用优先队列实现最小堆</span></span><br><span class="line">        <span class="keyword">return</span> a1.dis&gt;a2.dis;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(<span class="keyword">int</span> _v,<span class="keyword">int</span> _dis):v(_v),dis(_dis) &#123;&#125;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; adj[MAX_V]; <span class="comment">// 邻接表，需要存储边权</span></span><br><span class="line"><span class="comment">/*------------邻接矩阵 Dijkstra 堆优化----------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为顶点个数</span></span><br><span class="line">    fill(d,d+n,INF);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node&gt; minHeap; <span class="comment">// 最小堆，堆中记录 u 和 d[u]</span></span><br><span class="line">    minHeap.push(Node(s,d[s])); <span class="comment">// 将起点放入最小堆中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">while</span>(!minHeap.empty())&#123; </span><br><span class="line">            Node temp=minHeap.top(); <span class="comment">// 堆顶是 d[] 最小的</span></span><br><span class="line">            minHead.pop(); <span class="comment">// 将堆顶出堆。因为堆顶要么这次被访问，要么已经被访问过，所以没用了。</span></span><br><span class="line">            <span class="keyword">if</span>(vis[temp.v]==<span class="literal">false</span>)&#123; <span class="comment">// 如果当前顶点没有被访问</span></span><br><span class="line">                u=temp.v;  </span><br><span class="line">            	MIN=temp.dis;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找不到小于 INF 的 d[u]，表示剩余顶点与起点不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 如果 j 未访问 &amp;&amp; j 可达 &amp;&amp; 以 u 为中介点可以使 d[j] 更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;G[u][j]!=INF&amp;&amp;d[u]+G[u][j]&lt;d[j])&#123;</span><br><span class="line">                d[j]=d[u]+G[u][j]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">                <span class="comment">// 将优化过的 d[j] 放入最小堆，这里可能导致 d[j] 多次入队</span></span><br><span class="line">                <span class="comment">// 如果 d[j] 之前已经入过队且还没有出队，则 d[j] 会再次入队</span></span><br><span class="line">                minHeap.push(Node(j,d[j])); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------邻接表 Dijkstra 堆优化--------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    fill(d,d+n,INF);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node&gt; minHeap;</span><br><span class="line">    minHeap.push(Node(s,d[s]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">while</span>(!minHeap.empty())&#123;</span><br><span class="line">            Node temp=minHeap.top();</span><br><span class="line">            minHeap.pop();</span><br><span class="line">            <span class="keyword">if</span>(vis[temp.v]==<span class="literal">false</span>)&#123;</span><br><span class="line">                u=temp.v;</span><br><span class="line">                MIN=temp.dis;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;adj[u].size();j++)&#123;</span><br><span class="line">            <span class="comment">// 如果 j 未被访问 &amp;&amp; 以 u 为中介点 d[j] 可以优化</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[u]+adj[u][j].dis&lt;d[j])&#123;</span><br><span class="line">                d[j]=d[u]+adj[u][j]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">                minHeap.push(Node(j,d[j])); <span class="comment">// 将优化过的 d[j] 放入最小堆中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用最小堆优化过的 Dijkstra 算法的时间复杂度降为 O(VlogV)。因为选择 u 的时间复杂度将为 O(logV) 了。</p>
<p><strong>记录每一条最短路径</strong></p>
<p>数组 d 的更新条件 “以 u 为中介点可以使起点 s 到顶点 v 的最短距离 d[v] 更优” 意味着，使 d[v] 变得更小的方案是让 u 作为 s 到 v 最短路径上 v 的前一个节点，即 s → … → u → v。记录最短路径就是将这个信息记录下来。</p>
<p>设数组 pre[]，令 pre[v] 表示从起点 s 到顶点 v 的最短路径上 v 的前一个顶点（即前驱结点）的编号。在优化 d[v] 时，可以将 u 赋给 pre[v]。最终，最短路径上每一个节点的前驱节点都可以被记录下来。</p>
<p>一般，从起点 s 到顶点 v 的最短路径不止有一条，可以将 pre 数组声明为 <code>vector&lt;int&gt; pre[MAX_V]</code>。这样对每个顶点 v 来说，pre[v] 就是一个变长数组 vector，里面存放顶点 v 的所有能产生最短路径的前驱结点。</p>
<p>二维的 pre 数组不需要被赋初值。</p>
<p>pre 数组的更新过程如下：</p>
<ol>
<li>
<p>d[u]+G[u][v]&lt;d[v]</p>
<p>此时说明以 u 为中介点，可以使 d[v] 更优，此时 v 的前驱节点为 u。</p>
<p>先将 pre[v] 清空，再将 u 加入到 pre[v] 中。</p>
</li>
<li>
<p>d[u]+G[u][v]==d[v]</p>
<p>此时说明以 u 为中介点可以找到一条相同距离的路径，因此直接将 u 添加到 pre[v] 中即可。</p>
</li>
</ol>
<p>pre 数组计算完成后，使用 DFS 从终点开始遍历 pre 数组，遍历的过程会形成一棵递归树。路径的起点是树的叶子节点。</p>
<p>记录 DFS 遍历过程中的路径，就可以得到最短路径。DFS 递归到起点时终止递归。由于递归的原因，记录在 tempPath 中的路径是从终点到起点倒着存储的。</p>
<h3 id="bellman-ford-算法"><a class="markdownIt-Anchor" href="#bellman-ford-算法"></a> <strong>Bellman-Ford 算法</strong></h3>
<p>BF 算法可以处理有负权边的图。</p>
<p><strong>图中的环</strong></p>
<p>环，也就是从某个顶点出发，经过若干个不同的顶点之后可以回到该顶点的情况。</p>
<p>根据环中边的边权之和的正负，环可以分为零环、正环和负环。</p>
<p>零环和正环不会影响最短路径的求解，因为零环和正环不会使最短路径更短。</p>
<p>如果图中有负环，且从起点可以到达，那么就会影响最短路径的求解；如果负环不能从起点到达，则最短路径的求解不会受影响。</p>
<p><strong>基本思想</strong></p>
<p>BF 算法设置一个数组 d，用来存放从起点到达其它各顶点的最短距离。</p>
<p>BF 算法返回一个 bool 值：如果图中存在从起点可达的负环，那么函数返回 false；否则，函数返回 true，此时数组 d 中存放的值就是从起点到达各顶点的最短距离。</p>
<p>BF 算法需要对图中的边进行  V-1 轮操作，每轮都遍历图中的所有边：对每条边 u→v，如果以 u 为中介点可以使 d[v] 更小，即 d[u]+length[u→v]&lt;d[v] 成立时，就用 d[u]+length[u→v] 更新 d[v]。在 V-1 轮操作后，如果图中没有从起点可达的负环，则数组 d 中的所有值都应当已经达到最优。因此，此时在对所有边进行一轮操作，判断是否有某条边依然满足 d[v]&gt;d[u]+length[u→v]，如果有，则说明图中有从起点可达的负环，算法返回 false，表示没有最短路径，路径可以无限缩短；否则，说明数组 d 的所有值已经达到最优，返回 true。</p>
<p>由此可以看出，BF 算法的时间复杂度是 O(VE)，其中 V 是顶点的个数，E 是边的个数。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V<span class="number">-1</span>;i++)&#123; <span class="comment">// 共循环 V-1 次，V 为顶点的个数</span></span><br><span class="line">    <span class="keyword">for</span>(each edge u→v)&#123; <span class="comment">// 每次都遍历所有的边</span></span><br><span class="line">        <span class="keyword">if</span>(d[v]&gt;d[u]+length[u→v])&#123; <span class="comment">// 如果以 u 为中介点，可以使 d[v] 更优</span></span><br><span class="line">            d[v]=d[u]+length[u→v]; <span class="comment">// 松弛 d[v]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(each edge u→v)&#123; <span class="comment">// 最后再遍历一次所有的边</span></span><br><span class="line">    <span class="keyword">if</span>(d[u]+length[u→v]&lt;d[v])&#123; <span class="comment">// 如果依旧可以松弛</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 说明图中有起点可达的负环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 图中没有起点可达的负环，数组 d 的所有值已经更新到最优</span></span><br></pre></td></tr></table></figure>
<p><strong>简单证明 BF 算法</strong></p>
<ol>
<li>如果最短路径存在，则最短路径上顶点的个数不会超过 V 个，因为整个图中顶点个数就只有 V 个。</li>
<li>如果把起点 s 作为一棵树的根节点，把其他节点按照最短路径的节点顺序连接，就会生成一棵最短路径树。最短路径树中节点的个数不会超过 V 个，则最短路径树的高度一定不会超过 V。因为包含 V 个顶点的树的最大高度为 V。</li>
<li>初始状态下 d[s]=0，因此在接下来的步骤中 d[s] 不会改变，即最短路径树的根节点被确定。BF 算法遍历一次所有边后，最短路径树中第二层节点也就被确定下来了。由于最短路径树的高度不超过 V，所以 BF 算法的松弛操作不会超过 V-1 次。</li>
</ol>
<p>由于 BF 算法需要遍历所有边，所以使用邻接矩阵存储表会比较方便。如果使用邻接矩阵，则会使 BF 算法的时间复杂度上升为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>下面是以邻接表存储图的 BF 算法的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 为邻接边的目标顶点，dis 为邻接边的边权</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">10000</span>; <span class="comment">// 图中顶点的最大个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大的数，表示不可达</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">// 邻接矩阵表示的图</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">// 从起点到达其他顶点的最短路径长度数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BF</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为图中顶点的个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 填充距离数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 起点到达自身的距离为 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123; <span class="comment">// 最外层的 n-1 次循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 遍历每一条边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;Adj[j].size();k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> endNode=Adj[j][k].v; <span class="comment">// 目标顶点</span></span><br><span class="line">                <span class="keyword">int</span> interNode=j; <span class="comment">// 中介顶点</span></span><br><span class="line">                <span class="keyword">int</span> len=Adj[j][k].dis; <span class="comment">// 从中介顶点到目标顶点的的边权</span></span><br><span class="line">                <span class="keyword">if</span>(d[endNode]&lt;d[interNode]+len)&#123; <span class="comment">// 如果以 j 为中介点可以松弛</span></span><br><span class="line">                    d[endNode]=d[interNode]+len; <span class="comment">// 松弛</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断负环是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 遍历每一条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[i].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> endNode=Adj[i][j].v;</span><br><span class="line">            <span class="keyword">int</span> interNode=i;</span><br><span class="line">            <span class="keyword">int</span> len=Adj[i][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[endNode]&lt;d[interNode]+len)&#123; <span class="comment">// 如果依旧可以松弛</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 存在从起点可达的负环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 数组 d 已达到最优，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将 BF 算法优化为 SPFA 算法 Shortest Path Faster Algorithm 快速最短路径算法</strong></p>
<p>BF 算法在每一轮遍历时，都要访问图中所有的边，这会导致大量无效访问。<strong>因为，只有在某个顶点 u 的 d[u] 值改变时，从它出发的边的邻接点 v 的 d[v] 值才有可能改变。</strong></p>
<p>因此，可以对 BF 进行如下优化：建立一个<strong>队列</strong>，每次将队首顶点 u 取出，然后对从 u 出发的所有边 u→v 进行松弛操作，如果可以松弛，则更新 d[v]。此时如果 v 不在队列中，就把 v 加入队列。这样操作直到队列为空（说明图中没有从起点可达的负环），或是某个顶点的入队次数超过 V-1 次（说明图中有从起点可达的负环）。</p>
<p>伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">起点 s 入队;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">    取出队首元素 u;</span><br><span class="line">    <span class="keyword">for</span>(u 的所有邻接边 u→v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">            d[v]=d[u]+dis;</span><br><span class="line">            <span class="keyword">if</span>(v当前不在队列中)&#123;</span><br><span class="line">                v入队;</span><br><span class="line">                <span class="keyword">if</span>(v入队的次数大于 n<span class="number">-1</span>)&#123;</span><br><span class="line">                    说明有可达的负环，<span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编码要点</strong></p>
<ol>
<li>使用一个 int 数组 num[] 记录顶点 v 的入队次数 num[v]</li>
<li>使用一个 bool 数组 inq[] 记录顶点 v 是否在队列中</li>
</ol>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>; <span class="comment">// 图中最大节点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大数，表示不可达</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">// 记录起点到其他节点的最短路径的距离数组</span></span><br><span class="line"><span class="keyword">bool</span> inq[maxv]; <span class="comment">// 记录节点是否在队列中</span></span><br><span class="line"><span class="keyword">int</span> num[maxv]; <span class="comment">// 记录节点的入队次数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// 边的终点和边权</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">// 图 G 的邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为图中顶点的个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 初始化 d 数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 起点 s 到自身的距离为 0</span></span><br><span class="line">    fill(inq,inq+n,<span class="literal">false</span>); <span class="comment">// 初始化入队标记数组</span></span><br><span class="line">    fill(num,num+n,<span class="number">0</span>); <span class="comment">// 初始化记录入队次数的数组</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q; <span class="comment">// 队列</span></span><br><span class="line">    Q.push(s); <span class="comment">// 起点入队</span></span><br><span class="line">    num[s]++; <span class="comment">// 入队次数加一</span></span><br><span class="line">    inq[s]=<span class="literal">true</span>; <span class="comment">// 标记为已入队</span></span><br><span class="line">    <span class="comment">// 算法主体</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=Q.front(); <span class="comment">// 获得队头</span></span><br><span class="line">        Q.pop(); <span class="comment">// 队头出队</span></span><br><span class="line">        inq[u]=<span class="literal">false</span>; <span class="comment">// 标记队头出队</span></span><br><span class="line">        <span class="comment">// 遍历 u 的所有邻接顶点 v</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">            <span class="keyword">int</span> len=Adj[u][i].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+len)&#123; <span class="comment">// 松弛操作</span></span><br><span class="line">                d[v]=d[u]+len;</span><br><span class="line">                <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123; <span class="comment">// 如果 v 不在队列中</span></span><br><span class="line">                    Q.push(v); <span class="comment">// v 入队</span></span><br><span class="line">                    inq[v]=<span class="literal">true</span>; <span class="comment">// 将 v 标记为已入队</span></span><br><span class="line">                    num[v]++; <span class="comment">// v 的入队次数加一</span></span><br><span class="line">                    <span class="keyword">if</span>(num[v]&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果入队次数大于 n-1 次，说明有负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 无可达负环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全源最短路径算法"><a class="markdownIt-Anchor" href="#全源最短路径算法"></a> <strong>全源最短路径算法</strong></h2>
<h3 id="floyd-算法"><a class="markdownIt-Anchor" href="#floyd-算法"></a> Floyd 算法</h3>
<p>Floyd 算法用来解决全源最短路径问题。即对给定的图 G(V,E)，求任意两点 u，v 之间的最短路径长度。</p>
<p>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>时间复杂度将图的顶点限制到了 200 以内。</p>
<p><strong>Folyd 算法的基本思想</strong></p>
<p>如果存在顶点 k，使得以 k 作为中介点时，顶点 i 和 顶点 j 的当前最短距离缩短，则使用 k 作为顶点 i 与顶点 j 的中介点。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">枚举顶点 k∈[<span class="number">1</span>,n]</span><br><span class="line">    以顶点 k 为中介点，枚举所有顶点对 i 和 j，i ∈ [<span class="number">1</span>,n]，j ∈ [<span class="number">1</span>,n]</span><br><span class="line">    	如果 dis[i][k]+dis[k][j]&lt;dis[i][j] 成立</span><br><span class="line">    		赋值 dis[i][j]=dis[i][k]+dis[k][j]</span><br></pre></td></tr></table></figure>
<p><strong>编码要点</strong></p>
<ol>
<li>使用三层 for 循环 k→i→j</li>
<li>不能将最外层的 k 循环放到内层，即产生 i→j→k 的三重循环，这样会导致出错。因为，如果较后访问的 dis[u][v] 有了优化之后，前面访问的 dis[i][j] 会因为已经被访问而无法获得进一步的优化。</li>
</ol>
<h1 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h1>
<p>最小生成树是在一个给定的<strong>无向连通图</strong> G(V,E) 中求一棵树 T，使得这棵树拥有图 G 中的所有顶点，且所有边都是来自图 G 中的边，并且满足整棵树的边权和最小。</p>
<p>最小生成树有三个重要性质：</p>
<ol>
<li>最小生成树是树，因此，其边数等于定点数减一，且树内一定不会有环。</li>
<li>对于给定的图 G(V,E)，其最小生成树可以不唯一，但其边权和一定是唯一的。</li>
<li>最小生成树是在无向图上生成的，因此其根节点可以是这棵树上的任意一个节点。</li>
</ol>
<p>求最小生成树一般有两种算法，即 prim 算法和 kruskal 算法。这两个算法都是采用了贪心法的思想，只是贪心的策略不太一样。</p>
<h2 id="prim-算法"><a class="markdownIt-Anchor" href="#prim-算法"></a> Prim 算法</h2>
<p><strong>基本思想</strong></p>
<p>对图 G(V,E) 设置集合 S，存放已经被访问的顶点，然后每次从集合 V-S 中选择与集合 S 的最短距离最小的一个顶点，记为 u，访问并加入到集合 S 中。之后，令顶点 u 为中介点，优化所有从 u 能到达的顶点 v 与集合 S 之间的最短距离。这样的操作重复执行 V 次，直到集合 S 中已包含所有顶点。</p>
<p><strong>编码要点</strong></p>
<ol>
<li>集合 S 的实现。与 Dijkstra 相同，使用一个 bool 型数组 vis[] 标记顶点是否已经被访问过。vis[v]=true 表示顶点 v 已经被访问，vis[v]=false 表示顶点 v 未被访问。以访问的顶点就相当于以加入到 S 中。</li>
<li>顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_i,(0\le i\le n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 与集合 S 的最短距离。使用一个 int 数组 d[] 来存放顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_i,(0\le i\le n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 与集合 S 的最短距离。初始时，令起点 d[s] 等于 0，其余与顶点都赋为一个很大的数 INF，表示不可达。</li>
</ol>
<p><strong>Prim 算法与 Dijkstra 算法的不同之处</strong>在于，数组 d[] 在 Prim 算法中表示顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_i,(0\le i\le n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 与集合 S 的最小距离，在 Dijkstra 算法中表示顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_i,(0\le i\le n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 与起点 s 的最小距离。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Prim(G,d[])&#123; <span class="comment">// G 为图，数组 d 存放顶点与集合 S 的最短距离</span></span><br><span class="line">    初始化;</span><br><span class="line">    <span class="keyword">for</span>(循环 n 次)&#123;</span><br><span class="line">        u = 使 d[u] 最小的还未被访问的顶点的编号;</span><br><span class="line">        标记 u 为以访问;</span><br><span class="line">        <span class="keyword">for</span>(从 u 出发能到达的所有顶点 v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v 未访问 &amp;&amp; 以 u 为中介点使得 v 与集合 S 的最短距离 d[v] 更优)&#123;</span><br><span class="line">                将 length[u→v] 赋值给 d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Prim 算法与 Dijkstra 算法实际上是相同的思路，只是数组 d[] 的含义不同</strong></p>
<p><strong>邻接矩阵与邻接表分别实现 Prim 算法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>; <span class="comment">// 图中最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大值，表示不可达</span></span><br><span class="line"><span class="keyword">int</span> G[maxv][maxv]; <span class="comment">// 邻接矩阵，矩阵中的值表示边权</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 为边的目标顶点，dis 为边权</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">// 存放顶点与集合的最小距离的数组</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxv]; <span class="comment">// 标记顶点是否被访问</span></span><br><span class="line"><span class="comment">/*-----------------------------邻接矩阵版---------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为人为指定的最小生成树的根节点，n 为图中的节点总数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 初始化距离数组</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 初始化标记数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 根节点为集合 S 中的第一个节点，距离集合 S 的距离为 0</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="comment">// 记录最小生成树的边权和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 循环 n 次，每次将一个顶点加入集合 S</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minl=INF; <span class="comment">// u 使 d[u] 最小，minl 存放最小的 d[u]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 顶点 j 未访问 &amp;&amp; d[j] 比 minl 小</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minl)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minl=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 u=-1，表示剩余顶点与集合 S 不连通，该图没有最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 标记 u 为已访问，即将顶点 u 加入集合 S</span></span><br><span class="line">        ans+=d[u]; <span class="comment">// 将与集合 S 距离最小的边加入最小生成树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 顶点 j 未访问 &amp;&amp; 从 u 可以到达顶点 j &amp;&amp; 以 u 为中介点可以使 d[j] 更小</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;G[u][j]!=INF&amp;&amp;d[u]+G[u][j]&lt;d[j])&#123;</span><br><span class="line">                d[j]=G[u][j]; <span class="comment">// 松弛 d[j]，这是与 Dijkstra 不同的地方</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------------邻接表版---------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为人为指定的最小生成树的根节点，n 为图中顶点的个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 初始化距离数组</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 初始化标记数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 根节点为集合 S 中的第一个节点，距离集合 S 的距离为 0</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="comment">// 存放最小生成树的边权和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 循环 n 次</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minl=INF; <span class="comment">// u 使 d[u] 最小，minl 记录最小的 d[u]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 顶点 j 未访问 &amp;&amp; d[j] 小于 minl</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minl)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minl=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// u=-1 说明剩余顶点与集合 S 不连通，图 G 不存在最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为以访问，即加入集合 S</span></span><br><span class="line">        ans+=d[u]; <span class="comment">// 记录最小生成树新加的边的边权</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v; <span class="comment">// 通过邻接表直接获得 u 的可达顶点</span></span><br><span class="line">            <span class="comment">// 顶点 v 不在集合 S 中 &amp;&amp; 以 u 为中介点可以使 d[v] 更小</span></span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;d[u]+Adj[u][j].dis&lt;d[v])&#123;</span><br><span class="line">                d[v]=Adj[u][j].dis; <span class="comment">// 松弛，这是与 Dijkstra 不同的地方</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 Dijkstra 相同，这种写法的 prim 算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。其中外层循环共循环 V 次，内层循环寻找 u 也需要 V 次。同样可以使用堆优化降低 prim 算法的时间复杂度。</p>
<h2 id="kruskal-算法-克鲁斯卡尔算法"><a class="markdownIt-Anchor" href="#kruskal-算法-克鲁斯卡尔算法"></a> kruskal 算法 克鲁斯卡尔算法</h2>
<p>kruskal 同样用于计算最小生成树。与 prim 算法不同的是，kruskal 算法使用的是边贪心的策略。</p>
<p><strong>基本思想</strong></p>
<ol>
<li>在初始状态时隐去图中所有的边，这样图中的每个顶点都自成一个连通块。</li>
<li>对所有的边按边权从小到大进行排序。</li>
<li>按边权从小到大测试所有的边，如果当前测试边所连接的两个个顶点不在同一个连通块中，则把这条测试边加入到最小生成树中；否则将边舍弃。</li>
<li>重复执行步骤 3，直到最小生成树中的边数等于总顶点数减 1 或是测试完所有边时结束步骤 4。</li>
<li>当步骤 4 结束时，如果最小生成树的边数小于总顶点数减一，说明该图不连通。</li>
</ol>
<p>简单来说，kruskal 算法的思想就是：每次选择图中边权最小的边，如果边两端的顶点在不同的连通块中，就把这条边加入最小生成树。</p>
<p><strong>编码细节</strong></p>
<ol>
<li>
<p>由于需要判断边的两个端点是否在同一个连通块中，并且需要寻找边权最小的边。所以需要定义一个结构体，里面存放边的两个端点和边权。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v; <span class="comment">// 边的两个端点编号</span></span><br><span class="line">    <span class="keyword">int</span> cost; <span class="comment">// 边权</span></span><br><span class="line">&#125;E[maxe]; <span class="comment">// 最多有 maxe 条边</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义边的排序函数，使边按照边权从小到大排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost&lt;b.cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>**使用并查集表示连通块。**判断边的两个端点是否在同一个连通块中，就可以转换为判断两个端点是否在同一个集合中。</p>
</li>
<li>
<p><strong>将测试边加入最小生成树，可以转换为将测试边的两个端点所在的集合合并。</strong></p>
</li>
</ol>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans=<span class="number">0</span>; <span class="comment">// 表示最小生成树的边权之和</span></span><br><span class="line">    numEdge=<span class="number">0</span>; <span class="comment">// 表示最小生成树的当前边数</span></span><br><span class="line">    将所有的边按照从小到大排序;</span><br><span class="line">    <span class="keyword">for</span>(按边权从小打大枚举所有边)&#123;</span><br><span class="line">        <span class="keyword">if</span>(当前测试边的两个端点在不同的连通块中)&#123;</span><br><span class="line">            将该测试边加入最小生成树中;</span><br><span class="line">            ans+=测试边的边权;</span><br><span class="line">            numEdge++;</span><br><span class="line">            <span class="keyword">if</span>(当前边数 nunEdge 等于顶点数减 <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>kruskal 算法的代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxn=<span class="number">1000</span>; <span class="comment">// 最大的顶点个数</span></span><br><span class="line"><span class="keyword">const</span> maxe=<span class="number">1000</span>; <span class="comment">// 最大边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v; <span class="comment">// 边的两个端点编号</span></span><br><span class="line">    <span class="keyword">int</span> cost; <span class="comment">// 边权</span></span><br><span class="line">&#125;;</span><br><span class="line">edge E[maxe]; <span class="comment">// 图使用 E 来表示</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span>&#123; <span class="comment">// 边的比较函数，边权小的在前，边权大的在后</span></span><br><span class="line">    <span class="keyword">return</span> a.cost&lt;b.cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> father[N]; <span class="comment">// 并查集数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 并查集查询函数，使用路径压缩</span></span><br><span class="line">    <span class="keyword">int</span> a=x; <span class="comment">// 将 x 记录下来，以便从 x 开始压缩查询路径</span></span><br><span class="line">    <span class="keyword">while</span>(x!=father[x])&#123; <span class="comment">// 找到 x 所在集合的根节点并存储在 x 中</span></span><br><span class="line">        x=father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a!=father[a])&#123; <span class="comment">// 从 a 开始压缩路径</span></span><br><span class="line">        <span class="keyword">int</span> z=a;</span><br><span class="line">        a=father[a];</span><br><span class="line">        father[z]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 返回集合的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// kruskal 算法返回最小生成树的边权之和，参数 n 为顶点个数，m 为图的边数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="comment">// 最小生成树的边权之和</span></span><br><span class="line">    <span class="keyword">int</span> numEdge=<span class="number">0</span>; <span class="comment">// 当前生成树的边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">// 假设图中顶点的编号为 [1,n]</span></span><br><span class="line">        father[i]=i; <span class="comment">// 并查集初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(E,E+m,cmp); <span class="comment">// 所有边按照边权从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123; <span class="comment">// 按边权从小到大的顺讯，枚举所有的边</span></span><br><span class="line">        <span class="keyword">int</span> faU=findFather(E[i].u); <span class="comment">// 顶点 u 所在集合的根节点</span></span><br><span class="line">        <span class="keyword">int</span> faV=findFather(E[i].v); <span class="comment">// 顶点 v 所在集合的根节点</span></span><br><span class="line">        <span class="keyword">if</span>(faU!=faV)&#123; <span class="comment">// 如果两个顶点不在同一个连通块中</span></span><br><span class="line">            father[faU]=faV; <span class="comment">// 集合合并，将测试边加入到最小生成树中</span></span><br><span class="line">            ans+=E[i].cost; <span class="comment">// 边权之和增加测试边的边权</span></span><br><span class="line">            numEdge++; <span class="comment">// 当前生成树的边数加一</span></span><br><span class="line">            <span class="keyword">if</span>(numEdge==n<span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 边数等于顶点数减一时结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numEdge!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 图不是连通图，返回 -1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans; <span class="comment">// 返回最小生成树的边权之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kruskal 算法的时间复杂度主要来自于边的排序，因此，其时间复杂度为 O(ElogE)，E 为图中的边数。</p>
<p>显然 kruskal 算法适用于顶点多，边少的情况。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hespoon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">hespoon</p>
  <div class="site-description" itemprop="description">全心全意的投入生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hespoon" title="GitHub → https://github.com/hespoon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hezaojian@gmail.com" title="E-Mail → mailto:hezaojian@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fas fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hespoon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">142k</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        


  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1279024191&web_id=1279024191"></script>
  </div>






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
