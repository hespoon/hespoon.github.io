<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-hespoon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-hespoon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-hespoon.png">
  <link rel="mask-icon" href="/images/hespoon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hespoon.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":"//cdn.jsdelivr.net/gh/user/repo@version/file","lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="全心全意的投入生活">
<meta property="og:type" content="website">
<meta property="og:title" content="Spirit">
<meta property="og:url" content="http://hespoon.github.io/page/2/index.html">
<meta property="og:site_name" content="Spirit">
<meta property="og:description" content="全心全意的投入生活">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="hespoon">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hespoon.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Spirit</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Spirit</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hespoon" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-01 21:09:19" itemprop="dateCreated datePublished" datetime="2020-03-01T21:09:19+08:00">2020-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-04 23:05:59" itemprop="dateModified" datetime="2020-03-04T23:05:59+08:00">2020-03-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单例模式">单例模式</h1>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/26/C-C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/C-C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">C++/C 基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-26 17:15:23" itemprop="dateCreated datePublished" datetime="2020-02-26T17:15:23+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-28 10:06:01" itemprop="dateModified" datetime="2020-02-28T10:06:01+08:00">2020-02-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="const-关键字">const 关键字</h1>
<ul>
<li><p>const 修饰普通变量 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br></pre></td></tr></table></figure> a 为常量，只能在声明时赋值，不可再次赋值。指向常量的指针和引用，必须被 const 修饰，这样用于防止通过指针或引用修改该常量。</p></li>
<li><p>指向常量的指针 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p = <span class="number">8</span>;</span><br></pre></td></tr></table></figure> const 位于 * 的左边，不能通过指针修改指针指向的值。指向常量的指针，可以指向常量也可以指向普通类型。关键是不能通过指针修改指针指向的值。</p></li>
<li><p>常指针 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = <span class="number">8</span>;</span><br></pre></td></tr></table></figure> const 位于 * 的右边，指针是一个指针常量，指针指向的内存地址不能改变，但可以通过指针修改指针指向的值。</p></li>
<li><p>指向常量的常指针 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p = <span class="number">8</span>;</span><br></pre></td></tr></table></figure> const 在 * 的两边都有，指针指向的内存地址不能改变，地址中的值不能通过指针改变。 常指针和指针常量的合并。</p></li>
<li><p>const 修饰函数参数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传值参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    a++; <span class="comment">// 错误，不能在函数中修改 a 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> *a)</span></span>&#123;</span><br><span class="line">    *a=<span class="number">10</span>; <span class="comment">// 错误，不能通过指针修改 a 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> a)</span></span>&#123;</span><br><span class="line">    *a=<span class="number">10</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">10</span>;</span><br><span class="line">    a=&amp;b; <span class="comment">// 错误，不可以改变指针指向的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当函数参数是一个自定义的对象时，按值传参时会构建临时对象复制参数，一般采用传引用，为了防止参数在函数体内被修改，常用 const 修饰参数。</p></li>
<li><p>const 修饰函数返回值</p></li>
</ul>
<ol type="1">
<li>const 修饰基本数据类型，修饰与不修饰作用相同。</li>
<li>const 修饰自定义类型。此时返回一个常量，返回值不能做左值。返回值既不能被赋值，也不能被修改。</li>
<li>const 修饰返回的指针或引用。</li>
</ol>
<ul>
<li><p>const 修饰类的成员函数 const 加在 () 后面 const 修饰成员函数，是为了防止成员函数修改调用这个函数的对象的值。一个类中，任何不会修改数据成员的函数都应该声明为 const 类型。const 修饰的成员函数称为常成员函数，常成员函数不能调用非常成员函数，用来防止常成员函数修改类的属性。只有常成员函数能够操作常对象，没有 const 修饰的的成员函数不能用来操作常对象。如果对象的某个属性希望被自己的 const 成员函数修改，则可以用 mutable 修饰该属性。</p></li>
<li><p>const 修饰引用 const 引用是指向 const 对象的引用。同时，普通的引用是无法绑定到 const 对象上的。为了防止通过普通的引用修改 const 对象。</p></li>
</ul>
<h1 id="static-关键字">static 关键字</h1>
<ul>
<li><p>静态成员变量 类内成员变量声明前加上关键字 static，该数据成员就是类内的静态数据成员。</p></li>
<li><p>静态成员变量的特点</p></li>
</ul>
<ol type="1">
<li>静态成员变量是该类所有对象共有的。静态成员变量只分配一次内存，由该类的所有对象共享访问。</li>
<li>静态数据成员在全局数据区分配内存，不属于特定的对象，不占用对象的内存。在没有类的实例存在前，静态成员变量就已经存在了。</li>
<li>静态成员变量在初始化时分配内存。静态变量必须初始化，并且只能在类体外进行。初始化时可以赋初值，也可以不赋初值。如果不赋初值，则会被默认初始化。静态数据区的变量都有默认的初始值，动态数据区的变量默认是垃圾值。</li>
<li>static 成员变量与普通 static 变量相同，编译时在静态数据区分配内存，到程序结束时才释放。</li>
<li>静态数据成员初始化时可以不加 static，但必须要有数据类型。</li>
<li>静态数据成员可以通过 <类名>::<静态数据成员名> 访问，不需要通过类的对象。</li>
<li>sizeof 运算不会计算静态成员变量的大小。</li>
</ol>
<ul>
<li><p>静态成员函数 静态成员函数是为某一个类服务的。静态成员函数不作用于某个具体的对象。普通成员函数隐含了一个 this 指针，该 this 指针指向类的对象本身。函数调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this 是缺省的。 静态成员函数属于类本身，不作用与具体的对象，因此它不具有 this 指针。静态成员函数不能访问非静态成员变量和非静态成员函数，只能访问其余的静态成员变量和函数。</p></li>
<li><p>静态成员函数的特点</p></li>
</ul>
<ol type="1">
<li>出现在类体外的函数定义不能指定关键字 static</li>
<li>静态成员函数仅可以访问静态成员变量和静态成员函数</li>
<li>静态成员函数不能访问非静态成员函数和非静态成员变量</li>
<li>非静态成员函数可以任意的访问静态成员函数和静态成员变量</li>
</ol>
<ul>
<li><p>拷贝构造函数的问题 使用包含静态成员的类时，有时会调用拷贝构造函数生成临时的隐藏的类对象，而这个临时类对象消亡时会调用析构函数，析构函数中可能会修改静态成员变量，但是这些临时对象在创建时却没有执行构造函数中的对静态成员变量修改的操作。此时应当在类中写一个拷贝构造函数，让临时对象的创建使用该拷贝构造函数，在拷贝构造函数中规范拷贝对象时的操作。</p></li>
<li><p>静态全局变量 在全局变量之前加上 static 关键字。</p></li>
<li><p>静态全局变量的特点</p></li>
</ul>
<ol type="1">
<li>该变量在全局数据区分配内存</li>
<li>未经初始化的静态全局变量有一个默认的初始化值。与之相比，普通变量的默认初始化值是垃圾值。</li>
<li>静态全局变量在声明它的整个文件内都是可见的，在文件外不可见。</li>
<li>对于一个完整的程序，在内存中的分布情况如下：【代码区】、【全局数据区】、【堆区】和【栈区】。一般由 new 产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据，包括函数内部的静态局部数据，存放在全局变量区。</li>
<li>静态全局变量不能被其他文件使用。在其他文件中，可以定义相同名字的变量，不会产生冲突。</li>
</ol>
<ul>
<li><p>静态局部变量 在局部变量之前加上 static 关键字，该变量就被定义为一个静态局部变量。 函数中的普通局部变量存放在栈中，函数退出时系统会回收栈的内存，局部变量也就失效了。 有时，我们希望在两次调用之间对局部变量的值进行保存，此时就可以使用静态局部变量。 静态局部变量只在第一次函数调用时初始化一次。且存放在全局数据区，每次调用的值保持到下一次调用。 静态局部变量始终驻留在函数的全局数据区中，直到程序运行结束。但其作用域为局部作用域，当定义它的语句块结束时，其作用域随之结束。</p></li>
<li><p>静态函数 在函数的返回类型前加上 static 关键字，函数被定义为静态函数。静态函数只在声明它的文件中可见，不能被其他文件使用。其他文件中可以定义同名函数，不会发生冲突。</p></li>
</ul>
<h1 id="虚函数与纯虚函数">虚函数与纯虚函数</h1>
<ul>
<li><p>虚函数是实现多态的机制。多态性使得程序调用的函数是在运行时动态决定的，而不是编译时静态决定的。其核心理念是通过基类访问派生类实现的函数。使用一个基类类型的指针或引用指向子类对象，进而调用由子类复写的个性化的虚函数。</p></li>
<li><p>虚函数，在类的成员方法的声明前加 virtual 关键字。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>纯虚函数，在虚函数的声明后加 “= 0” <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>虚函数表 每一个包含虚函数的类都包含一个虚函数表 虚表是一个指针数组，指针是指向虚函数的函数指针。 虚表是属于类的，而不是属于某个对象，一个类只需要一个虚表即可。同一个类的所有对象公用一个虚表。 为了指定对象的虚表，对象内部包含一个指向虚表的指针。类对象在创建时便拥有了指向虚表的指针，指针会自动指向对象所属类的虚表。 对象的虚表指针指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数。</p></li>
<li><p>对于虚函数，子类可以重写虚函数，也可以不重写。对于纯虚函数，子类必须重写。</p></li>
<li><p>当使用类指针调用成员函数时，普通函数由指针类型确定，虚函数由指针指向的实际类型确定。</p></li>
<li><p>含有纯虚函数的类称为抽象类，它不能生成对象。</p></li>
<li><p>当基类中的某个成员方法，在大多数情况下都应该由子类提供个性化实现，但基类中也可以提供缺省的备选方案时，该方法设计为虚函数。当基类的某个成员方法，必须由子类提供个性化实现时，应该设计为纯虚函数。</p></li>
<li><p>构造函数不能是虚函数，析构函数可以是虚函数且推荐设置为虚函数。基类的析构函数是虚函数，可以确保，在使用基类指针销毁派生类对象时，派生类的析构函数能够被调用，因为派生类的虚构函数一般会有释放一些派生类对象独有的内存这样的操作。</p></li>
</ul>
<h1 id="函数指针">函数指针</h1>
<p>函数存放在内存的代码区域，同样具有地址。 函数指针指向的函数一定要保持函数的返回值类型，函数参数个数、类型和函数指针一致。 函数指针可以作为参数传递给函数 还可以构成函数指针数组 类成员函数指针和普通函数指针是不同的。 类成员函数指针要通过 <code>.*</code> 或者 <code>-&gt;*</code> 运算符使用。 类成员函数指针指向类中的非静态成员函数时，必须由类的实例对象调用，用于传递给函数 this 指针。 指向类的静态成员函数的函数指针在声明时可以不加类名。调用时可以不使用类的实例对象。 普通成员的函数指针可以通过 <code>*</code> 运算符使用。</p>
<h1 id="内联函数">内联函数</h1>
<p>内联函数是为了解决程序中函数调用的效率问题。如果函数为内联函数，则在程序编译时，编译器会将程序中出现的内联函数表达式用内联函数体进行替换。是一种空间换时间的操作。内联函数一般都比较小。 内联函数中最好不要使用循环语句，内联函数的定义必须出现在内联函数第一次调用之前，类内部定义的函数是内联函数。</p>
<h1 id="函数签名">函数签名</h1>
<p>C++ 的函数签名包含函数名和函数的参数列表，不包含返回类型。函数签名用于识别不同的函数。</p>
<h1 id="构造函数">构造函数</h1>
<p>构造函数不需要用户调用，而是在建立对象时自动执行。函数名称与类名相同，没有返回值。 声明类数组时，数组中的每一个元素都会调用一次构造函数。假设数组长度为 n，则会调用 n 次构造函数。 声明类的指针数组时，不会调用类的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cls</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> executeCount;</span><br><span class="line">	cls() &#123;</span><br><span class="line">		executeCount++;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; executeCount &lt;&lt; <span class="string">&quot;  &quot;</span>; <span class="comment">// 输出当前是第几次调用构造函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> cls::executeCount = <span class="number">0</span>; <span class="comment">// 静态成员变量初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cls a[<span class="number">5</span>]; <span class="comment">// 会调用 5 次默认构造函数</span></span><br><span class="line">    cls * b[<span class="number">8</span>]; <span class="comment">// 不会调用构造函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>无参数的构造函数</li>
<li>带参数的构造函数，属于构造函数的重载。构造函数的参数可以有默认初值。</li>
</ol>
<h1 id="拷贝构造函数">拷贝构造函数</h1>
<p>用于对象复制。函数名与类名一致，参数一般是一个本类型对象的引用。</p>
<ul>
<li>拷贝构造函数调用时机</li>
</ul>
<ol type="1">
<li>对象以传值的方式传入函数参数时。</li>
<li>对象以传值的方式从函数返回时。</li>
<li>使用另一个同类型的对象来初始化新创建的对象时。</li>
</ol>
<ul>
<li>深拷贝与浅拷贝 默认的拷贝构造函数没有处理类的静态数据成员。 浅拷贝是指，在对象复制时，只对对象中的数据成员进行简单的赋值，不会正确处理指针，指针只是简单的指向相同的内存空间。此时，拷贝出来的对象会影响原来的对象。 深拷贝时，对象中的成员变量，不再是简单的赋值，而是重新分配内存空间。</li>
</ul>
<h1 id="指针与引用的区别">指针与引用的区别</h1>
<ul>
<li>指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元。引用跟原来的变量是同一东西，只不过是原变量的一个别名而已。</li>
<li>有 const 指针，没有 const 引用</li>
<li>指针可以有多级，引用只能由一级</li>
<li>指针可以为空，引用不能为空</li>
</ul>
<h1 id="回车与换行">回车与换行 </h1>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th style="text-align: center;">ASCII码</th>
<th style="text-align: center;">意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">换行</td>
</tr>
<tr class="even">
<td style="text-align: center;"> 13</td>
<td style="text-align: center;">回车</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>在 windows 中： <code>\r</code> 回车，表示回到当前行的行首，而不会换到下一行。如果接着输出，本行的内容会被覆盖 <code>\n</code> 换行，换到当前位置的下一行，而不会回到行首。 按下键盘回车键相当于输入 <code>\r\n</code></p>
<p>在 Unix 系统中： <code>\n</code> 会换到下一行的行首。 按下回车键相当于输入 <code>\n</code></p>
<p>在 Mac 中： <code>\r</code> 会换到下一行的行首。 按下回车键相当于输入 <code>\r</code></p>
<p>一般在程序中写 <code>\n</code> 在 Linux中都能实现换到下一行的行首的功能。只是在文本文件中，Linux 只有 <code>\n</code>，Windows 中是 <code>\r\n</code>。</p>
<h1 id="标准输入输出">标准输入输出</h1>
<ul>
<li>scanf 和 printf 头文件： <cstdio> 输入格式：</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/16/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/16/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">《高性能 MySQL》学习笔记 第四章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-16 17:34:36 / Modified: 20:50:17" itemprop="dateCreated datePublished" datetime="2020-02-16T17:34:36+08:00">2020-02-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第四章-schema-与数据类型优化">第四章 Schema 与数据类型优化</h1>
<h2 id="临时表">临时表</h2>
<p>MySQL 临时表用于保存一些临时数据。临时表只在当前连接可见，当关闭连接时，MySQL 会自动删除表并释放所有空间。</p>
<ul>
<li><p>外部临时表</p>
<p>通过 <code>CREATE TEMORPARY TABLE</code> 创建的临时表称为外部临时表。这种临时表的命名可与非临时表相同。同名后，非临时表对当前回话不可见，直到临时表被删除。</p></li>
<li><p>内部临时表</p>
<p>内部临时表是一种特殊的轻量级临时表，由 MySQL 自动创建，用来存储某些操作的中间结果，达到性能优化的目的。该表一般是 Memory 表。如果中间结果太大超出了 Memory 的限制，或者含有 BLOB 或 TEXT 字段，则临时表会转换为 MyISAM 表。</p></li>
</ul>
<h2 id="对象关系映射-object-relation-mapping-简称-omp">对象关系映射 Object Relation Mapping 简称 OMP</h2>
<p>面向对象的开发方法是当今企业级应用开发环境中的主流方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现方式。业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多的关联和继承关系。因此，对象-关系映射系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>
<h2 id="实体-属性-值模型-entity-attribute-value-model-eav">实体-属性-值模型 Entity-attribute-value model EAV</h2>
<blockquote>
<p><a href="%5Bhttps://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model%5D(https://en.wikipedia.org/wiki/Entity–attribute–value_model)">Entity-attribute-value mode-wiki</a></p>
</blockquote>
<p>EAV 模型是一种数据模型。主要用于以较高的空间利用率编码一种特殊实体，该实体在整体上包含很多属性，但是具体到某一个个体时，只有有限个的属性有值，其他的属性都为空。这种实体与数学上的稀疏矩阵很相似。</p>
<p>EAV 表通常是瘦长的。瘦表示表的列很少，长表示表的行很多。</p>
<p>EAV 表通常有三列</p>
<ul>
<li>entity 表示被描述的实体，该列一般是关联到实体定义表的外键。</li>
<li>attribute 该列一般是关联到一个属性定义表的外键。该属性定义表用来定义该属性，表格可能包含如下几种列：属性ID、属性名、属性描述、数据类型和用于辅助输入验证的列，比如，最大字符串长度、正则表达式或这一个包含有效数据的集合。</li>
<li>value 该列存放属性的值</li>
</ul>
<p>使用 EAV 模型的两个例子：医院的病历记录，超市的销售数据。</p>
<p>EAV 使用了行模型。行模型表示一个实体被记录在很多行而不是很多列中，每行通常有三列：entity、attribute 和 value。</p>
<h2 id="范式">范式</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24696366">常见范式设计</a></p>
</blockquote>
<ul>
<li>依赖：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，记作 <span class="math inline">\(X \to Y\)</span>。</li>
<li>完全函数依赖：在一张表中，若 <span class="math inline">\(X \to Y\)</span>，且对于 X 的任何真子集 <span class="math inline">\(X&#39;\)</span>，<span class="math inline">\(X&#39; \to Y\)</span> 不成立，那么我们称 Y 完全依赖于 X，记作 <span class="math inline">\(X\stackrel{F}{\to}Y\)</span>。</li>
<li>部分函数依赖：Y 函数依赖于 X，同时 Y 不完全依赖于 X，则称 Y 部分依赖于 X，记作 <span class="math inline">\(X\stackrel{P}{\to}Y\)</span>。</li>
<li>传递函数依赖：Z 函数依赖于 Y，且 Y 函数依赖于 X，且 Y 不包含于 X，且 X 不函数依赖于 Y，则称 Z 传递依赖于 X，记作 <span class="math inline">\(X\stackrel{T}{\to}Z\)</span>。</li>
<li>码：设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都有完全函数依赖于 K，那么我们称 K 为候选码，简称为码。通常可以这样理解：假如 K 确定的情况下，该表除 K 之外的所有属性的值也就确定，那么 K 就是码。一张表中可以有超过一个码，通常选择其中的一个码作为主码。</li>
<li>主属性：包含在任何一个码中的属性为主属性</li>
<li>判断表格符合那一个范式步骤
<ol type="1">
<li>找出表中的所有码</li>
<li>根据第一步的码，找出所有主属性</li>
<li>除去所有的主属性，剩下的都是非主属性</li>
<li>查看函数依赖</li>
</ol></li>
</ul>
<ol type="1">
<li><p>第一范式</p>
<p>所有属性都是不可分割的原子值。</p>
<p>数据库表的每一列都是不可分割的原子数据项，不能是集合，数组，记录等非原子数据项。</p></li>
<li><p>第二范式</p>
<p>在第一范式的基础上，要求非主属性都要==完全==依赖于码。</p></li>
<li><p>第三范式</p>
<p>任何非主属性不依赖于其他非主键属性。</p>
<p>第三范式是在第二范式的基础上建立起来的，消除了非主属性对于码的传递函数依赖。</p></li>
<li><p>BC 范式</p>
<p>在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。</p></li>
</ol>
<h2 id="选择数据类型的原则">选择数据类型的原则</h2>
<ol type="1">
<li><p>更小的通常更好</p>
<p>更小的数据类型通常占用更少的存储空间，处理时需要的 CPU 周期更少。</p>
<p>同时要确保没有低估需要存储的值的范围。在 schema 中的多个地方增加数据类型是一个代价很高的操作。</p></li>
<li><p>简单就好</p>
<p>简单的数据类型操作通常需要更少的 CPU 周期。</p>
<p>使用 MySQL 内建的数据类型存储日期和时间，而不是使用字符串。</p>
<p>使用整形存储 IP 地址。</p></li>
<li><p>尽量避免 NULL</p>
<p>可为 NULL 是列的默认属性。</p>
<p>通常情况下最好指定 NOT NULL，除非真的需要存储 NULL 值。</p>
<p>包含 NULL 的列，对 MySQL 来说更难优化。</p>
<p>可为 NULL 的列使得索引、索引统计和值比较都更加复杂。</p>
<p>但是，通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小。所以，在调优时，没有必要首先修改这种情况。但是，在设计表格时要尽量避免 NULL。</p></li>
<li><p>第一步，确定适合的大类型：数字、字符串、时间等。然后确定具体类型。MySQL 为了兼容性支持很多基本数据类型的别名，例如 INTEGER、BOOL 以及 NUMERIC。这些别名不会影响性能。</p></li>
</ol>
<h2 id="整数类型">整数类型</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类型</th>
<th style="text-align: center;">位数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">TINYINT</td>
<td style="text-align: center;">8 位</td>
</tr>
<tr class="even">
<td style="text-align: center;">SMALLINT</td>
<td style="text-align: center;">16 位</td>
</tr>
<tr class="odd">
<td style="text-align: center;">MEDIUMINT</td>
<td style="text-align: center;">24 位</td>
</tr>
<tr class="even">
<td style="text-align: center;">INT</td>
<td style="text-align: center;">32 位</td>
</tr>
<tr class="odd">
<td style="text-align: center;">BIGINT</td>
<td style="text-align: center;">64 位</td>
</tr>
</tbody>
</table>
<p>可存储的值的范围：<span class="math inline">\(-2^{(N-1)}\thicksim2^{(N-1)}-1\)</span>，N 为位数。</p>
<p>有可选的 UNSIGNED 属性，表示无符号整数。可存储的值的范围：<span class="math inline">\(0 \thicksim 2^N-1\)</span>，N 为位数。</p>
<p>数据类型决定整数是如何存储的。而整数计算一般使用 64 位的 BIGINT 整数，即使在 32 位环境中也是如此。一些聚合函数是例外，它们使用 DECIMAL 或 DOUBLE 进行计算。</p>
<p>可以为整数类型指定宽度，例如 INT(11)。这对大多数应用没有意义，这不会改变值的合法范围，只是规定了 MySQL 的一些交互工具用来显示字符的个数。对于存储和计算来讲 INT(1) 与 INT(20) 没有区别。</p>
<h2 id="实数类型">实数类型</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类型</th>
<th style="text-align: center;">位数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">FLOAT</td>
<td style="text-align: center;">32 位</td>
</tr>
<tr class="even">
<td style="text-align: center;">DOUBLE</td>
<td style="text-align: center;">64 位</td>
</tr>
<tr class="odd">
<td style="text-align: center;">DECIMAL</td>
<td style="text-align: center;">128 位</td>
</tr>
</tbody>
</table>
<p>DECIMAL(a,b)</p>
<p>参数说明：a 指定小数点左边和右边可以存储的十进制数字的最大个数。b 指定小数点右边可以存储的十进制数字的最大个数。</p>
<p>DECIMAL 只是一种存储格式，在实际计算中，DECIMAL 会转换为 DOUBLE。</p>
<p>CUP 不支持 DECIMAL 的直接运算，DECIMAL 的运算要在服务器层实现。相对而言，CUP 原生支持的浮点数运算更快。</p>
<p>MySQL 使用 DOUBLE 作为内部浮点计算的类型。</p>
<p>推荐只指定数据类型，不指定精度。</p>
<p>尽量只在对小数进行精确计算时才使用 DECIMAL，例如财务数据。</p>
<p>在数据量比较大时，可以使用 BIGINT 代替 DECIMAL，只需要将 DECIMAL 乘以合适的倍数将其转换为整数即可。这样可以避免浮点数计算精度问题和 DECIMAL 计算代价大的问题。</p>
<h2 id="字符串类型">字符串类型</h2>
<p>MySQL 4.1 开始，每个字符串列可以自定义自己的字符集和排序规则，这些东西会很大程度上影响性能。</p>
<h3 id="varchar-和-char-类型">VARCHAR 和 CHAR 类型</h3>
<p>这两个数据类型在磁盘和内存中的存储方式与存储引擎的具体实现有关。以下以 InnoDB 和 MyISAM 在磁盘上的存储为例。</p>
<ul>
<li><p>VARCHAR</p>
<p>用于存储可变长的字符串。</p>
<p>比定长类型节省空间，因为它仅使用必要的空间。</p>
<p>例外：如果表使用 ROW_FORMAT = FIXED 创建，每一行都会使用定长储存，这会很浪费存储空间。</p>
<p>VARCHAR 需要使用额外的字节记录字符串的长度，如果列的最大长度小于等于 255 字节，则使用 1 个字节记录，否则使用 2 字节。</p>
<p>由于行是变长的，在 UPDATE 时可能使行变得比原来长，这会导致额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间存储，在这种情况下，不同的存储引擎的处理方式不同。InnoDB 会分裂页来使行可以放入页内，MyISAM 会将行拆分成不同的片段存储。</p>
<p>适用 VARCHAR 的情况：</p>
<ol type="1">
<li>字符串列的最大长度比平均长度大很多</li>
<li>列的更新很少</li>
<li>使用了像 UTF-8 这样的复杂字符集，每个字符都使用不同的字节进行存储。</li>
</ol>
<p>MySQL 5.0 及以上在存储和检索时会保留末尾空格。</p>
<p>InnoDB 会把过长的 VARCHAR 存储为 BLOB。</p></li>
<li><p>CHAR</p>
<p>CHAR 是定长的。MySQL 总是根据定义的字符串长度为 CHAR 分配足够的空间。</p>
<p>存储时，MySQL 会删除所有的末尾空格。</p>
<p>CHAR 值会根据需要使用空格进行填充以便进行比较。</p>
<p>适用 CHAR 的情况：</p>
<ol type="1">
<li>很短的字符串。</li>
<li>所有值都接近同一长度的字符串。比如 MD5 值。</li>
<li>对于经常变更的数据，CHAR 比 VARCHAR 更有效率，因为不容易产生碎片。</li>
</ol></li>
</ul>
<p>填充和截取空格的行为在不同的存储引擎中都是一样的，因为这是在服务器层处理的。</p>
<h3 id="binary-和-varbinary">BINARY 和 VARBINARY</h3>
<p>与 CHAR 和 VARCHAR 很像。</p>
<p>这两个数据类型存储的是二进制的字符串，即存储的是字节码而不是字符。</p>
<p>填充时使用 \0 而不是空格。</p>
<p>二进制比较比字符比较简单很多，也就快很多。</p>
<h3 id="慷慨是不明智的-最好的策略是只分配真正需要的空间">慷慨是不明智的 最好的策略是只分配真正需要的空间</h3>
<h3 id="blob-和-text-类型">BLOB 和 TEXT 类型</h3>
<p>用于存储很大的数据。</p>
<p>BLOB 存储二进制数据，没有字符集和排序规则。</p>
<p>TEXT 存储字符数据，有字符集和排序规则。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字符类型</th>
<th style="text-align: center;">二进制类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">TINYTEXT</td>
<td style="text-align: center;">TINYBLOB</td>
</tr>
<tr class="even">
<td style="text-align: center;">SMALLTEXT(TEXT)</td>
<td style="text-align: center;">SMALLBLOB(BLOB)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">MEDIUMTEXT</td>
<td style="text-align: center;">MEDIUMBLOB</td>
</tr>
<tr class="even">
<td style="text-align: center;">LONGTEXT</td>
<td style="text-align: center;">LONGBLOB</td>
</tr>
</tbody>
</table>
<p>InnoDB 在 BLOB 或 TEXT 太大时，使用专用的外部存储区域存储，在行内只存储一个指向外部存储区域的指针。</p>
<p>只对每列最前的 max_sort_lenght 字节做排序而不是对整个字符串。</p>
<p>不能将 BLOB 和 TEXT 全部长度的字符串进行索引，也不能使用这些索引消除排序。</p>
<h3 id="使用枚举类型代替字符串类型">使用枚举类型代替字符串类型</h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/14/Manacher-%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/14/Manacher-%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Manacher 算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-14 17:21:49" itemprop="dateCreated datePublished" datetime="2020-02-14T17:21:49+08:00">2020-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-17 15:50:50" itemprop="dateModified" datetime="2020-02-17T15:50:50+08:00">2020-02-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="功能">功能</h1>
<p>查找一个字符串的最长回文子串的线性算法</p>
<h1 id="算法原理与实现">算法原理与实现</h1>
<ol type="1">
<li><p>将长度为奇数和偶数的回文串一起处理</p>
<p>Manacher 使用一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑。具体做法是，在原字符串的每个相邻字符中间插入一个分隔符，同时在首尾也要各添加一个分隔符。要求分隔符不在原字符串中出现。如下图所示，其中，原始字符串为 S，转换后的字符串为 T：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxczgeenuj34a10x3jvu.jpg" /></p></li>
<li><p>使用额外空间存储必要信息 Len 数组</p>
<p>辅助数组 Len 是算法的核心。</p>
<p>Len[i] 表示以字符 T[i] 为中心的最长回文子串的最右端字符到字符 T[i] 的字符个数。</p>
<p>比如，以 T[i] 为中心的最长回文子串是 T[l,r]，则 Len[i] = r - i + 1。</p>
<p>对于上面的例子，可以得出如下的 Len 数组：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxdeb6mxqj33uo0shjvo.jpg" /></p>
<p>Len 数组的性质：Len[i] - 1 等于该回文子串在原字符 S 中的长度。</p>
<p>证明如下：首先，在转换得到的字符串 T 中，所有的回文串的长度都为奇数。那么，对于以字符 T[i] 为中心的最长回文子串，其长度就是 2 × Len[i] -1。经过观察可知，T 中的所有回文子串，其中分隔符的数量一定比其他字符的数量多一。所以， 2 × Len[i] -1 的长度中，有 Len[i] 个分隔符，剩下 Len[i] - 1 个字符来自原字符串。综上所述，该回文串在原字符串中的长度为 Len[i] - 1。</p></li>
<li><p>Len 数组的计算</p>
<p>从左向右依次计算 Len 数组。当计算 Len[i] 时，Len[0] ~ Len[i-1] 已经计算完毕。</p>
<p>设 P 为之前计算中最长回文子串的右端点的最大值。并且，设取得这个最大值的位置为 Po。</p>
<p>分为两种情况计算：</p>
<ol type="1">
<li><p>i &lt; P</p>
<p>找到 i 相对于 Po 的对称位置，设为 j。再分为三种情况。</p>
<ul>
<li><p>Len[j] &lt; P - i + 1 如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxdx60uxbj34r827w0ys.jpg" /></p>
<p>此时说明，以 j 为中心的回文串一定在以 Po 为中心的回文串的内部。j 和 i 关于位置 Po 对称，并且，由回文串的定义可知，一个回文串反过来还是一个回文串。所以，以 i 为中心的回文串的长度至少和以 j 为中心的回文串的长度一样长，即 Len[i] ≥ Len[j]。由对称性可知，Len[i] = Len[j]。</p></li>
<li><p>Len[j] &gt; P - i + 1 如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxe6lr6amj34r827wwki.jpg" /></p>
<p>此时，Len[i] = P - i + 1</p>
<p>证明如下：由图可知，Len[i] ≥ P - i + 1。</p>
<p>假设 Len[i] &gt; P - i + 1，则 Len[Po] &gt; P - Po +1，即以 Po 为中心的回文子串是可以更长的，这与 Len[Po] 的原值不符，所以假设错误。</p>
<p>综上所述，Len[i] = P - i + 1</p></li>
<li><p>Len[j] = P - i + 1 如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxgfvlv0pj30h2083wed.jpg" /></p>
<p>此时，以 i 为中心的回文串可能会延伸到 P 之外，对于大于 P 的部分，我们还未匹配。因此，要从 P + 1 开始一个一个的匹配，直到发生失配，得出 Len[i] 的值。</p></li>
</ul></li>
<li><p>i &gt;= P 如下图所示： <img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbzf37mcc7j348t1g1wgo.jpg" /> <img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbzfxdznfuj30hl07mglf.jpg" /> 这两种情况下，对于中点为 i 的回文串还一点都没有匹配。因此，只能一个一个的匹配得出 Len[i] 的值。</p></li>
</ol></li>
<li><p>时间复杂度分析</p>
<p>该算法只有在遇到没有匹配的位置时才进行匹配，已经匹配过的位置不再匹配。因此，对于字符串 T 中的每一个位置，只进行一次匹配，算法整体复杂度为 O(n)，其中 n 为字符串 T 的长度。由于 T 的长度实际上是原字符串 S 的长度的两倍，所以时间复杂度依旧是线性的。</p></li>
<li><p>算法实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串 s 中的任意一个最长回文子串 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">     <span class="comment">// 初始化辅助字符串</span></span><br><span class="line">     <span class="built_in">string</span> T=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">         T+=s.substr(i,<span class="number">1</span>)+<span class="string">&quot;#&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 初始化辅助数组</span></span><br><span class="line">     <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Len</span><span class="params">(T.length())</span></span>;</span><br><span class="line">     Len[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> aimIndex=<span class="number">0</span>,Po=<span class="number">0</span>,P=<span class="number">0</span>; <span class="comment">// aimIndex 存放最长回文子串的中心字符在 T 中的下标</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;T.length();i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(i&lt;P)&#123;</span><br><span class="line">             <span class="keyword">int</span> j=Po-i+Po;</span><br><span class="line">             <span class="keyword">int</span> threshold=P-i+<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span>(Len[j]&lt;threshold)&#123;</span><br><span class="line">                 Len[i]=Len[j];</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Len[j]&gt;threshold)&#123;</span><br><span class="line">                 Len[i]=P-i+<span class="number">1</span>;</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Len[j]==threshold)&#123;</span><br><span class="line">                 <span class="keyword">int</span> left=i-P+i<span class="number">-1</span>;</span><br><span class="line">                 <span class="keyword">int</span> right=P+<span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;T.length()&amp;&amp;T[left]==T[right])&#123;</span><br><span class="line">                     right++;</span><br><span class="line">                     left--;</span><br><span class="line">                 &#125;</span><br><span class="line">                 Len[i]=right-i;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> left=i<span class="number">-1</span>;</span><br><span class="line">             <span class="keyword">int</span> right=i+<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;T.length()&amp;&amp;T[left]==T[right])&#123;</span><br><span class="line">                 right++;</span><br><span class="line">                 left--;</span><br><span class="line">             &#125;</span><br><span class="line">             Len[i]=right-i;</span><br><span class="line">         &#125;</span><br><span class="line">         aimIndex=Len[i]&gt;=Len[aimIndex]?i:aimIndex;</span><br><span class="line">         <span class="keyword">if</span>(i+Len[i]<span class="number">-1</span>&gt;P)&#123;</span><br><span class="line">             P=i+Len[i]<span class="number">-1</span>;</span><br><span class="line">             Po=i;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 从 T 中提取最长回文子串</span></span><br><span class="line">     <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=aimIndex-Len[aimIndex]+<span class="number">1</span>;i&lt;=aimIndex+Len[aimIndex]<span class="number">-1</span>;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(T[i]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">             ans+=T.substr(i,<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/01/leetcode-%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/01/leetcode-%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">leetcode 刷题经验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-01 16:20:40" itemprop="dateCreated datePublished" datetime="2020-02-01T16:20:40+08:00">2020-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-05 21:20:04" itemprop="dateModified" datetime="2020-02-05T21:20:04+08:00">2020-02-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c-不要用局部静态变量在多个测试用例的调用过程中局部静态变量只会被初始化一次导致测试用例之间的结果相互影响出现-bug">C++ 不要用局部静态变量。在多个测试用例的调用过程中，局部静态变量只会被初始化一次，导致测试用例之间的结果相互影响，出现 bug。</h1>
<h1 id="想要所有的递归函数使用同一个变量有三种方法全局变量局部静态变量参数传引用">想要所有的递归函数使用同一个变量有三种方法，全局变量，局部静态变量，参数传引用。</h1>
<h1 id="string-转-int">string 转 int</h1>
<ol type="1">
<li>使用 C++ 11 中的全局函数 std::to_string <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>使用 sstream 中定义的字符串流对象来实现 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ostringstream</span> os; <span class="comment">// 构造一个输出字符串流，流的内容为空</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">12</span>;</span><br><span class="line">os&lt;&lt;i; <span class="comment">// 向输出字符串流中输入 int 型整数 i 的内容</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;os.str()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure> # C++ stringstream 使用 C++ 的输入输出分为三种</li>
<li>基于控制台的 I/O</li>
</ol>
<table>
<thead>
<tr class="header">
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>iostream</td>
<td>istream 从流中读取、ostream 写到流中去、iostream 对流进行读写</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>基于文件的 I/O</li>
</ol>
<table>
<thead>
<tr class="header">
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>fstream</td>
<td>ifstream 从文件中读取、ofstream 写到文件中去、fstream 对文件进行读写</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>基于字符串的 I/O</li>
</ol>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sstream</td>
<td>istringstream 从 string 对象中读取、ostringstream 写到 string 对象中去、stringstream 对 string 对象进行读写</td>
</tr>
</tbody>
</table>
<p>ostringstream、istringstream、stringstream 这三个类包含在 sstream.h 文件中。 istringstream 类用于执行 C++ 风格的串流的输入操作。 ostringstream 类用于执行 C++ 风格的串流的输出操作。 stringstream 类同时支持 C++ 风格的串流的输入输出操作。 * istringstream 类 从字符串中提取数据，支持 &gt;&gt; 操作。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">istringstream</span>::<span class="built_in">istringstream</span>(<span class="built_in">string</span> str); <span class="comment">// 构造函数原型</span></span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">istr</span><span class="params">(<span class="string">&quot;1 56.3&quot;</span>)</span></span>; <span class="comment">// 初始化一个 istringstream 对象</span></span><br><span class="line">istr.str(<span class="string">&quot;1100 2.3&quot;</span>); <span class="comment">// 把字符串写入 istr 中。可以使用分界点获取不同的数据，完成字符串到其他数据类型的转换。</span></span><br><span class="line">istr.str(); <span class="comment">// 使 istringstream 返回一个字符串</span></span><br><span class="line"><span class="comment">// 举例 把字符串转换为其他数据类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">istr</span><span class="params">(<span class="string">&quot;1 56.7&quot;</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;istr.str()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//直接输出字符串的数据 &quot;1 56.7&quot;   </span></span><br><span class="line">      </span><br><span class="line">    <span class="built_in">string</span> str = istr.str();<span class="comment">//函数str()返回一个字符串   </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="keyword">double</span> d;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//以空格为界，把istringstream中数据取出，应进行类型转换   </span></span><br><span class="line">    istr&gt;&gt;n;<span class="comment">//第一个数为整型数据，输出1   </span></span><br><span class="line">    istr&gt;&gt;d;<span class="comment">//第二个数位浮点数，输出56.7   </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//假设换下存储类型   </span></span><br><span class="line">    istr&gt;&gt;d;<span class="comment">//istringstream第一个数要自动变成浮点型，输出仍为1   </span></span><br><span class="line">    istr&gt;&gt;n;<span class="comment">//istringstream第二个数要自动变成整型，有数字的阶段，输出为56   </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//测试输出   </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/01/30/SQL-%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/SQL-%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">SQL 命令学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-30 20:41:24 / Modified: 22:52:47" itemprop="dateCreated datePublished" datetime="2020-01-30T20:41:24+08:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-命令">MySQL 命令</h1>
<ul>
<li>登录本机的 MySQL 数据库 mysql -u root -p</li>
<li>登录 MySQL 服务器 mysql -h 主机名 -u 用户名 -p -h：指定客户端需要登陆的 MySQL 主机名，登录本机时可以省略。 -u：登录的用户名 -p：告诉服务器将会使用一个密码登录。如果密码为空，可以忽略此选项。</li>
<li>创建新用户 MySQL 默认使用严格模式，禁止使用 INSERT 命令直接向 mysql 数据库的 user 表中插入新行。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> username<span class="variable">@host</span> indentified <span class="keyword">by</span> <span class="string">&#x27;password&#x27;</span>; <span class="operator">/</span><span class="operator">/</span> 创建用户，没有任何权限</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> username<span class="variable">@host</span>; <span class="operator">/</span><span class="operator">/</span> 查询用户权限</span><br></pre></td></tr></table></figure> username 和 host 用 @ 符号分割。host 指明用户登陆 MySQL 服务器的主机。host 为 % 时，表示用户可以从任何主机登陆 MySQL 服务器。</li>
<li>向用户授予权限 GRANT 语句 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privilege,[privilege],.. <span class="keyword">ON</span> privilege_level </span><br><span class="line"><span class="keyword">TO</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> [IDENTIFIED <span class="keyword">BY</span> password]</span><br><span class="line">[REQUIRE tsl_option]</span><br><span class="line">[<span class="keyword">WITH</span> [GRANT_OPTION <span class="operator">|</span> resource_option]];</span><br></pre></td></tr></table></figure> [] 内的内容为可选选项。 GRANT 关键字之后可以指定一个或多个权限。权限之间以逗号分隔。 privilege_level 指定权限级别。MySQL 支持全局 <code>*.*</code> 权限，数据库 <code>database.*</code> 权限，表 <code>database.table</code> 权限和列权限。使用列权限时，必须在每个权限之后用逗号分隔列名。 放置要授予权限的用户。如果用户已存在，则 GRANT 语句修改其权限。如果不存在，则 GRANT 语句将创建一个新用户。可选的 IDENTIFIED BY 允许为新用户设置密码。 REQUIRE tsl_option 指定用户是否必须通过安全连接连接到数据库 WITH GRANT OPTION 子句允许此用户授予其他用户权限。 RESOURCE OPTION 子句用于分配 MySQL 服务器的资源。例如，设置用户每小时可以使用多少个连接或语句。 使用 GRANT 语句必须要有 GRANT OPTION 权限。如果启用了 read_only 系统变量，则需要具有 SUPER 权限才能执行 GRANT 语句。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/01/30/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">《高性能 MySQL》学习笔记 第一章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 20:36:55" itemprop="dateCreated datePublished" datetime="2020-01-30T20:36:55+08:00">2020-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-14 12:12:09" itemprop="dateModified" datetime="2020-06-14T12:12:09+08:00">2020-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-的架构">MySQL 的架构</h1>
<p>最上层 服务器层</p>
<p>第二层 查询执行引擎 大多数 MySQL 的核心服务功能位于这一层，比如：查询解析、分析、优化、缓存以及所有的内置函数。所有跨存储引擎的功能也都位于这一层，比如：存储过程、触发器、视图等。</p>
<p>第三层 存储引擎 存储引擎负责 MySQL 中数据的存储与提取。第二层通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使这些差异对上层的查询过程透明。 存储引擎不会解析 SQL 语句。InnoDB 是个例外，它会解析外键，因为 MySQL 服务器中没有实现解析外键这一功能。 存储引擎之间不会相互通信，只是简单的响应上层的请求。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/30/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/01/26/JavaScript-%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/26/JavaScript-%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JavaScript 学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-26 15:29:07 / Modified: 15:32:33" itemprop="dateCreated datePublished" datetime="2020-01-26T15:29:07+08:00">2020-01-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="javascript-是大小写敏感的">JavaScript 是大小写敏感的</h1>
<h1 id="数据类型">数据类型</h1>
<ul>
<li>七种基本数据类型
<ul>
<li>Boolean 有两个值，分别为 true 和 false</li>
<li>null 表明 null 值的关键字</li>
<li>undefined 特殊关键字，表示变量未定义时的属性</li>
<li>Number 整数或浮点数</li>
<li>BigInt 任意精度的整数</li>
<li>String 字符串</li>
<li>Symbol 一种实例唯一且不可更改的数据类型</li>
</ul></li>
<li>Object 对象</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/01/23/C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">C++ 实现一个 Web 服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-23 16:12:00 / Modified: 21:35:01" itemprop="dateCreated datePublished" datetime="2020-01-23T16:12:00+08:00">2020-01-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="web-服务器">Web 服务器</h1>
<p>Web 服务器是 HTTP 请求的应答方。 # CDN Content Delivery Network 内容分发网络。依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，挑个用户访问速度和命中率。 # WAF Web Appalication Firewall 网络应用防火墙。通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。它是应用层面的防火墙，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止 SQL 注入、跨站脚本等攻击。 # URI Uniform Resource Identifier 统一资源标识符。使用 URI 可以唯一的标记互联网上的资源。 # URL Uniform Resource Locator 统一资源定位符。它是 URI 的一个子集。 URL 分析 <code>http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument</code> <code>http://</code> 是方案或协议，该部分告诉浏览器使用何种协议。 # URN Uniform Resource Name 统一资源名称。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/01/17/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">常见排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 18:43:07" itemprop="dateCreated datePublished" datetime="2020-01-17T18:43:07+08:00">2020-01-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hespoon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">hespoon</p>
  <div class="site-description" itemprop="description">全心全意的投入生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hespoon" title="GitHub → https://github.com/hespoon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hezaojian@gmail.com" title="E-Mail → mailto:hezaojian@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fas fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hespoon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">142k</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        


  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1279024191&web_id=1279024191"></script>
  </div>






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
