<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-hespoon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-hespoon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-hespoon.png">
  <link rel="mask-icon" href="/images/hespoon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hespoon.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":"//cdn.jsdelivr.net/gh/user/repo@version/file","lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="全心全意的投入生活">
<meta property="og:type" content="website">
<meta property="og:title" content="Spirit">
<meta property="og:url" content="http://hespoon.github.io/page/2/index.html">
<meta property="og:site_name" content="Spirit">
<meta property="og:description" content="全心全意的投入生活">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="hespoon">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hespoon.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Spirit</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Spirit</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hespoon" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/03/12/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">图算法专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-12 06:53:26" itemprop="dateCreated datePublished" datetime="2020-03-12T06:53:26+08:00">2020-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-18 12:55:45" itemprop="dateModified" datetime="2020-10-18T12:55:45+08:00">2020-10-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="图的定义与相关术语"><a class="markdownIt-Anchor" href="#图的定义与相关术语"></a> 图的定义与相关术语</h1>
<p>图由顶点和边组成。</p>
<p>图分为有向图和无向图。有时可以将无向图看为双向的有向图。</p>
<p>图可以表示为 G(V,E)，V 是顶点的集合，E 是边的集合。</p>
<h1 id="图的存储"><a class="markdownIt-Anchor" href="#图的存储"></a> 图的存储</h1>
<p>图的存储方式有两种：邻接矩阵和邻接表。</p>
<p><strong>邻接矩阵</strong></p>
<p>设图 G(V,E) 的顶点编号为 0、1、…、N-1，则可以令二维数组 G[N][N] 的两维分别表示图的顶点编号。G[i][j] 表示点 i 到点 j 的边的权重。可以令权重等于一个非法值来表示两点之间不联通。</p>
<p><strong>邻接表</strong></p>
<p>设图 G(V,E) 的顶点编号为 0、1、…、N-1，每个顶点都可能有若干条出边，如果把同一个顶点的所有出边放在一个列表中，那么 N 个顶点就会有 N 个列表（没有出边，则对应空表），这 N 个列表被称为图 G 的邻接表，记为 Adj[N]，其中 Adj[i] 存放顶点 i 的所有出边组成的列表，这样 Adj[0]，Adj[1]，…，Adj[N-1] 就分别都是一个列表。直观上，邻接表可以使用链表实现。但是，使用 vector 实现会更加方便。</p>
<p>对于有 N 个顶点的图，可以申请一个二维 vector 数组 Adj[N]，其中 N 为顶点个数，每个 Adj[i] 都是一个变长数组 vector，存放点 i 的出边。</p>
<p>如果邻接表中只存放顶点之间的连接情况，不存放边权，则可以直接声明为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[N];</span><br></pre></td></tr></table></figure>
<p>如果邻接表中需要存放边权，可以先声明一个结构体 Node，用于存放出边的终点编号和边权</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> v; <span class="comment">// 出边终点编号</span></span><br><span class="line">  <span class="keyword">int</span> w; <span class="comment">// 出边的边权</span></span><br><span class="line">  Node () &#123;&#125;</span><br><span class="line">  Node (<span class="keyword">int</span> _v,<span class="keyword">int</span> _w): v(_v),w(_w) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>邻接表如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[N];</span><br></pre></td></tr></table></figure>
<h1 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历</h1>
<p>遍历整个图，就相当于对图中所有的连通块进行遍历。</p>
<p><strong>DFS</strong></p>
<p>DFS 遍历图的基本思想是，将已经访问过的点设为已访问，下次递归到时不再处理，直到整个图的顶点都标记为以访问。</p>
<p>一次 DFS 遍历可以遍历完一个连通块。</p>
<p>如果已知图是一个连通图，则只需要一次 DFS 就可以遍历所有顶点。如果图是不连通的，包含多个连通块，则需要多次 DFS 遍历。DFS 的伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DFS(u)&#123; <span class="comment">// 访问顶点 u 所在的连通块</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(从 u 出发能到达的所有顶点 v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DFSTrave(G)&#123; <span class="comment">// 遍历图 G</span></span><br><span class="line">    <span class="keyword">for</span>(G 的所有顶点 u)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是邻接表和邻接矩阵的 DFS 遍历框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V=<span class="number">1000</span>; <span class="comment">// 定义最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7fffffff</span>; <span class="comment">// 定义一个超大数，在邻接矩阵中表示两点之间不连通</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[MAX_V]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 访问数组，初始化为全 false</span></span><br><span class="line"><span class="comment">/*--------------------邻接矩阵的 DFS 遍历--------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// u 为当前访问顶点，depth 为 DFS 树的深度，n 为节点个数</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为以访问</span></span><br><span class="line">    <span class="comment">// 这里可以对 u 进行一些操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G[u][i]!=INF&amp;&amp;vis[i]==<span class="literal">false</span>)&#123; <span class="comment">// 如果 i 未被访问且 i 可达</span></span><br><span class="line">            DFS(i,depth+<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 遍历图 G，n 为顶点个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(i,<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------邻接表的 DFS 遍历----------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// u 为当前访问顶点，depth 为 DFS 树的深度，n 为节点个数</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 这里可以对 u 进行一些操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].size();i++)&#123; <span class="comment">// 遍历从 u 出发可以到达的所有顶点</span></span><br><span class="line">        <span class="keyword">int</span> v=adj[u][i]; <span class="comment">// 下一个要访问的顶点</span></span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(v,depth+<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 遍历图，n 为顶点个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            DFS(i,<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BFS</strong></p>
<p>BFS 以广度为关键词，以扩散的方式向外访问顶点。</p>
<p>BFS 需要使用一个队列，通过反复取出队首，将该顶点可达到的的未曾加入过队列的顶点全部入队，直到队列为空时遍历结束。</p>
<p>一次 BFS 遍历可以遍历一个连通块。</p>
<p>如果图中有多个连通块，则需要多次 BFS 遍历。BFS 的伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BFS(u)&#123; <span class="comment">// 遍历 u 所在的连通块</span></span><br><span class="line">    <span class="built_in">queue</span> q; <span class="comment">// 定义队列 q</span></span><br><span class="line">    将 u 入队;</span><br><span class="line">    inq[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为已进入过队列</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        取出队首元素 s 进行访问;</span><br><span class="line">        <span class="keyword">for</span>(从 s 出发可到达的所有顶点 v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inq[v] == <span class="literal">false</span>)&#123;</span><br><span class="line">                将 v 入队;</span><br><span class="line">                inq[v]=<span class="literal">true</span>; <span class="comment">// 标记 v 为已入过队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFSTrave(G)&#123; <span class="comment">// 遍历图 G</span></span><br><span class="line">	<span class="keyword">for</span>(G 中的所有顶点 u)&#123; <span class="comment">// 枚举 G 中的所有顶点 </span></span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)&#123; <span class="comment">// 如果顶点没有入过队</span></span><br><span class="line">            BFS(u); <span class="comment">// 遍历 u 所在的连通块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面分别是邻接矩阵和邻接表的 BFS 遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V =<span class="number">10000</span>; <span class="comment">// 定义最大顶点个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7fffffff</span>; <span class="comment">// 定义一个超大数，表示不可达</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[MAX_V]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">bool</span> inq[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 入队标记数组</span></span><br><span class="line"><span class="comment">/*----------邻接矩阵 BFS----------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 当前访问顶点 u 和图中顶点总数 n</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 在这里可以对队首顶点进行操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inq[i]==<span class="literal">false</span>&amp;&amp;G[u][i]!=INF)&#123;</span><br><span class="line">                inq[i]=<span class="literal">true</span>;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 图中节点总数 n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(i,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------邻接表 BFS---------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="comment">// 当前访问顶点 u</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 这里可以对队首顶点进行操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[temp].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=adj[temp][i];</span><br><span class="line">            <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>
<p>DFS 和 BFS 两种遍历方式都是一次遍历一个连通块，都使用了一个标记数组以防重复遍历同一个顶点。</p>
</li>
<li>
<p>DFS 每次遍历到最后一个顶点时会形成一个遍历路径，与标记数组结合，可以找出图中的环。</p>
</li>
<li>
<p>如果能够确定图是一棵树，则 DFS 和 BFS 都能保证每个顶点遍历且仅遍历一次，可以不用标记数组。</p>
</li>
<li>
<p>DFS 是以深度作为关键词，通过递归实现。</p>
</li>
<li>
<p>BFS 是以广度作为关键词，通过迭代和一个队列实现。</p>
</li>
</ul>
<h1 id="最短路径"><a class="markdownIt-Anchor" href="#最短路径"></a> 最短路径</h1>
<p>给定图 G(V,E)，求一条从起点到终点的路径，使得这条路径上经过的边的边权之和最小。</p>
<h2 id="单源最短路径"><a class="markdownIt-Anchor" href="#单源最短路径"></a> 单源最短路径</h2>
<p>给定图 G(V,E) 和起点 s，通过算法得到 s 到达其他每个顶点的最短距离。</p>
<h3 id="dijkstra-算法"><a class="markdownIt-Anchor" href="#dijkstra-算法"></a> <strong>Dijkstra 算法</strong></h3>
<p>Dijkstra 的基本思想是对图 G(V,E) 设置集合 S，存放已经被访问的顶点，然后每次从集合 V-S 中选择与起点 s 的最短距离最小的一个顶点，记为 u，访问 u 并加入集合 S 中。之后，令顶点 u 为中介点，优化起点 s 与所有能从 u 到达的顶点 v 之间的最短距离，这样的操作执行 n 次，n 为顶点个数，直到集合 S 包含所有顶点。</p>
<p>Dijkstra 算法只能处理边权都是非负数的图。如果边权出现负数，Dijkstra 算法就会出现错误。</p>
<p><strong>编码要点</strong></p>
<ol>
<li>
<p>集合 S 可以使用一个 bool 型数组 vis[] 来实现。</p>
<p>当 vis[i]=true 时，表示顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 已经被访问；vis[i]=false 时，表示顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 没有被访问</p>
</li>
<li>
<p>使用一个 int 型数组 d[] 表示起点 s 到达顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的最短距离。</p>
<p>初始时，起点 s 的 d[s] 赋为 0，表示从起点到起点的距离为 0，其余 d[i] 都赋为一个很大的数，表示其他顶点都是不可达的。</p>
</li>
</ol>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图 G 设为全局对象，减少传递参数带来的消耗；数组 d[] 为起点到达其他个点的最短路径的长度；s 为起点</span></span><br><span class="line">Dijkstra(G,<span class="keyword">int</span> d[],<span class="keyword">int</span> s)&#123;</span><br><span class="line">    初始化，d[s]=<span class="number">0</span>，其余 d[i]=<span class="number">0x3fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(循环 n 次，n 为顶点个数)&#123;</span><br><span class="line">        u=使 d[u] 最小，且还未访问的顶点的编号;</span><br><span class="line">        标记 u 已经被访问了;</span><br><span class="line">        <span class="keyword">for</span>(从 u 出发能到达的所有顶点 v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v 未被访问且以 u 为中介点使 s 到达 v 的距离更优)&#123;</span><br><span class="line">                优化 d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dijkstra 是一个迭代算法，最外层的 for 循环共循环 n 次，n 为顶点个数。</p>
<p>寻找最小且未被访问的 d[i] 可以通过最小堆来实现，将查找过程的时间复杂度优化为 O(1)，向最小堆中插入数据的时间复杂度为 O(logn)。因此，使用最小堆可以将查找操作的整体时间复杂度优化为 O(logn)。​ C++ 中的最小堆可以使用优先队列代替。</p>
<p><strong>邻接矩阵和邻接表的 Dijkstra 实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V=<span class="number">10000</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大数</span></span><br><span class="line"><span class="keyword">int</span> d[MAX_V]; <span class="comment">// 记录起点到达其他顶点的最短距离的数组</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 标记数组</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="comment">/*--------------------邻接矩阵的 Dijkstra 未优化----------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为顶点个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 填充数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 从起点到达起点的距离为 0</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 填充标记数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 循环 n 次</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF; <span class="comment">// u 使 d[u] 最小，MIN 存放最小的 d[u]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 寻找未访问的顶点中 d[] 最小者</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;</span><br><span class="line">                MIN=d[j];</span><br><span class="line">                u=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到小于 INF 的 d[u]，说明剩余顶点和起点不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 遍历从 u 出发可到达的所有顶点</span></span><br><span class="line">            <span class="comment">// 如果顶点未访问 &amp;&amp; 顶点可达 &amp;&amp; 以 u 为中介点可以使 d[j] 更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;G[u][j]!=INF&amp;&amp;d[u]+G[u][j]&lt;d[j])&#123;</span><br><span class="line">                d[j]=d[u]+G[u][j]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------邻接表的 Dijkstra 未优化-----------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 为边的目标顶点，dis 为边权</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; adj[MAX_V]; <span class="comment">// 邻接表，邻接表中要存储边权</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 是起点，n 是顶点个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 填充距离数组 d</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 起点到起点的距离为 0</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 填充标记数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// n 次循环</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 寻找未访问顶点中 d[] 最小的</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;MIN)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                MIN=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找不到小于 INF 的 d[u]，说明剩余顶点与起点不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为以访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;adj[u].size();j++)&#123;</span><br><span class="line">            <span class="comment">// 如果 j 未访问 &amp;&amp; 以 u 为中介点可以使 d[j] 更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;adj[u][j].dis+d[u]&lt;d[j])&#123;</span><br><span class="line">                d[j]=adj[u][j].dis+d[u]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未优化的 Djikstra 的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。其中，最外层的 for 循环需要循环 V 次，寻找 u 则还需要循环 V 次。</p>
<p><strong>使用最小堆优化的 Dijkstra</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V=<span class="number">10000</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大数</span></span><br><span class="line"><span class="keyword">int</span> d[MAX_V]; <span class="comment">// 记录起点到达其他顶点的最短距离的数组</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAX_V]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 标记数组</span></span><br><span class="line"><span class="keyword">int</span> G[MAX_V][MAX_V]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 是目标顶点，dis 是边权</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node a1,Node a2)&#123; <span class="comment">// 重载小于号，利用优先队列实现最小堆</span></span><br><span class="line">        <span class="keyword">return</span> a1.dis&gt;a2.dis;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(<span class="keyword">int</span> _v,<span class="keyword">int</span> _dis):v(_v),dis(_dis) &#123;&#125;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; adj[MAX_V]; <span class="comment">// 邻接表，需要存储边权</span></span><br><span class="line"><span class="comment">/*------------邻接矩阵 Dijkstra 堆优化----------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为顶点个数</span></span><br><span class="line">    fill(d,d+n,INF);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node&gt; minHeap; <span class="comment">// 最小堆，堆中记录 u 和 d[u]</span></span><br><span class="line">    minHeap.push(Node(s,d[s])); <span class="comment">// 将起点放入最小堆中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">while</span>(!minHeap.empty())&#123; </span><br><span class="line">            Node temp=minHeap.top(); <span class="comment">// 堆顶是 d[] 最小的</span></span><br><span class="line">            minHead.pop(); <span class="comment">// 将堆顶出堆。因为堆顶要么这次被访问，要么已经被访问过，所以没用了。</span></span><br><span class="line">            <span class="keyword">if</span>(vis[temp.v]==<span class="literal">false</span>)&#123; <span class="comment">// 如果当前顶点没有被访问</span></span><br><span class="line">                u=temp.v;  </span><br><span class="line">            	MIN=temp.dis;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找不到小于 INF 的 d[u]，表示剩余顶点与起点不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 如果 j 未访问 &amp;&amp; j 可达 &amp;&amp; 以 u 为中介点可以使 d[j] 更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;G[u][j]!=INF&amp;&amp;d[u]+G[u][j]&lt;d[j])&#123;</span><br><span class="line">                d[j]=d[u]+G[u][j]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">                <span class="comment">// 将优化过的 d[j] 放入最小堆，这里可能导致 d[j] 多次入队</span></span><br><span class="line">                <span class="comment">// 如果 d[j] 之前已经入过队且还没有出队，则 d[j] 会再次入队</span></span><br><span class="line">                minHeap.push(Node(j,d[j])); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------邻接表 Dijkstra 堆优化--------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    fill(d,d+n,INF);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node&gt; minHeap;</span><br><span class="line">    minHeap.push(Node(s,d[s]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">while</span>(!minHeap.empty())&#123;</span><br><span class="line">            Node temp=minHeap.top();</span><br><span class="line">            minHeap.pop();</span><br><span class="line">            <span class="keyword">if</span>(vis[temp.v]==<span class="literal">false</span>)&#123;</span><br><span class="line">                u=temp.v;</span><br><span class="line">                MIN=temp.dis;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;adj[u].size();j++)&#123;</span><br><span class="line">            <span class="comment">// 如果 j 未被访问 &amp;&amp; 以 u 为中介点 d[j] 可以优化</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[u]+adj[u][j].dis&lt;d[j])&#123;</span><br><span class="line">                d[j]=d[u]+adj[u][j]; <span class="comment">// 优化 d[j]</span></span><br><span class="line">                minHeap.push(Node(j,d[j])); <span class="comment">// 将优化过的 d[j] 放入最小堆中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用最小堆优化过的 Dijkstra 算法的时间复杂度降为 O(VlogV)。因为选择 u 的时间复杂度将为 O(logV) 了。</p>
<p><strong>记录每一条最短路径</strong></p>
<p>数组 d 的更新条件 “以 u 为中介点可以使起点 s 到顶点 v 的最短距离 d[v] 更优” 意味着，使 d[v] 变得更小的方案是让 u 作为 s 到 v 最短路径上 v 的前一个节点，即 s → … → u → v。记录最短路径就是将这个信息记录下来。</p>
<p>设数组 pre[]，令 pre[v] 表示从起点 s 到顶点 v 的最短路径上 v 的前一个顶点（即前驱结点）的编号。在优化 d[v] 时，可以将 u 赋给 pre[v]。最终，最短路径上每一个节点的前驱节点都可以被记录下来。</p>
<p>一般，从起点 s 到顶点 v 的最短路径不止有一条，可以将 pre 数组声明为 <code>vector&lt;int&gt; pre[MAX_V]</code>。这样对每个顶点 v 来说，pre[v] 就是一个变长数组 vector，里面存放顶点 v 的所有能产生最短路径的前驱结点。</p>
<p>二维的 pre 数组不需要被赋初值。</p>
<p>pre 数组的更新过程如下：</p>
<ol>
<li>
<p>d[u]+G[u][v]&lt;d[v]</p>
<p>此时说明以 u 为中介点，可以使 d[v] 更优，此时 v 的前驱节点为 u。</p>
<p>先将 pre[v] 清空，再将 u 加入到 pre[v] 中。</p>
</li>
<li>
<p>d[u]+G[u][v]==d[v]</p>
<p>此时说明以 u 为中介点可以找到一条相同距离的路径，因此直接将 u 添加到 pre[v] 中即可。</p>
</li>
</ol>
<p>pre 数组计算完成后，使用 DFS 从终点开始遍历 pre 数组，遍历的过程会形成一棵递归树。路径的起点是树的叶子节点。</p>
<p>记录 DFS 遍历过程中的路径，就可以得到最短路径。DFS 递归到起点时终止递归。由于递归的原因，记录在 tempPath 中的路径是从终点到起点倒着存储的。</p>
<h3 id="bellman-ford-算法"><a class="markdownIt-Anchor" href="#bellman-ford-算法"></a> <strong>Bellman-Ford 算法</strong></h3>
<p>BF 算法可以处理有负权边的图。</p>
<p><strong>图中的环</strong></p>
<p>环，也就是从某个顶点出发，经过若干个不同的顶点之后可以回到该顶点的情况。</p>
<p>根据环中边的边权之和的正负，环可以分为零环、正环和负环。</p>
<p>零环和正环不会影响最短路径的求解，因为零环和正环不会使最短路径更短。</p>
<p>如果图中有负环，且从起点可以到达，那么就会影响最短路径的求解；如果负环不能从起点到达，则最短路径的求解不会受影响。</p>
<p><strong>基本思想</strong></p>
<p>BF 算法设置一个数组 d，用来存放从起点到达其它各顶点的最短距离。</p>
<p>BF 算法返回一个 bool 值：如果图中存在从起点可达的负环，那么函数返回 false；否则，函数返回 true，此时数组 d 中存放的值就是从起点到达各顶点的最短距离。</p>
<p>BF 算法需要对图中的边进行  V-1 轮操作，每轮都遍历图中的所有边：对每条边 u→v，如果以 u 为中介点可以使 d[v] 更小，即 d[u]+length[u→v]&lt;d[v] 成立时，就用 d[u]+length[u→v] 更新 d[v]。在 V-1 轮操作后，如果图中没有从起点可达的负环，则数组 d 中的所有值都应当已经达到最优。因此，此时在对所有边进行一轮操作，判断是否有某条边依然满足 d[v]&gt;d[u]+length[u→v]，如果有，则说明图中有从起点可达的负环，算法返回 false，表示没有最短路径，路径可以无限缩短；否则，说明数组 d 的所有值已经达到最优，返回 true。</p>
<p>由此可以看出，BF 算法的时间复杂度是 O(VE)，其中 V 是顶点的个数，E 是边的个数。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V<span class="number">-1</span>;i++)&#123; <span class="comment">// 共循环 V-1 次，V 为顶点的个数</span></span><br><span class="line">    <span class="keyword">for</span>(each edge u→v)&#123; <span class="comment">// 每次都遍历所有的边</span></span><br><span class="line">        <span class="keyword">if</span>(d[v]&gt;d[u]+length[u→v])&#123; <span class="comment">// 如果以 u 为中介点，可以使 d[v] 更优</span></span><br><span class="line">            d[v]=d[u]+length[u→v]; <span class="comment">// 松弛 d[v]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(each edge u→v)&#123; <span class="comment">// 最后再遍历一次所有的边</span></span><br><span class="line">    <span class="keyword">if</span>(d[u]+length[u→v]&lt;d[v])&#123; <span class="comment">// 如果依旧可以松弛</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 说明图中有起点可达的负环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 图中没有起点可达的负环，数组 d 的所有值已经更新到最优</span></span><br></pre></td></tr></table></figure>
<p><strong>简单证明 BF 算法</strong></p>
<ol>
<li>如果最短路径存在，则最短路径上顶点的个数不会超过 V 个，因为整个图中顶点个数就只有 V 个。</li>
<li>如果把起点 s 作为一棵树的根节点，把其他节点按照最短路径的节点顺序连接，就会生成一棵最短路径树。最短路径树中节点的个数不会超过 V 个，则最短路径树的高度一定不会超过 V。因为包含 V 个顶点的树的最大高度为 V。</li>
<li>初始状态下 d[s]=0，因此在接下来的步骤中 d[s] 不会改变，即最短路径树的根节点被确定。BF 算法遍历一次所有边后，最短路径树中第二层节点也就被确定下来了。由于最短路径树的高度不超过 V，所以 BF 算法的松弛操作不会超过 V-1 次。</li>
</ol>
<p>由于 BF 算法需要遍历所有边，所以使用邻接矩阵存储表会比较方便。如果使用邻接矩阵，则会使 BF 算法的时间复杂度上升为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>下面是以邻接表存储图的 BF 算法的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 为邻接边的目标顶点，dis 为邻接边的边权</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">10000</span>; <span class="comment">// 图中顶点的最大个数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大的数，表示不可达</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">// 邻接矩阵表示的图</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">// 从起点到达其他顶点的最短路径长度数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BF</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为图中顶点的个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 填充距离数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 起点到达自身的距离为 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123; <span class="comment">// 最外层的 n-1 次循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">// 遍历每一条边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;Adj[j].size();k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> endNode=Adj[j][k].v; <span class="comment">// 目标顶点</span></span><br><span class="line">                <span class="keyword">int</span> interNode=j; <span class="comment">// 中介顶点</span></span><br><span class="line">                <span class="keyword">int</span> len=Adj[j][k].dis; <span class="comment">// 从中介顶点到目标顶点的的边权</span></span><br><span class="line">                <span class="keyword">if</span>(d[endNode]&lt;d[interNode]+len)&#123; <span class="comment">// 如果以 j 为中介点可以松弛</span></span><br><span class="line">                    d[endNode]=d[interNode]+len; <span class="comment">// 松弛</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断负环是否存在</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 遍历每一条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[i].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> endNode=Adj[i][j].v;</span><br><span class="line">            <span class="keyword">int</span> interNode=i;</span><br><span class="line">            <span class="keyword">int</span> len=Adj[i][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[endNode]&lt;d[interNode]+len)&#123; <span class="comment">// 如果依旧可以松弛</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 存在从起点可达的负环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 数组 d 已达到最优，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将 BF 算法优化为 SPFA 算法 Shortest Path Faster Algorithm 快速最短路径算法</strong></p>
<p>BF 算法在每一轮遍历时，都要访问图中所有的边，这会导致大量无效访问。<strong>因为，只有在某个顶点 u 的 d[u] 值改变时，从它出发的边的邻接点 v 的 d[v] 值才有可能改变。</strong></p>
<p>因此，可以对 BF 进行如下优化：建立一个<strong>队列</strong>，每次将队首顶点 u 取出，然后对从 u 出发的所有边 u→v 进行松弛操作，如果可以松弛，则更新 d[v]。此时如果 v 不在队列中，就把 v 加入队列。这样操作直到队列为空（说明图中没有从起点可达的负环），或是某个顶点的入队次数超过 V-1 次（说明图中有从起点可达的负环）。</p>
<p>伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">起点 s 入队;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">    取出队首元素 u;</span><br><span class="line">    <span class="keyword">for</span>(u 的所有邻接边 u→v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">            d[v]=d[u]+dis;</span><br><span class="line">            <span class="keyword">if</span>(v当前不在队列中)&#123;</span><br><span class="line">                v入队;</span><br><span class="line">                <span class="keyword">if</span>(v入队的次数大于 n<span class="number">-1</span>)&#123;</span><br><span class="line">                    说明有可达的负环，<span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编码要点</strong></p>
<ol>
<li>使用一个 int 数组 num[] 记录顶点 v 的入队次数 num[v]</li>
<li>使用一个 bool 数组 inq[] 记录顶点 v 是否在队列中</li>
</ol>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>; <span class="comment">// 图中最大节点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大数，表示不可达</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">// 记录起点到其他节点的最短路径的距离数组</span></span><br><span class="line"><span class="keyword">bool</span> inq[maxv]; <span class="comment">// 记录节点是否在队列中</span></span><br><span class="line"><span class="keyword">int</span> num[maxv]; <span class="comment">// 记录节点的入队次数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// 边的终点和边权</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">// 图 G 的邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为起点，n 为图中顶点的个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 初始化 d 数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 起点 s 到自身的距离为 0</span></span><br><span class="line">    fill(inq,inq+n,<span class="literal">false</span>); <span class="comment">// 初始化入队标记数组</span></span><br><span class="line">    fill(num,num+n,<span class="number">0</span>); <span class="comment">// 初始化记录入队次数的数组</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q; <span class="comment">// 队列</span></span><br><span class="line">    Q.push(s); <span class="comment">// 起点入队</span></span><br><span class="line">    num[s]++; <span class="comment">// 入队次数加一</span></span><br><span class="line">    inq[s]=<span class="literal">true</span>; <span class="comment">// 标记为已入队</span></span><br><span class="line">    <span class="comment">// 算法主体</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=Q.front(); <span class="comment">// 获得队头</span></span><br><span class="line">        Q.pop(); <span class="comment">// 队头出队</span></span><br><span class="line">        inq[u]=<span class="literal">false</span>; <span class="comment">// 标记队头出队</span></span><br><span class="line">        <span class="comment">// 遍历 u 的所有邻接顶点 v</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][i].v;</span><br><span class="line">            <span class="keyword">int</span> len=Adj[u][i].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+len)&#123; <span class="comment">// 松弛操作</span></span><br><span class="line">                d[v]=d[u]+len;</span><br><span class="line">                <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123; <span class="comment">// 如果 v 不在队列中</span></span><br><span class="line">                    Q.push(v); <span class="comment">// v 入队</span></span><br><span class="line">                    inq[v]=<span class="literal">true</span>; <span class="comment">// 将 v 标记为已入队</span></span><br><span class="line">                    num[v]++; <span class="comment">// v 的入队次数加一</span></span><br><span class="line">                    <span class="keyword">if</span>(num[v]&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果入队次数大于 n-1 次，说明有负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 无可达负环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全源最短路径算法"><a class="markdownIt-Anchor" href="#全源最短路径算法"></a> <strong>全源最短路径算法</strong></h2>
<h3 id="floyd-算法"><a class="markdownIt-Anchor" href="#floyd-算法"></a> Floyd 算法</h3>
<p>Floyd 算法用来解决全源最短路径问题。即对给定的图 G(V,E)，求任意两点 u，v 之间的最短路径长度。</p>
<p>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>时间复杂度将图的顶点限制到了 200 以内。</p>
<p><strong>Folyd 算法的基本思想</strong></p>
<p>如果存在顶点 k，使得以 k 作为中介点时，顶点 i 和 顶点 j 的当前最短距离缩短，则使用 k 作为顶点 i 与顶点 j 的中介点。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">枚举顶点 k∈[<span class="number">1</span>,n]</span><br><span class="line">    以顶点 k 为中介点，枚举所有顶点对 i 和 j，i ∈ [<span class="number">1</span>,n]，j ∈ [<span class="number">1</span>,n]</span><br><span class="line">    	如果 dis[i][k]+dis[k][j]&lt;dis[i][j] 成立</span><br><span class="line">    		赋值 dis[i][j]=dis[i][k]+dis[k][j]</span><br></pre></td></tr></table></figure>
<p><strong>编码要点</strong></p>
<ol>
<li>使用三层 for 循环 k→i→j</li>
<li>不能将最外层的 k 循环放到内层，即产生 i→j→k 的三重循环，这样会导致出错。因为，如果较后访问的 dis[u][v] 有了优化之后，前面访问的 dis[i][j] 会因为已经被访问而无法获得进一步的优化。</li>
</ol>
<h1 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h1>
<p>最小生成树是在一个给定的<strong>无向连通图</strong> G(V,E) 中求一棵树 T，使得这棵树拥有图 G 中的所有顶点，且所有边都是来自图 G 中的边，并且满足整棵树的边权和最小。</p>
<p>最小生成树有三个重要性质：</p>
<ol>
<li>最小生成树是树，因此，其边数等于定点数减一，且树内一定不会有环。</li>
<li>对于给定的图 G(V,E)，其最小生成树可以不唯一，但其边权和一定是唯一的。</li>
<li>最小生成树是在无向图上生成的，因此其根节点可以是这棵树上的任意一个节点。</li>
</ol>
<p>求最小生成树一般有两种算法，即 prim 算法和 kruskal 算法。这两个算法都是采用了贪心法的思想，只是贪心的策略不太一样。</p>
<h2 id="prim-算法"><a class="markdownIt-Anchor" href="#prim-算法"></a> Prim 算法</h2>
<p><strong>基本思想</strong></p>
<p>对图 G(V,E) 设置集合 S，存放已经被访问的顶点，然后每次从集合 V-S 中选择与集合 S 的最短距离最小的一个顶点，记为 u，访问并加入到集合 S 中。之后，令顶点 u 为中介点，优化所有从 u 能到达的顶点 v 与集合 S 之间的最短距离。这样的操作重复执行 V 次，直到集合 S 中已包含所有顶点。</p>
<p><strong>编码要点</strong></p>
<ol>
<li>集合 S 的实现。与 Dijkstra 相同，使用一个 bool 型数组 vis[] 标记顶点是否已经被访问过。vis[v]=true 表示顶点 v 已经被访问，vis[v]=false 表示顶点 v 未被访问。以访问的顶点就相当于以加入到 S 中。</li>
<li>顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_i,(0\le i\le n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 与集合 S 的最短距离。使用一个 int 数组 d[] 来存放顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_i,(0\le i\le n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 与集合 S 的最短距离。初始时，令起点 d[s] 等于 0，其余与顶点都赋为一个很大的数 INF，表示不可达。</li>
</ol>
<p><strong>Prim 算法与 Dijkstra 算法的不同之处</strong>在于，数组 d[] 在 Prim 算法中表示顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_i,(0\le i\le n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 与集合 S 的最小距离，在 Dijkstra 算法中表示顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_i,(0\le i\le n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 与起点 s 的最小距离。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Prim(G,d[])&#123; <span class="comment">// G 为图，数组 d 存放顶点与集合 S 的最短距离</span></span><br><span class="line">    初始化;</span><br><span class="line">    <span class="keyword">for</span>(循环 n 次)&#123;</span><br><span class="line">        u = 使 d[u] 最小的还未被访问的顶点的编号;</span><br><span class="line">        标记 u 为以访问;</span><br><span class="line">        <span class="keyword">for</span>(从 u 出发能到达的所有顶点 v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v 未访问 &amp;&amp; 以 u 为中介点使得 v 与集合 S 的最短距离 d[v] 更优)&#123;</span><br><span class="line">                将 length[u→v] 赋值给 d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Prim 算法与 Dijkstra 算法实际上是相同的思路，只是数组 d[] 的含义不同</strong></p>
<p><strong>邻接矩阵与邻接表分别实现 Prim 算法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>; <span class="comment">// 图中最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3fffffff</span>; <span class="comment">// 一个超大值，表示不可达</span></span><br><span class="line"><span class="keyword">int</span> G[maxv][maxv]; <span class="comment">// 邻接矩阵，矩阵中的值表示边权</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis; <span class="comment">// v 为边的目标顶点，dis 为边权</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">// 存放顶点与集合的最小距离的数组</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxv]; <span class="comment">// 标记顶点是否被访问</span></span><br><span class="line"><span class="comment">/*-----------------------------邻接矩阵版---------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为人为指定的最小生成树的根节点，n 为图中的节点总数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 初始化距离数组</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 初始化标记数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 根节点为集合 S 中的第一个节点，距离集合 S 的距离为 0</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="comment">// 记录最小生成树的边权和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 循环 n 次，每次将一个顶点加入集合 S</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minl=INF; <span class="comment">// u 使 d[u] 最小，minl 存放最小的 d[u]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 顶点 j 未访问 &amp;&amp; d[j] 比 minl 小</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minl)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minl=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 u=-1，表示剩余顶点与集合 S 不连通，该图没有最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 标记 u 为已访问，即将顶点 u 加入集合 S</span></span><br><span class="line">        ans+=d[u]; <span class="comment">// 将与集合 S 距离最小的边加入最小生成树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 顶点 j 未访问 &amp;&amp; 从 u 可以到达顶点 j &amp;&amp; 以 u 为中介点可以使 d[j] 更小</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;G[u][j]!=INF&amp;&amp;d[u]+G[u][j]&lt;d[j])&#123;</span><br><span class="line">                d[j]=G[u][j]; <span class="comment">// 松弛 d[j]，这是与 Dijkstra 不同的地方</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------------邻接表版---------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// s 为人为指定的最小生成树的根节点，n 为图中顶点的个数</span></span><br><span class="line">    fill(d,d+n,INF); <span class="comment">// 初始化距离数组</span></span><br><span class="line">    fill(vis,vis+n,<span class="literal">false</span>); <span class="comment">// 初始化标记数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>; <span class="comment">// 根节点为集合 S 中的第一个节点，距离集合 S 的距离为 0</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="comment">// 存放最小生成树的边权和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 循环 n 次</span></span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minl=INF; <span class="comment">// u 使 d[u] 最小，minl 记录最小的 d[u]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 顶点 j 未访问 &amp;&amp; d[j] 小于 minl</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minl)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minl=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// u=-1 说明剩余顶点与集合 S 不连通，图 G 不存在最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>; <span class="comment">// 将 u 标记为以访问，即加入集合 S</span></span><br><span class="line">        ans+=d[u]; <span class="comment">// 记录最小生成树新加的边的边权</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v; <span class="comment">// 通过邻接表直接获得 u 的可达顶点</span></span><br><span class="line">            <span class="comment">// 顶点 v 不在集合 S 中 &amp;&amp; 以 u 为中介点可以使 d[v] 更小</span></span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;d[u]+Adj[u][j].dis&lt;d[v])&#123;</span><br><span class="line">                d[v]=Adj[u][j].dis; <span class="comment">// 松弛，这是与 Dijkstra 不同的地方</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 Dijkstra 相同，这种写法的 prim 算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。其中外层循环共循环 V 次，内层循环寻找 u 也需要 V 次。同样可以使用堆优化降低 prim 算法的时间复杂度。</p>
<h2 id="kruskal-算法-克鲁斯卡尔算法"><a class="markdownIt-Anchor" href="#kruskal-算法-克鲁斯卡尔算法"></a> kruskal 算法 克鲁斯卡尔算法</h2>
<p>kruskal 同样用于计算最小生成树。与 prim 算法不同的是，kruskal 算法使用的是边贪心的策略。</p>
<p><strong>基本思想</strong></p>
<ol>
<li>在初始状态时隐去图中所有的边，这样图中的每个顶点都自成一个连通块。</li>
<li>对所有的边按边权从小到大进行排序。</li>
<li>按边权从小到大测试所有的边，如果当前测试边所连接的两个个顶点不在同一个连通块中，则把这条测试边加入到最小生成树中；否则将边舍弃。</li>
<li>重复执行步骤 3，直到最小生成树中的边数等于总顶点数减 1 或是测试完所有边时结束步骤 4。</li>
<li>当步骤 4 结束时，如果最小生成树的边数小于总顶点数减一，说明该图不连通。</li>
</ol>
<p>简单来说，kruskal 算法的思想就是：每次选择图中边权最小的边，如果边两端的顶点在不同的连通块中，就把这条边加入最小生成树。</p>
<p><strong>编码细节</strong></p>
<ol>
<li>
<p>由于需要判断边的两个端点是否在同一个连通块中，并且需要寻找边权最小的边。所以需要定义一个结构体，里面存放边的两个端点和边权。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v; <span class="comment">// 边的两个端点编号</span></span><br><span class="line">    <span class="keyword">int</span> cost; <span class="comment">// 边权</span></span><br><span class="line">&#125;E[maxe]; <span class="comment">// 最多有 maxe 条边</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义边的排序函数，使边按照边权从小到大排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost&lt;b.cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>**使用并查集表示连通块。**判断边的两个端点是否在同一个连通块中，就可以转换为判断两个端点是否在同一个集合中。</p>
</li>
<li>
<p><strong>将测试边加入最小生成树，可以转换为将测试边的两个端点所在的集合合并。</strong></p>
</li>
</ol>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans=<span class="number">0</span>; <span class="comment">// 表示最小生成树的边权之和</span></span><br><span class="line">    numEdge=<span class="number">0</span>; <span class="comment">// 表示最小生成树的当前边数</span></span><br><span class="line">    将所有的边按照从小到大排序;</span><br><span class="line">    <span class="keyword">for</span>(按边权从小打大枚举所有边)&#123;</span><br><span class="line">        <span class="keyword">if</span>(当前测试边的两个端点在不同的连通块中)&#123;</span><br><span class="line">            将该测试边加入最小生成树中;</span><br><span class="line">            ans+=测试边的边权;</span><br><span class="line">            numEdge++;</span><br><span class="line">            <span class="keyword">if</span>(当前边数 nunEdge 等于顶点数减 <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>kruskal 算法的代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxn=<span class="number">1000</span>; <span class="comment">// 最大的顶点个数</span></span><br><span class="line"><span class="keyword">const</span> maxe=<span class="number">1000</span>; <span class="comment">// 最大边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v; <span class="comment">// 边的两个端点编号</span></span><br><span class="line">    <span class="keyword">int</span> cost; <span class="comment">// 边权</span></span><br><span class="line">&#125;;</span><br><span class="line">edge E[maxe]; <span class="comment">// 图使用 E 来表示</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span>&#123; <span class="comment">// 边的比较函数，边权小的在前，边权大的在后</span></span><br><span class="line">    <span class="keyword">return</span> a.cost&lt;b.cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> father[N]; <span class="comment">// 并查集数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 并查集查询函数，使用路径压缩</span></span><br><span class="line">    <span class="keyword">int</span> a=x; <span class="comment">// 将 x 记录下来，以便从 x 开始压缩查询路径</span></span><br><span class="line">    <span class="keyword">while</span>(x!=father[x])&#123; <span class="comment">// 找到 x 所在集合的根节点并存储在 x 中</span></span><br><span class="line">        x=father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a!=father[a])&#123; <span class="comment">// 从 a 开始压缩路径</span></span><br><span class="line">        <span class="keyword">int</span> z=a;</span><br><span class="line">        a=father[a];</span><br><span class="line">        father[z]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 返回集合的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// kruskal 算法返回最小生成树的边权之和，参数 n 为顶点个数，m 为图的边数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="comment">// 最小生成树的边权之和</span></span><br><span class="line">    <span class="keyword">int</span> numEdge=<span class="number">0</span>; <span class="comment">// 当前生成树的边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">// 假设图中顶点的编号为 [1,n]</span></span><br><span class="line">        father[i]=i; <span class="comment">// 并查集初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(E,E+m,cmp); <span class="comment">// 所有边按照边权从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123; <span class="comment">// 按边权从小到大的顺讯，枚举所有的边</span></span><br><span class="line">        <span class="keyword">int</span> faU=findFather(E[i].u); <span class="comment">// 顶点 u 所在集合的根节点</span></span><br><span class="line">        <span class="keyword">int</span> faV=findFather(E[i].v); <span class="comment">// 顶点 v 所在集合的根节点</span></span><br><span class="line">        <span class="keyword">if</span>(faU!=faV)&#123; <span class="comment">// 如果两个顶点不在同一个连通块中</span></span><br><span class="line">            father[faU]=faV; <span class="comment">// 集合合并，将测试边加入到最小生成树中</span></span><br><span class="line">            ans+=E[i].cost; <span class="comment">// 边权之和增加测试边的边权</span></span><br><span class="line">            numEdge++; <span class="comment">// 当前生成树的边数加一</span></span><br><span class="line">            <span class="keyword">if</span>(numEdge==n<span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 边数等于顶点数减一时结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numEdge!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 图不是连通图，返回 -1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans; <span class="comment">// 返回最小生成树的边权之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kruskal 算法的时间复杂度主要来自于边的排序，因此，其时间复杂度为 O(ElogE)，E 为图中的边数。</p>
<p>显然 kruskal 算法适用于顶点多，边少的情况。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-01 21:09:19" itemprop="dateCreated datePublished" datetime="2020-03-01T21:09:19+08:00">2020-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-04 23:05:59" itemprop="dateModified" datetime="2020-03-04T23:05:59+08:00">2020-03-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h1>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/26/C-C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/C-C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">C++/C 基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-26 17:15:23" itemprop="dateCreated datePublished" datetime="2020-02-26T17:15:23+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-28 10:06:01" itemprop="dateModified" datetime="2020-02-28T10:06:01+08:00">2020-02-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="const-关键字"><a class="markdownIt-Anchor" href="#const-关键字"></a> const 关键字</h1>
<ul>
<li>const 修饰普通变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>a 为常量，只能在声明时赋值，不可再次赋值。指向常量的指针和引用，必须被 const 修饰，这样用于防止通过指针或引用修改该常量。</p>
<ul>
<li>指向常量的指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>const 位于 * 的左边，不能通过指针修改指针指向的值。指向常量的指针，可以指向常量也可以指向普通类型。关键是不能通过指针修改指针指向的值。</p>
<ul>
<li>常指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>const 位于 * 的右边，指针是一个指针常量，指针指向的内存地址不能改变，但可以通过指针修改指针指向的值。</p>
<ul>
<li>指向常量的常指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>const 在 * 的两边都有，指针指向的内存地址不能改变，地址中的值不能通过指针改变。<br />
常指针和指针常量的合并。</p>
<ul>
<li>const 修饰函数参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传值参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    a++; <span class="comment">// 错误，不能在函数中修改 a 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> *a)</span></span>&#123;</span><br><span class="line">    *a=<span class="number">10</span>; <span class="comment">// 错误，不能通过指针修改 a 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> a)</span></span>&#123;</span><br><span class="line">    *a=<span class="number">10</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">10</span>;</span><br><span class="line">    a=&amp;b; <span class="comment">// 错误，不可以改变指针指向的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数参数是一个自定义的对象时，按值传参时会构建临时对象复制参数，一般采用传引用，为了防止参数在函数体内被修改，常用 const 修饰参数。</p>
<ul>
<li>const 修饰函数返回值</li>
</ul>
<ol>
<li>const 修饰基本数据类型，修饰与不修饰作用相同。</li>
<li>const 修饰自定义类型。此时返回一个常量，返回值不能做左值。返回值既不能被赋值，也不能被修改。</li>
<li>const 修饰返回的指针或引用。</li>
</ol>
<ul>
<li>
<p>const 修饰类的成员函数<br />
const 加在 () 后面<br />
const 修饰成员函数，是为了防止成员函数修改调用这个函数的对象的值。一个类中，任何不会修改数据成员的函数都应该声明为 const 类型。const 修饰的成员函数称为常成员函数，常成员函数不能调用非常成员函数，用来防止常成员函数修改类的属性。只有常成员函数能够操作常对象，没有 const 修饰的的成员函数不能用来操作常对象。如果对象的某个属性希望被自己的 const 成员函数修改，则可以用 mutable 修饰该属性。</p>
</li>
<li>
<p>const 修饰引用<br />
const 引用是指向 const 对象的引用。同时，普通的引用是无法绑定到 const 对象上的。为了防止通过普通的引用修改 const 对象。</p>
</li>
</ul>
<h1 id="static-关键字"><a class="markdownIt-Anchor" href="#static-关键字"></a> static 关键字</h1>
<ul>
<li>
<p>静态成员变量<br />
类内成员变量声明前加上关键字 static，该数据成员就是类内的静态数据成员。</p>
</li>
<li>
<p>静态成员变量的特点</p>
</li>
</ul>
<ol>
<li>静态成员变量是该类所有对象共有的。静态成员变量只分配一次内存，由该类的所有对象共享访问。</li>
<li>静态数据成员在全局数据区分配内存，不属于特定的对象，不占用对象的内存。在没有类的实例存在前，静态成员变量就已经存在了。</li>
<li>静态成员变量在初始化时分配内存。静态变量必须初始化，并且只能在类体外进行。初始化时可以赋初值，也可以不赋初值。如果不赋初值，则会被默认初始化。静态数据区的变量都有默认的初始值，动态数据区的变量默认是垃圾值。</li>
<li>static 成员变量与普通 static 变量相同，编译时在静态数据区分配内存，到程序结束时才释放。</li>
<li>静态数据成员初始化时可以不加 static，但必须要有数据类型。</li>
<li>静态数据成员可以通过 &lt;类名&gt;::&lt;静态数据成员名&gt; 访问，不需要通过类的对象。</li>
<li>sizeof 运算不会计算静态成员变量的大小。</li>
</ol>
<ul>
<li>
<p>静态成员函数<br />
静态成员函数是为某一个类服务的。静态成员函数不作用于某个具体的对象。普通成员函数隐含了一个 this 指针，该 this 指针指向类的对象本身。函数调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this 是缺省的。<br />
静态成员函数属于类本身，不作用与具体的对象，因此它不具有 this 指针。静态成员函数不能访问非静态成员变量和非静态成员函数，只能访问其余的静态成员变量和函数。</p>
</li>
<li>
<p>静态成员函数的特点</p>
</li>
</ul>
<ol>
<li>出现在类体外的函数定义不能指定关键字 static</li>
<li>静态成员函数仅可以访问静态成员变量和静态成员函数</li>
<li>静态成员函数不能访问非静态成员函数和非静态成员变量</li>
<li>非静态成员函数可以任意的访问静态成员函数和静态成员变量</li>
</ol>
<ul>
<li>
<p>拷贝构造函数的问题<br />
使用包含静态成员的类时，有时会调用拷贝构造函数生成临时的隐藏的类对象，而这个临时类对象消亡时会调用析构函数，析构函数中可能会修改静态成员变量，但是这些临时对象在创建时却没有执行构造函数中的对静态成员变量修改的操作。此时应当在类中写一个拷贝构造函数，让临时对象的创建使用该拷贝构造函数，在拷贝构造函数中规范拷贝对象时的操作。</p>
</li>
<li>
<p>静态全局变量<br />
在全局变量之前加上 static 关键字。</p>
</li>
<li>
<p>静态全局变量的特点</p>
</li>
</ul>
<ol>
<li>该变量在全局数据区分配内存</li>
<li>未经初始化的静态全局变量有一个默认的初始化值。与之相比，普通变量的默认初始化值是垃圾值。</li>
<li>静态全局变量在声明它的整个文件内都是可见的，在文件外不可见。</li>
<li>对于一个完整的程序，在内存中的分布情况如下：【代码区】、【全局数据区】、【堆区】和【栈区】。一般由 new 产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据，包括函数内部的静态局部数据，存放在全局变量区。</li>
<li>静态全局变量不能被其他文件使用。在其他文件中，可以定义相同名字的变量，不会产生冲突。</li>
</ol>
<ul>
<li>
<p>静态局部变量<br />
在局部变量之前加上 static 关键字，该变量就被定义为一个静态局部变量。<br />
函数中的普通局部变量存放在栈中，函数退出时系统会回收栈的内存，局部变量也就失效了。<br />
有时，我们希望在两次调用之间对局部变量的值进行保存，此时就可以使用静态局部变量。<br />
静态局部变量只在第一次函数调用时初始化一次。且存放在全局数据区，每次调用的值保持到下一次调用。<br />
静态局部变量始终驻留在函数的全局数据区中，直到程序运行结束。但其作用域为局部作用域，当定义它的语句块结束时，其作用域随之结束。</p>
</li>
<li>
<p>静态函数<br />
在函数的返回类型前加上 static 关键字，函数被定义为静态函数。静态函数只在声明它的文件中可见，不能被其他文件使用。其他文件中可以定义同名函数，不会发生冲突。</p>
</li>
</ul>
<h1 id="虚函数与纯虚函数"><a class="markdownIt-Anchor" href="#虚函数与纯虚函数"></a> 虚函数与纯虚函数</h1>
<ul>
<li>
<p>虚函数是实现多态的机制。多态性使得程序调用的函数是在运行时动态决定的，而不是编译时静态决定的。其核心理念是通过基类访问派生类实现的函数。使用一个基类类型的指针或引用指向子类对象，进而调用由子类复写的个性化的虚函数。</p>
</li>
<li>
<p>虚函数，在类的成员方法的声明前加 virtual 关键字。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>纯虚函数，在虚函数的声明后加 “= 0”</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>虚函数表<br />
每一个包含虚函数的类都包含一个虚函数表<br />
虚表是一个指针数组，指针是指向虚函数的函数指针。<br />
虚表是属于类的，而不是属于某个对象，一个类只需要一个虚表即可。同一个类的所有对象公用一个虚表。<br />
为了指定对象的虚表，对象内部包含一个指向虚表的指针。类对象在创建时便拥有了指向虚表的指针，指针会自动指向对象所属类的虚表。<br />
对象的虚表指针指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数。</p>
</li>
<li>
<p>对于虚函数，子类可以重写虚函数，也可以不重写。对于纯虚函数，子类必须重写。</p>
</li>
<li>
<p>当使用类指针调用成员函数时，普通函数由指针类型确定，虚函数由指针指向的实际类型确定。</p>
</li>
<li>
<p>含有纯虚函数的类称为抽象类，它不能生成对象。</p>
</li>
<li>
<p>当基类中的某个成员方法，在大多数情况下都应该由子类提供个性化实现，但基类中也可以提供缺省的备选方案时，该方法设计为虚函数。当基类的某个成员方法，必须由子类提供个性化实现时，应该设计为纯虚函数。</p>
</li>
<li>
<p>构造函数不能是虚函数，析构函数可以是虚函数且推荐设置为虚函数。基类的析构函数是虚函数，可以确保，在使用基类指针销毁派生类对象时，派生类的析构函数能够被调用，因为派生类的虚构函数一般会有释放一些派生类对象独有的内存这样的操作。</p>
</li>
</ul>
<h1 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h1>
<p>函数存放在内存的代码区域，同样具有地址。<br />
函数指针指向的函数一定要保持函数的返回值类型，函数参数个数、类型和函数指针一致。<br />
函数指针可以作为参数传递给函数<br />
还可以构成函数指针数组<br />
类成员函数指针和普通函数指针是不同的。<br />
类成员函数指针要通过 <code>.*</code> 或者 <code>-&gt;*</code> 运算符使用。<br />
类成员函数指针指向类中的非静态成员函数时，必须由类的实例对象调用，用于传递给函数 this 指针。<br />
指向类的静态成员函数的函数指针在声明时可以不加类名。调用时可以不使用类的实例对象。<br />
普通成员的函数指针可以通过 <code>*</code> 运算符使用。</p>
<h1 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数"></a> 内联函数</h1>
<p>内联函数是为了解决程序中函数调用的效率问题。如果函数为内联函数，则在程序编译时，编译器会将程序中出现的内联函数表达式用内联函数体进行替换。是一种空间换时间的操作。内联函数一般都比较小。<br />
内联函数中最好不要使用循环语句，内联函数的定义必须出现在内联函数第一次调用之前，类内部定义的函数是内联函数。</p>
<h1 id="函数签名"><a class="markdownIt-Anchor" href="#函数签名"></a> 函数签名</h1>
<p>C++ 的函数签名包含函数名和函数的参数列表，不包含返回类型。函数签名用于识别不同的函数。</p>
<h1 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h1>
<p>构造函数不需要用户调用，而是在建立对象时自动执行。函数名称与类名相同，没有返回值。<br />
声明类数组时，数组中的每一个元素都会调用一次构造函数。假设数组长度为 n，则会调用 n 次构造函数。<br />
声明类的指针数组时，不会调用类的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cls</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> executeCount;</span><br><span class="line">	cls() &#123;</span><br><span class="line">		executeCount++;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; executeCount &lt;&lt; <span class="string">&quot;  &quot;</span>; <span class="comment">// 输出当前是第几次调用构造函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> cls::executeCount = <span class="number">0</span>; <span class="comment">// 静态成员变量初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cls a[<span class="number">5</span>]; <span class="comment">// 会调用 5 次默认构造函数</span></span><br><span class="line">    cls * b[<span class="number">8</span>]; <span class="comment">// 不会调用构造函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>无参数的构造函数</li>
<li>带参数的构造函数，属于构造函数的重载。构造函数的参数可以有默认初值。</li>
</ol>
<h1 id="拷贝构造函数"><a class="markdownIt-Anchor" href="#拷贝构造函数"></a> 拷贝构造函数</h1>
<p>用于对象复制。函数名与类名一致，参数一般是一个本类型对象的引用。</p>
<ul>
<li>拷贝构造函数调用时机</li>
</ul>
<ol>
<li>对象以传值的方式传入函数参数时。</li>
<li>对象以传值的方式从函数返回时。</li>
<li>使用另一个同类型的对象来初始化新创建的对象时。</li>
</ol>
<ul>
<li>深拷贝与浅拷贝<br />
默认的拷贝构造函数没有处理类的静态数据成员。<br />
浅拷贝是指，在对象复制时，只对对象中的数据成员进行简单的赋值，不会正确处理指针，指针只是简单的指向相同的内存空间。此时，拷贝出来的对象会影响原来的对象。<br />
深拷贝时，对象中的成员变量，不再是简单的赋值，而是重新分配内存空间。</li>
</ul>
<h1 id="指针与引用的区别"><a class="markdownIt-Anchor" href="#指针与引用的区别"></a> 指针与引用的区别</h1>
<ul>
<li>指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元。引用跟原来的变量是同一东西，只不过是原变量的一个别名而已。</li>
<li>有 const 指针，没有 const 引用</li>
<li>指针可以有多级，引用只能由一级</li>
<li>指针可以为空，引用不能为空</li>
</ul>
<h1 id="回车与换行-r-n"><a class="markdownIt-Anchor" href="#回车与换行-r-n"></a> 回车与换行 \r \n</h1>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">ASCII码</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">10</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">13</td>
<td style="text-align:center">回车</td>
</tr>
</tbody>
</table>
<p>在 windows 中：<br />
<code>\r</code> 回车，表示回到当前行的行首，而不会换到下一行。如果接着输出，本行的内容会被覆盖<br />
<code>\n</code> 换行，换到当前位置的下一行，而不会回到行首。<br />
按下键盘回车键相当于输入 <code>\r\n</code></p>
<p>在 Unix 系统中：<br />
<code>\n</code> 会换到下一行的行首。<br />
按下回车键相当于输入 <code>\n</code></p>
<p>在 Mac 中：<br />
<code>\r</code> 会换到下一行的行首。<br />
按下回车键相当于输入 <code>\r</code></p>
<p>一般在程序中写 <code>\n</code> 在 Linux\windows 中都能实现换到下一行的行首的功能。只是在文本文件中，Linux 只有 <code>\n</code>，Windows 中是 <code>\r\n</code>。</p>
<h1 id="标准输入输出"><a class="markdownIt-Anchor" href="#标准输入输出"></a> 标准输入输出</h1>
<ul>
<li>scanf 和 printf<br />
头文件：<br />
<cstdio><br />
输入格式：</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/16/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/16/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">《高性能 MySQL》学习笔记 第四章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-16 17:34:36 / Modified: 20:50:17" itemprop="dateCreated datePublished" datetime="2020-02-16T17:34:36+08:00">2020-02-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第四章-schema-与数据类型优化"><a class="markdownIt-Anchor" href="#第四章-schema-与数据类型优化"></a> 第四章 Schema 与数据类型优化</h1>
<h2 id="临时表"><a class="markdownIt-Anchor" href="#临时表"></a> 临时表</h2>
<p>MySQL 临时表用于保存一些临时数据。临时表只在当前连接可见，当关闭连接时，MySQL 会自动删除表并释放所有空间。</p>
<ul>
<li>
<p>外部临时表</p>
<p>通过 <code>CREATE TEMORPARY TABLE</code> 创建的临时表称为外部临时表。这种临时表的命名可与非临时表相同。同名后，非临时表对当前回话不可见，直到临时表被删除。</p>
</li>
<li>
<p>内部临时表</p>
<p>内部临时表是一种特殊的轻量级临时表，由 MySQL 自动创建，用来存储某些操作的中间结果，达到性能优化的目的。该表一般是 Memory 表。如果中间结果太大超出了 Memory 的限制，或者含有 BLOB 或 TEXT 字段，则临时表会转换为 MyISAM 表。</p>
</li>
</ul>
<h2 id="对象关系映射-object-relation-mapping-简称-omp"><a class="markdownIt-Anchor" href="#对象关系映射-object-relation-mapping-简称-omp"></a> 对象关系映射 Object Relation Mapping 简称 OMP</h2>
<p>面向对象的开发方法是当今企业级应用开发环境中的主流方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现方式。业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多的关联和继承关系。因此，对象-关系映射系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>
<h2 id="实体-属性-值模型-entity-attribute-value-model-eav"><a class="markdownIt-Anchor" href="#实体-属性-值模型-entity-attribute-value-model-eav"></a> 实体-属性-值模型 Entity-attribute-value model EAV</h2>
<blockquote>
<p><a href="%5Bhttps://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model%5D(https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model)">Entity-attribute-value mode-wiki</a></p>
</blockquote>
<p>EAV 模型是一种数据模型。主要用于以较高的空间利用率编码一种特殊实体，该实体在整体上包含很多属性，但是具体到某一个个体时，只有有限个的属性有值，其他的属性都为空。这种实体与数学上的稀疏矩阵很相似。</p>
<p>EAV 表通常是瘦长的。瘦表示表的列很少，长表示表的行很多。</p>
<p>EAV 表通常有三列</p>
<ul>
<li>entity 表示被描述的实体，该列一般是关联到实体定义表的外键。</li>
<li>attribute 该列一般是关联到一个属性定义表的外键。该属性定义表用来定义该属性，表格可能包含如下几种列：属性ID、属性名、属性描述、数据类型和用于辅助输入验证的列，比如，最大字符串长度、正则表达式或这一个包含有效数据的集合。</li>
<li>value 该列存放属性的值</li>
</ul>
<p>使用 EAV 模型的两个例子：医院的病历记录，超市的销售数据。</p>
<p>EAV 使用了行模型。行模型表示一个实体被记录在很多行而不是很多列中，每行通常有三列：entity、attribute 和 value。</p>
<h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24696366">常见范式设计</a></p>
</blockquote>
<ul>
<li>依赖：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>。</li>
<li>完全函数依赖：在一张表中，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>，且对于 X 的任何真子集 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">X&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><mo mathvariant="normal">′</mo></msup><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X&#x27; \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 不成立，那么我们称 Y 完全依赖于 X，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mover><mo><mo>→</mo></mo><mi>F</mi></mover><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\stackrel{F}{\to}Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452010000000001em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452010000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5668699999999998em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>。</li>
<li>部分函数依赖：Y 函数依赖于 X，同时 Y 不完全依赖于 X，则称 Y 部分依赖于 X，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mover><mo><mo>→</mo></mo><mi>P</mi></mover><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\stackrel{P}{\to}Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452010000000001em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452010000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5668699999999998em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>。</li>
<li>传递函数依赖：Z 函数依赖于 Y，且 Y 函数依赖于 X，且 Y 不包含于 X，且 X 不函数依赖于 Y，则称 Z 传递依赖于 X，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mover><mo><mo>→</mo></mo><mi>T</mi></mover><mi>Z</mi></mrow><annotation encoding="application/x-tex">X\stackrel{T}{\to}Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452010000000001em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452010000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5668699999999998em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span>。</li>
<li>码：设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都有完全函数依赖于 K，那么我们称 K 为候选码，简称为码。通常可以这样理解：假如 K 确定的情况下，该表除 K 之外的所有属性的值也就确定，那么 K 就是码。一张表中可以有超过一个码，通常选择其中的一个码作为主码。</li>
<li>主属性：包含在任何一个码中的属性为主属性</li>
<li>判断表格符合那一个范式步骤
<ol>
<li>找出表中的所有码</li>
<li>根据第一步的码，找出所有主属性</li>
<li>除去所有的主属性，剩下的都是非主属性</li>
<li>查看函数依赖</li>
</ol>
</li>
</ul>
<ol>
<li>
<p>第一范式</p>
<p>所有属性都是不可分割的原子值。</p>
<p>数据库表的每一列都是不可分割的原子数据项，不能是集合，数组，记录等非原子数据项。</p>
</li>
<li>
<p>第二范式</p>
<p>在第一范式的基础上，要求非主属性都要<mark>完全</mark>依赖于码。</p>
</li>
<li>
<p>第三范式</p>
<p>任何非主属性不依赖于其他非主键属性。</p>
<p>第三范式是在第二范式的基础上建立起来的，消除了非主属性对于码的传递函数依赖。</p>
</li>
<li>
<p>BC 范式</p>
<p>在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。</p>
</li>
</ol>
<h2 id="选择数据类型的原则"><a class="markdownIt-Anchor" href="#选择数据类型的原则"></a> 选择数据类型的原则</h2>
<ol>
<li>
<p>更小的通常更好</p>
<p>更小的数据类型通常占用更少的存储空间，处理时需要的 CPU 周期更少。</p>
<p>同时要确保没有低估需要存储的值的范围。在 schema 中的多个地方增加数据类型是一个代价很高的操作。</p>
</li>
<li>
<p>简单就好</p>
<p>简单的数据类型操作通常需要更少的 CPU 周期。</p>
<p>使用 MySQL 内建的数据类型存储日期和时间，而不是使用字符串。</p>
<p>使用整形存储 IP 地址。</p>
</li>
<li>
<p>尽量避免 NULL</p>
<p>可为 NULL 是列的默认属性。</p>
<p>通常情况下最好指定 NOT NULL，除非真的需要存储 NULL 值。</p>
<p>包含 NULL 的列，对 MySQL 来说更难优化。</p>
<p>可为 NULL 的列使得索引、索引统计和值比较都更加复杂。</p>
<p>但是，通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小。所以，在调优时，没有必要首先修改这种情况。但是，在设计表格时要尽量避免 NULL。</p>
</li>
<li>
<p>第一步，确定适合的大类型：数字、字符串、时间等。然后确定具体类型。MySQL 为了兼容性支持很多基本数据类型的别名，例如 INTEGER、BOOL 以及 NUMERIC。这些别名不会影响性能。</p>
</li>
</ol>
<h2 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型"></a> 整数类型</h2>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">位数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TINYINT</td>
<td style="text-align:center">8 位</td>
</tr>
<tr>
<td style="text-align:center">SMALLINT</td>
<td style="text-align:center">16 位</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMINT</td>
<td style="text-align:center">24 位</td>
</tr>
<tr>
<td style="text-align:center">INT</td>
<td style="text-align:center">32 位</td>
</tr>
<tr>
<td style="text-align:center">BIGINT</td>
<td style="text-align:center">64 位</td>
</tr>
</tbody>
</table>
<p>可存储的值的范围：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>∼</mo><msup><mn>2</mn><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2^{(N-1)}\thicksim2^{(N-1)}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，N 为位数。</p>
<p>有可选的 UNSIGNED 属性，表示无符号整数。可存储的值的范围：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>∼</mo><msup><mn>2</mn><mi>N</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \thicksim 2^N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，N   为位数。</p>
<p>数据类型决定整数是如何存储的。而整数计算一般使用 64 位的 BIGINT 整数，即使在 32 位环境中也是如此。一些聚合函数是例外，它们使用 DECIMAL 或 DOUBLE 进行计算。</p>
<p>可以为整数类型指定宽度，例如 INT(11)。这对大多数应用没有意义，这不会改变值的合法范围，只是规定了 MySQL 的一些交互工具用来显示字符的个数。对于存储和计算来讲 INT(1) 与 INT(20) 没有区别。</p>
<h2 id="实数类型"><a class="markdownIt-Anchor" href="#实数类型"></a> 实数类型</h2>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">位数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FLOAT</td>
<td style="text-align:center">32 位</td>
</tr>
<tr>
<td style="text-align:center">DOUBLE</td>
<td style="text-align:center">64 位</td>
</tr>
<tr>
<td style="text-align:center">DECIMAL</td>
<td style="text-align:center">128 位</td>
</tr>
</tbody>
</table>
<p>DECIMAL(a,b)</p>
<p>参数说明：a 指定小数点左边和右边可以存储的十进制数字的最大个数。b 指定小数点右边可以存储的十进制数字的最大个数。</p>
<p>DECIMAL 只是一种存储格式，在实际计算中，DECIMAL 会转换为 DOUBLE。</p>
<p>CUP 不支持 DECIMAL 的直接运算，DECIMAL 的运算要在服务器层实现。相对而言，CUP 原生支持的浮点数运算更快。</p>
<p>MySQL 使用 DOUBLE 作为内部浮点计算的类型。</p>
<p>推荐只指定数据类型，不指定精度。</p>
<p>尽量只在对小数进行精确计算时才使用 DECIMAL，例如财务数据。</p>
<p>在数据量比较大时，可以使用 BIGINT 代替 DECIMAL，只需要将 DECIMAL 乘以合适的倍数将其转换为整数即可。这样可以避免浮点数计算精度问题和 DECIMAL 计算代价大的问题。</p>
<h2 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h2>
<p>MySQL 4.1 开始，每个字符串列可以自定义自己的字符集和排序规则，这些东西会很大程度上影响性能。</p>
<h3 id="varchar-和-char-类型"><a class="markdownIt-Anchor" href="#varchar-和-char-类型"></a> VARCHAR 和 CHAR 类型</h3>
<p>这两个数据类型在磁盘和内存中的存储方式与存储引擎的具体实现有关。以下以 InnoDB 和 MyISAM 在磁盘上的存储为例。</p>
<ul>
<li>
<p>VARCHAR</p>
<p>用于存储可变长的字符串。</p>
<p>比定长类型节省空间，因为它仅使用必要的空间。</p>
<p>例外：如果表使用 ROW_FORMAT = FIXED 创建，每一行都会使用定长储存，这会很浪费存储空间。</p>
<p>VARCHAR 需要使用额外的字节记录字符串的长度，如果列的最大长度小于等于 255 字节，则使用 1 个字节记录，否则使用 2 字节。</p>
<p>由于行是变长的，在 UPDATE 时可能使行变得比原来长，这会导致额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间存储，在这种情况下，不同的存储引擎的处理方式不同。InnoDB 会分裂页来使行可以放入页内，MyISAM 会将行拆分成不同的片段存储。</p>
<p>适用 VARCHAR 的情况：</p>
<ol>
<li>字符串列的最大长度比平均长度大很多</li>
<li>列的更新很少</li>
<li>使用了像 UTF-8 这样的复杂字符集，每个字符都使用不同的字节进行存储。</li>
</ol>
<p>MySQL 5.0 及以上在存储和检索时会保留末尾空格。</p>
<p>InnoDB 会把过长的 VARCHAR 存储为 BLOB。</p>
</li>
<li>
<p>CHAR</p>
<p>CHAR 是定长的。MySQL 总是根据定义的字符串长度为 CHAR 分配足够的空间。</p>
<p>存储时，MySQL 会删除所有的末尾空格。</p>
<p>CHAR 值会根据需要使用空格进行填充以便进行比较。</p>
<p>适用 CHAR 的情况：</p>
<ol>
<li>很短的字符串。</li>
<li>所有值都接近同一长度的字符串。比如 MD5 值。</li>
<li>对于经常变更的数据，CHAR 比 VARCHAR 更有效率，因为不容易产生碎片。</li>
</ol>
</li>
</ul>
<p>填充和截取空格的行为在不同的存储引擎中都是一样的，因为这是在服务器层处理的。</p>
<h3 id="binary-和-varbinary"><a class="markdownIt-Anchor" href="#binary-和-varbinary"></a> BINARY 和 VARBINARY</h3>
<p>与 CHAR 和 VARCHAR 很像。</p>
<p>这两个数据类型存储的是二进制的字符串，即存储的是字节码而不是字符。</p>
<p>填充时使用 \0 而不是空格。</p>
<p>二进制比较比字符比较简单很多，也就快很多。</p>
<h3 id="慷慨是不明智的-最好的策略是只分配真正需要的空间"><a class="markdownIt-Anchor" href="#慷慨是不明智的-最好的策略是只分配真正需要的空间"></a> 慷慨是不明智的 最好的策略是只分配真正需要的空间</h3>
<h3 id="blob-和-text-类型"><a class="markdownIt-Anchor" href="#blob-和-text-类型"></a> BLOB 和 TEXT 类型</h3>
<p>用于存储很大的数据。</p>
<p>BLOB 存储二进制数据，没有字符集和排序规则。</p>
<p>TEXT 存储字符数据，有字符集和排序规则。</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符类型</th>
<th style="text-align:center">二进制类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TINYTEXT</td>
<td style="text-align:center">TINYBLOB</td>
</tr>
<tr>
<td style="text-align:center">SMALLTEXT(TEXT)</td>
<td style="text-align:center">SMALLBLOB(BLOB)</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMTEXT</td>
<td style="text-align:center">MEDIUMBLOB</td>
</tr>
<tr>
<td style="text-align:center">LONGTEXT</td>
<td style="text-align:center">LONGBLOB</td>
</tr>
</tbody>
</table>
<p>InnoDB 在 BLOB 或 TEXT 太大时，使用专用的外部存储区域存储，在行内只存储一个指向外部存储区域的指针。</p>
<p>只对每列最前的 max_sort_lenght 字节做排序而不是对整个字符串。</p>
<p>不能将 BLOB 和 TEXT 全部长度的字符串进行索引，也不能使用这些索引消除排序。</p>
<h3 id="使用枚举类型代替字符串类型"><a class="markdownIt-Anchor" href="#使用枚举类型代替字符串类型"></a> 使用枚举类型代替字符串类型</h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/14/Manacher-%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/14/Manacher-%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Manacher 算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-14 17:21:49" itemprop="dateCreated datePublished" datetime="2020-02-14T17:21:49+08:00">2020-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-17 15:50:50" itemprop="dateModified" datetime="2020-02-17T15:50:50+08:00">2020-02-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h1>
<p>查找一个字符串的最长回文子串的线性算法</p>
<h1 id="算法原理与实现"><a class="markdownIt-Anchor" href="#算法原理与实现"></a> 算法原理与实现</h1>
<ol>
<li>
<p>将长度为奇数和偶数的回文串一起处理</p>
<p>Manacher 使用一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑。具体做法是，在原字符串的每个相邻字符中间插入一个分隔符，同时在首尾也要各添加一个分隔符。要求分隔符不在原字符串中出现。如下图所示，其中，原始字符串为 S，转换后的字符串为 T：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxczgeenuj34a10x3jvu.jpg" alt="" /></p>
</li>
<li>
<p>使用额外空间存储必要信息 Len 数组</p>
<p>辅助数组 Len 是算法的核心。</p>
<p>Len[i] 表示以字符 T[i] 为中心的最长回文子串的最右端字符到字符 T[i] 的字符个数。</p>
<p>比如，以 T[i] 为中心的最长回文子串是 T[l,r]，则 Len[i] = r - i + 1。</p>
<p>对于上面的例子，可以得出如下的 Len 数组：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxdeb6mxqj33uo0shjvo.jpg" alt="" /></p>
<p>Len 数组的性质：Len[i] - 1 等于该回文子串在原字符 S 中的长度。</p>
<p>证明如下：首先，在转换得到的字符串 T 中，所有的回文串的长度都为奇数。那么，对于以字符 T[i] 为中心的最长回文子串，其长度就是 2 × Len[i] -1。经过观察可知，T 中的所有回文子串，其中分隔符的数量一定比其他字符的数量多一。所以， 2 × Len[i] -1 的长度中，有 Len[i] 个分隔符，剩下 Len[i] - 1 个字符来自原字符串。综上所述，该回文串在原字符串中的长度为 Len[i] - 1。</p>
</li>
<li>
<p>Len 数组的计算</p>
<p>从左向右依次计算 Len 数组。当计算 Len[i] 时，Len[0] ~ Len[i-1] 已经计算完毕。</p>
<p>设 P 为之前计算中最长回文子串的右端点的最大值。并且，设取得这个最大值的位置为 Po。</p>
<p>分为两种情况计算：</p>
<ol>
<li>
<p>i &lt; P</p>
<p>找到 i 相对于 Po 的对称位置，设为 j。再分为三种情况。</p>
<ul>
<li>
<p>Len[j] &lt; P - i + 1 如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxdx60uxbj34r827w0ys.jpg" alt="" /></p>
<p>此时说明，以 j 为中心的回文串一定在以 Po 为中心的回文串的内部。j 和 i 关于位置 Po 对称，并且，由回文串的定义可知，一个回文串反过来还是一个回文串。所以，以 i 为中心的回文串的长度至少和以 j 为中心的回文串的长度一样长，即 Len[i] ≥ Len[j]。由对称性可知，Len[i] = Len[j]。</p>
</li>
<li>
<p>Len[j] &gt; P - i + 1 如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxe6lr6amj34r827wwki.jpg" alt="" /></p>
<p>此时，Len[i] = P - i + 1</p>
<p>证明如下：由图可知，Len[i] ≥ P - i + 1。</p>
<p>假设 Len[i] &gt; P - i + 1，则 Len[Po] &gt; P - Po +1，即以 Po 为中心的回文子串是可以更长的，这与 Len[Po] 的原值不符，所以假设错误。</p>
<p>综上所述，Len[i] = P - i + 1</p>
</li>
<li>
<p>Len[j] = P - i + 1 如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbxgfvlv0pj30h2083wed.jpg" alt="" /></p>
<p>此时，以 i 为中心的回文串可能会延伸到 P 之外，对于大于 P 的部分，我们还未匹配。因此，要从 P + 1 开始一个一个的匹配，直到发生失配，得出 Len[i] 的值。</p>
</li>
</ul>
</li>
<li>
<p>i &gt;= P 如下图所示：<br />
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbzf37mcc7j348t1g1wgo.jpg" alt="" /><br />
<img src="http://ww1.sinaimg.cn/large/006XJF4Oly1gbzfxdznfuj30hl07mglf.jpg" alt="" /><br />
这两种情况下，对于中点为 i 的回文串还一点都没有匹配。因此，只能一个一个的匹配得出 Len[i] 的值。</p>
</li>
</ol>
</li>
<li>
<p>时间复杂度分析</p>
<p>该算法只有在遇到没有匹配的位置时才进行匹配，已经匹配过的位置不再匹配。因此，对于字符串 T 中的每一个位置，只进行一次匹配，算法整体复杂度为 O(n)，其中 n 为字符串 T 的长度。由于 T 的长度实际上是原字符串 S 的长度的两倍，所以时间复杂度依旧是线性的。</p>
</li>
<li>
<p>算法实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串 s 中的任意一个最长回文子串 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">     <span class="comment">// 初始化辅助字符串</span></span><br><span class="line">     <span class="built_in">string</span> T=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">         T+=s.substr(i,<span class="number">1</span>)+<span class="string">&quot;#&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 初始化辅助数组</span></span><br><span class="line">     <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Len</span><span class="params">(T.length())</span></span>;</span><br><span class="line">     Len[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> aimIndex=<span class="number">0</span>,Po=<span class="number">0</span>,P=<span class="number">0</span>; <span class="comment">// aimIndex 存放最长回文子串的中心字符在 T 中的下标</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;T.length();i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(i&lt;P)&#123;</span><br><span class="line">             <span class="keyword">int</span> j=Po-i+Po;</span><br><span class="line">             <span class="keyword">int</span> threshold=P-i+<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span>(Len[j]&lt;threshold)&#123;</span><br><span class="line">                 Len[i]=Len[j];</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Len[j]&gt;threshold)&#123;</span><br><span class="line">                 Len[i]=P-i+<span class="number">1</span>;</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Len[j]==threshold)&#123;</span><br><span class="line">                 <span class="keyword">int</span> left=i-P+i<span class="number">-1</span>;</span><br><span class="line">                 <span class="keyword">int</span> right=P+<span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;T.length()&amp;&amp;T[left]==T[right])&#123;</span><br><span class="line">                     right++;</span><br><span class="line">                     left--;</span><br><span class="line">                 &#125;</span><br><span class="line">                 Len[i]=right-i;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> left=i<span class="number">-1</span>;</span><br><span class="line">             <span class="keyword">int</span> right=i+<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;T.length()&amp;&amp;T[left]==T[right])&#123;</span><br><span class="line">                 right++;</span><br><span class="line">                 left--;</span><br><span class="line">             &#125;</span><br><span class="line">             Len[i]=right-i;</span><br><span class="line">         &#125;</span><br><span class="line">         aimIndex=Len[i]&gt;=Len[aimIndex]?i:aimIndex;</span><br><span class="line">         <span class="keyword">if</span>(i+Len[i]<span class="number">-1</span>&gt;P)&#123;</span><br><span class="line">             P=i+Len[i]<span class="number">-1</span>;</span><br><span class="line">             Po=i;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 从 T 中提取最长回文子串</span></span><br><span class="line">     <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=aimIndex-Len[aimIndex]+<span class="number">1</span>;i&lt;=aimIndex+Len[aimIndex]<span class="number">-1</span>;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(T[i]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">             ans+=T.substr(i,<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/02/01/leetcode-%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/01/leetcode-%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">leetcode 刷题经验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-01 16:20:40" itemprop="dateCreated datePublished" datetime="2020-02-01T16:20:40+08:00">2020-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-05 21:20:04" itemprop="dateModified" datetime="2020-02-05T21:20:04+08:00">2020-02-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c-不要用局部静态变量-在多个测试用例的调用过程中局部静态变量只会被初始化一次导致测试用例之间的结果相互影响出现-bug"><a class="markdownIt-Anchor" href="#c-不要用局部静态变量-在多个测试用例的调用过程中局部静态变量只会被初始化一次导致测试用例之间的结果相互影响出现-bug"></a> C++ 不要用局部静态变量。在多个测试用例的调用过程中，局部静态变量只会被初始化一次，导致测试用例之间的结果相互影响，出现 bug。</h1>
<h1 id="想要所有的递归函数使用同一个变量有三种方法全局变量局部静态变量参数传引用"><a class="markdownIt-Anchor" href="#想要所有的递归函数使用同一个变量有三种方法全局变量局部静态变量参数传引用"></a> 想要所有的递归函数使用同一个变量有三种方法，全局变量，局部静态变量，参数传引用。</h1>
<h1 id="string-转-int"><a class="markdownIt-Anchor" href="#string-转-int"></a> string 转 int</h1>
<ol>
<li>使用 C++ 11 中的全局函数 std::to_string</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用 sstream 中定义的字符串流对象来实现</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ostringstream</span> os; <span class="comment">// 构造一个输出字符串流，流的内容为空</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">12</span>;</span><br><span class="line">os&lt;&lt;i; <span class="comment">// 向输出字符串流中输入 int 型整数 i 的内容</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;os.str()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1 id="c-stringstream-使用"><a class="markdownIt-Anchor" href="#c-stringstream-使用"></a> C++ stringstream 使用</h1>
<p>C++ 的输入输出分为三种</p>
<ol>
<li>基于控制台的 I/O</li>
</ol>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>istream 从流中读取、ostream 写到流中去、iostream 对流进行读写</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>基于文件的 I/O</li>
</ol>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>fstream</td>
<td>ifstream 从文件中读取、ofstream 写到文件中去、fstream 对文件进行读写</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>基于字符串的 I/O</li>
</ol>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>sstream</td>
<td>istringstream 从 string 对象中读取、ostringstream 写到 string 对象中去、stringstream 对 string 对象进行读写</td>
</tr>
</tbody>
</table>
<p>ostringstream、istringstream、stringstream 这三个类包含在 sstream.h 文件中。<br />
istringstream 类用于执行 C++ 风格的串流的输入操作。<br />
ostringstream 类用于执行 C++ 风格的串流的输出操作。<br />
stringstream 类同时支持 C++ 风格的串流的输入输出操作。</p>
<ul>
<li>istringstream 类<br />
从字符串中提取数据，支持 &gt;&gt; 操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">istringstream</span>::<span class="built_in">istringstream</span>(<span class="built_in">string</span> str); <span class="comment">// 构造函数原型</span></span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">istr</span><span class="params">(<span class="string">&quot;1 56.3&quot;</span>)</span></span>; <span class="comment">// 初始化一个 istringstream 对象</span></span><br><span class="line">istr.str(<span class="string">&quot;1100 2.3&quot;</span>); <span class="comment">// 把字符串写入 istr 中。可以使用分界点获取不同的数据，完成字符串到其他数据类型的转换。</span></span><br><span class="line">istr.str(); <span class="comment">// 使 istringstream 返回一个字符串</span></span><br><span class="line"><span class="comment">// 举例 把字符串转换为其他数据类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">istr</span><span class="params">(<span class="string">&quot;1 56.7&quot;</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;istr.str()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//直接输出字符串的数据 &quot;1 56.7&quot;   </span></span><br><span class="line">      </span><br><span class="line">    <span class="built_in">string</span> str = istr.str();<span class="comment">//函数str()返回一个字符串   </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="keyword">double</span> d;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//以空格为界，把istringstream中数据取出，应进行类型转换   </span></span><br><span class="line">    istr&gt;&gt;n;<span class="comment">//第一个数为整型数据，输出1   </span></span><br><span class="line">    istr&gt;&gt;d;<span class="comment">//第二个数位浮点数，输出56.7   </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//假设换下存储类型   </span></span><br><span class="line">    istr&gt;&gt;d;<span class="comment">//istringstream第一个数要自动变成浮点型，输出仍为1   </span></span><br><span class="line">    istr&gt;&gt;n;<span class="comment">//istringstream第二个数要自动变成整型，有数字的阶段，输出为56   </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//测试输出   </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/01/30/SQL-%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/SQL-%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">SQL 命令学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-30 20:41:24 / Modified: 22:52:47" itemprop="dateCreated datePublished" datetime="2020-01-30T20:41:24+08:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-命令"><a class="markdownIt-Anchor" href="#mysql-命令"></a> MySQL 命令</h1>
<ul>
<li>登录本机的 MySQL 数据库<br />
mysql -u root -p</li>
<li>登录 MySQL 服务器<br />
mysql -h 主机名 -u 用户名 -p<br />
-h：指定客户端需要登陆的 MySQL 主机名，登录本机时可以省略。<br />
-u：登录的用户名<br />
-p：告诉服务器将会使用一个密码登录。如果密码为空，可以忽略此选项。</li>
<li>创建新用户<br />
MySQL 默认使用严格模式，禁止使用 INSERT 命令直接向 mysql 数据库的 user 表中插入新行。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> username<span class="variable">@host</span> indentified <span class="keyword">by</span> <span class="string">&#x27;password&#x27;</span>; <span class="operator">/</span><span class="operator">/</span> 创建用户，没有任何权限</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> username<span class="variable">@host</span>; <span class="operator">/</span><span class="operator">/</span> 查询用户权限</span><br></pre></td></tr></table></figure>
<p>username 和 host 用 @ 符号分割。host 指明用户登陆 MySQL 服务器的主机。host 为 % 时，表示用户可以从任何主机登陆 MySQL 服务器。</p>
<ul>
<li>向用户授予权限<br />
GRANT 语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privilege,[privilege],.. <span class="keyword">ON</span> privilege_level </span><br><span class="line"><span class="keyword">TO</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> [IDENTIFIED <span class="keyword">BY</span> password]</span><br><span class="line">[REQUIRE tsl_option]</span><br><span class="line">[<span class="keyword">WITH</span> [GRANT_OPTION <span class="operator">|</span> resource_option]];</span><br></pre></td></tr></table></figure>
<p>[] 内的内容为可选选项。<br />
GRANT 关键字之后可以指定一个或多个权限。权限之间以逗号分隔。<br />
privilege_level 指定权限级别。MySQL 支持全局 <code>*.*</code> 权限，数据库 <code>database.*</code> 权限，表 <code>database.table</code> 权限和列权限。使用列权限时，必须在每个权限之后用逗号分隔列名。<br />
放置要授予权限的用户。如果用户已存在，则 GRANT 语句修改其权限。如果不存在，则 GRANT 语句将创建一个新用户。可选的 IDENTIFIED BY 允许为新用户设置密码。<br />
REQUIRE tsl_option 指定用户是否必须通过安全连接连接到数据库<br />
WITH GRANT OPTION 子句允许此用户授予其他用户权限。<br />
RESOURCE OPTION 子句用于分配 MySQL 服务器的资源。例如，设置用户每小时可以使用多少个连接或语句。<br />
使用 GRANT 语句必须要有 GRANT OPTION 权限。如果启用了 read_only 系统变量，则需要具有 SUPER 权限才能执行 GRANT 语句。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/01/30/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">《高性能 MySQL》学习笔记 第一章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 20:36:55" itemprop="dateCreated datePublished" datetime="2020-01-30T20:36:55+08:00">2020-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-14 12:12:09" itemprop="dateModified" datetime="2020-06-14T12:12:09+08:00">2020-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-的架构"><a class="markdownIt-Anchor" href="#mysql-的架构"></a> MySQL 的架构</h1>
<p>最上层 服务器层</p>
<p>第二层 查询执行引擎<br />
大多数 MySQL 的核心服务功能位于这一层，比如：查询解析、分析、优化、缓存以及所有的内置函数。所有跨存储引擎的功能也都位于这一层，比如：存储过程、触发器、视图等。</p>
<p>第三层 存储引擎<br />
存储引擎负责 MySQL 中数据的存储与提取。第二层通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使这些差异对上层的查询过程透明。<br />
存储引擎不会解析 SQL 语句。InnoDB 是个例外，它会解析外键，因为 MySQL 服务器中没有实现解析外键这一功能。<br />
存储引擎之间不会相互通信，只是简单的响应上层的请求。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/30/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD-MySQL%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/01/26/JavaScript-%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/26/JavaScript-%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JavaScript 学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-26 15:29:07 / Modified: 15:32:33" itemprop="dateCreated datePublished" datetime="2020-01-26T15:29:07+08:00">2020-01-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="javascript-是大小写敏感的"><a class="markdownIt-Anchor" href="#javascript-是大小写敏感的"></a> JavaScript 是大小写敏感的</h1>
<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1>
<ul>
<li>七种基本数据类型
<ul>
<li>Boolean 有两个值，分别为 true 和 false</li>
<li>null 表明 null 值的关键字</li>
<li>undefined 特殊关键字，表示变量未定义时的属性</li>
<li>Number 整数或浮点数</li>
<li>BigInt 任意精度的整数</li>
<li>String 字符串</li>
<li>Symbol 一种实例唯一且不可更改的数据类型</li>
</ul>
</li>
<li>Object 对象</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hespoon.github.io/2020/01/23/C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hespoon">
      <meta itemprop="description" content="全心全意的投入生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spirit">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">C++ 实现一个 Web 服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-23 16:12:00 / Modified: 21:35:01" itemprop="dateCreated datePublished" datetime="2020-01-23T16:12:00+08:00">2020-01-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="web-服务器"><a class="markdownIt-Anchor" href="#web-服务器"></a> Web 服务器</h1>
<p>Web 服务器是 HTTP 请求的应答方。</p>
<h1 id="cdn-content-delivery-network"><a class="markdownIt-Anchor" href="#cdn-content-delivery-network"></a> CDN Content Delivery Network</h1>
<p>内容分发网络。依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，挑个用户访问速度和命中率。</p>
<h1 id="waf-web-appalication-firewall"><a class="markdownIt-Anchor" href="#waf-web-appalication-firewall"></a> WAF Web Appalication Firewall</h1>
<p>网络应用防火墙。通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。它是应用层面的防火墙，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止 SQL 注入、跨站脚本等攻击。</p>
<h1 id="uri-uniform-resource-identifier"><a class="markdownIt-Anchor" href="#uri-uniform-resource-identifier"></a> URI Uniform Resource Identifier</h1>
<p>统一资源标识符。使用 URI 可以唯一的标记互联网上的资源。</p>
<h1 id="url-uniform-resource-locator"><a class="markdownIt-Anchor" href="#url-uniform-resource-locator"></a> URL Uniform Resource Locator</h1>
<p>统一资源定位符。它是 URI 的一个子集。<br />
URL 分析 <code>http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument</code><br />
<code>http://</code> 是方案或协议，该部分告诉浏览器使用何种协议。</p>
<h1 id="urn-uniform-resource-name"><a class="markdownIt-Anchor" href="#urn-uniform-resource-name"></a> URN Uniform Resource Name</h1>
<p>统一资源名称。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hespoon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">hespoon</p>
  <div class="site-description" itemprop="description">全心全意的投入生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hespoon" title="GitHub → https://github.com/hespoon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hezaojian@gmail.com" title="E-Mail → mailto:hezaojian@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fas fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hespoon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">157k</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        


  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1279024191&web_id=1279024191"></script>
  </div>






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
