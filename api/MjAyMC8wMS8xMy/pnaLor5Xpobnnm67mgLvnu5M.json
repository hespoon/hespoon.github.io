{"title":"面试项目总结","date":"2020-01-13T11:06:42.000Z","date_formatted":{"ll":"Jan 13, 2020","L":"01/13/2020","MM-DD":"01-13"},"link":"2020/01/13/面试项目总结","updated":"2020-01-17T01:14:57.878Z","content":"<h1 id=\"余大佬的面试经验\">余大佬的面试经验<a href=\"2020/01/13/面试项目总结#余大佬的面试经验\"></a></h1><ul>\n<li>多刷算法题</li>\n<li>啃《高级 Unix 编程》</li>\n<li>掌握基本 Linux 知识</li>\n<li>掌握常见的协议，如 http、tcp 之类的</li>\n<li>网络安全，如 CSRF、XSS</li>\n<li>项目经验会问项目设计相关内容</li>\n<li>研究 LevelDB</li>\n<li>用 C++ 实现一个 http 服务器</li>\n<li>熟练使用 epoll 可以保证有话题聊</li>\n<li>消息队列及常见消息中间件</li>\n<li>问道不会的直接说不会，不会扣分</li>\n<li>算法题最难到动态规划</li>\n<li>每一面都会问算法问题</li>\n</ul>\n<h1 id=\"计算机网络\">计算机网络<a href=\"2020/01/13/面试项目总结#计算机网络\"></a></h1><ul>\n<li>TCP 协议 Transmission Control Protocol</li>\n<li>TCP 是传输层的协议，解决传输的可靠、有序、无丢失和不重复。</li>\n<li>面向连接的，每条 TCP 连接只有两个端点</li>\n<li>全双工通信，通信双发在任何时候都能发送数据，有缓存，用于临时存放双向通信数据</li>\n<li>面向字节流，TCP 将应用程序交付的数据视为一串无结构的字节流</li>\n<li>TCP 首部最短 20B。<ul>\n<li>源端口，目的端口各占 2B。序号字段 4B，每个字节都会编号。</li>\n<li>确认字段 4B，是期望收到的报文段数据的第一个字节的序号</li>\n<li>数据偏移，4 位。单位是 4B。表示首部的长度</li>\n<li>保留字段 6 位</li>\n<li>6 个状态位。URG 紧急位、ACK 确认位、PSH 推送位、RST 复位位、SYN 同步位、FIN 终止位</li>\n<li>窗口字段。指出现在允许对方发送的数据量，单位为字节。</li>\n<li>校验和。 2B，校验首部和数据两部分，计算时要加上伪首部。</li>\n<li>紧急字段指针，2B。指出本报文段中紧急数据共有多少字节。</li>\n<li>选项字段，长度可变。</li>\n<li>填充字段。使头部的长度为 4B 的整数倍。</li>\n</ul>\n</li>\n<li>建立连接的 3 次握手<ul>\n<li>SYN=1，seq=x，不含应用层数据，消耗一个序号</li>\n<li>SYN=1，ACK=1，ack=x+1，seq=y，不含应用层数据，消耗一个序号，服务器为连接分配资源，因此易受 SYN 洪泛攻击</li>\n<li>ACK=1，seq=x+1，ack=y+1，可以开始携带应用层数据，客户端为连接分配资源</li>\n<li>为何要三次握手？为了解决网络中存在延迟的重复分组。比如，客户端发送了一个连接请求，但在网络中长时间的滞留了，以至于延迟到连接结束后的某个时间到达了服务器。服务器会误以为这是一个新的连接请求，然后响应该请求并发出确认，为连接分配资源。如果不采用三次握手，客户端不理睬服务器的确认，不会向服务器传输数据，因此服务器的资源就被浪费了。</li>\n</ul>\n</li>\n<li>断开连接的 4 次挥手<ul>\n<li>FIN=1，seq=u，客户端主动请求断开连接</li>\n<li>ACK=1，seq=v，ack=u+1，此时客户端到服务器的连接已经释放了，TCP 处于半关闭状态，服务器发送数据，客户端依旧要接收。客户端不能发送数据，但可以发送确认报文。</li>\n<li>FIN=1，ACK=1，seq=w，ack=u+1，此时服务器请求释放连接</li>\n<li>ACK=1，seq=u+1，ack=w+1，客户端收到服务器发来的连接释放报文后，必须要发出确认，然后等待 2 个报文最大生存时间后关闭连接。服务器端在接受到客户端的确认报文后就断开连接。 </li>\n<li>为何要四次挥手？因为在客户端主动要求断开连接后，服务器端还可能存在需要发送的数据，要等这些数据发送完后，再断开 TCP 连接。</li>\n</ul>\n</li>\n<li>TCP 可靠传输<ul>\n<li>TCP 通过校验机制保证传输的报文段没有差错</li>\n<li>TCP 通过首部的序号字段保证数据能够有序的提交给应用层，对每个字节进行编号，同时会丢弃重复数据。</li>\n<li>TCP 通过首部的确认号表示期望收到的下一报文段数据的第一个字节的序号，发送方会在缓存中存储那些已经发送但未确认的报文段，以便在需要时重传。使用累计确认</li>\n<li>TCP 重传。<ul>\n<li>超时重传。TCP 为每一个发送的报文段都设置一个计时器。计时器设置的重传时间到期但还没有收到确认，就要重传这一报文段。超时重传时间 RTO，加权平均往返时间 RTTs，RTT 的偏差的加权平均值 RTTd。RTO = RTTs + 4 × RTTd，RTTs = ( 1 - α ) × 旧 RTTs + α × 新 RTT 样本，RTTd = ( 1 - β ) × 旧 RTTd + β × |RTTs - 新 RTT 样本|。α 和 β 都是小于 1 大于 0 的系数。第一个 RTTs 等于测量到的 RTT，第一个 RTTd 等于测量到的 RTT 的值的一半。</li>\n<li>冗余 ACK<br>发送方可以通过冗余 ACK 来检测丢包情况。TCP 规定，每当接收方收到比期望序号大的失序报文段时，就发送一个冗余 ACK，指明下一个期待字节的序号。当发送方收到对同一报文段的三个冗余 ACK 时，就认为该报文段已经丢失。冗余 ACK 也用在了拥塞控制中。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>TCP 流量控制<ul>\n<li>TCP 提供一种基于滑动窗口协议的流量控制机制。</li>\n<li>接收方根据自己缓存的大小，动态调整接收窗口的大小，就是调整头部中的窗口字段。限制发送方的发送速率。</li>\n<li>发送方根据当前网络的拥塞情况调整拥塞窗口的大小。发送方的发送窗口取接收窗口和拥塞窗口两者中的最小值。</li>\n</ul>\n</li>\n<li>TCP 拥塞控制<ul>\n<li>两个窗口，接收窗口和拥塞窗口。发送窗口 = min(接受窗口，拥塞窗口)</li>\n<li>四种算法，慢开始、拥塞避免、快重传、快恢复。四种算法是用来维护拥塞窗口的。<ul>\n<li>慢开始。刚开始发送报文段时，令拥塞窗口 = 1，即一个最长报文段的大小。每收到一个对新报文段的确认后，将拥塞窗口的值加 1，就是增大一个 MSS。一般每经过一个传输轮次，拥塞窗口的大小就会翻倍。慢开始一直把拥塞窗口增加到一个阈值后，就改用拥塞避免算法。</li>\n<li>拥塞避免。发送端的拥塞窗口每经过一个 RTT 就增加 1，就是开始线性增加。</li>\n<li>网络拥塞处理<ul>\n<li>超时<br>当发送方检测到超时时，就将慢开始阈值设为当前拥塞窗口大小的一半，但不能小于 2，并将拥塞窗口的大小设为一个 MSS。然后开始执行慢开始算法。这样可以快速减少发送方发到网络中的分组数。</li>\n</ul>\n</li>\n<li>快重传<br>当发送方连续收到三个冗余 ACK 时，就直接重传接收方未收到的报文段，不用等到超时。</li>\n<li>快恢复<br>当发送方收到三个冗余 ACK 时，就将慢开始阈值设为当前拥塞窗口的一半，将拥塞窗口设为改变后的慢开始阈值，然后执行拥塞避免算法。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>UDP 协议，User Datagram Protocol</li>\n<li>UDP 的优点<ul>\n<li>UDP 无需建立连接，所以没有建立连接带来的延时，速度比较快。</li>\n<li>UDP 不用维护连接状态，就是说不用维护发送接收缓存，不用记录确认序号和拥塞控制参数，消耗的资源就小一些。</li>\n<li>分组头部开销小，只有 8B。</li>\n<li>发送方的应用层能够更好的控制要发送的数据和发送时间。因为 UDP 没有拥塞控制，所以网络中的拥塞不会影响发送方的发送效率。</li>\n</ul>\n</li>\n<li>UDP 应用<ul>\n<li>一次性传输数据较少的应用。比如 DNS。</li>\n<li>多媒体应用。比如实时视频会议。可靠的数据传输对这些应用来说不是最重要的。</li>\n</ul>\n</li>\n<li>UDP 不保证可靠交付，数据的可靠性要通过应用层来完成。</li>\n<li>UDP 面向报文，将应用层传下来的报文添加首部后就交给网络层，将网络层传上来的报文去除首部后就交给应用层。</li>\n<li>UDP 数据报首部<ul>\n<li>2B 的源端口号。需要对方回复时才会使用。</li>\n<li>2B 的目的端口号。</li>\n<li>2B 的长度标记，单位为 1B</li>\n<li>2B 的校验和。是可选的。计算校验和时要在数据报之前添加 12B 的伪首部。校验整个数据报。</li>\n</ul>\n</li>\n<li>TCP 与 UDP 的区别<ol>\n<li>TCP 是有连接的，UDP 是无连接的</li>\n<li>TCP 是可靠的，UDP 是不可靠的。接收方不会对 UDP 报文发送确认报文。</li>\n<li>TCP 是面向字节流的，UDP 是面向报文的。TCP 发送报文时以字节为单位，应用层传来的数据报可拆分。UDP 不能拆分数据报。</li>\n<li>TCP 有拥塞控制机制，UDP 没有。</li>\n<li>TCP 首部开销大，UDP 首部开销小。</li>\n<li>UDP 不需要维护连接状态，消耗资源小。</li>\n<li>TCP 只支持点对点通信。UDP 可以一对一、一对多、多对一、多对多</li>\n</ol>\n</li>\n<li>如何选择 TCP 与 UDP<br>对实时性要求高，对可靠传输要求低时，一般选用 UDP。比如 DNS 服务，直播。对可靠性要求高时用 TCP。HTTP 协议一般都用 TCP。HTTP3 使用了基于 UDP 协议的QUIC 协议。可能是因为现在网络环境越来越好了吧，设备本身越来越可靠，协议上就可以偷些懒。</li>\n<li>TCP 粘包<ul>\n<li>指发送方发送的若干数据包在到达接收方时粘成了一包。从接收方缓存来看，后一包数据的头紧挨着前一包数据的尾。如果粘包是同一数据的不同部分，可以不处理。如果粘包之间没有关系，此时就必须要使用合理的拆包机制将包分开。</li>\n<li>粘包原因<ol>\n<li>发送方默认使用 Nagle 算法，将多次间隔较小，数据量较小的数据报合并成一个数据量大的数据报发送，用于减少网络中的报文段，尽可能的利用网络带宽。</li>\n<li>接收方读取接收缓存的速度比 TCP 写入缓存的速度慢。</li>\n</ol>\n</li>\n<li>解决方法<ul>\n<li>发送方可以尝试关闭 Nagle 算法。接收方可以在应用层处理。将接收缓存的数据全部读完后，再分组。可以通过开始符和结束符的方式分组，也可以在数据报数据部分的开始部分记录数据的长度。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>HTTP HyperText Transfer Protocol<ul>\n<li>HTTP 由两个程序实现，一个客户端程序，一个服务器程序。</li>\n<li>URL 地址包含两部分，存放文件的服务器地址和文件的存放路径</li>\n<li>HTTP 使用 TCP 作为传输协议，应用通过套接字接口将 HTTP 请求发给 TCP 连接，同时也从套接字接口中接受响应信息。</li>\n<li>持续连接。客户端与服务器在一个相当长的时间范围内通信时，所有的请求和相应都通过一个 TCP 连接发送，这种模式称为持续连接。</li>\n<li>非持续连接。客户端与服务器在一个相当长的时间范围内通信时，每个请求和相应都通过一个单独的 TCP 连接发送。</li>\n<li>HTTP 默认使用持续连接，也可以使用非持续连接。</li>\n<li>HTTP 客户端进程运行在 80 号端口。</li>\n<li>非持续连接中的 TCP 连接可以是串行的也可以是并行的。</li>\n<li>HTTP 有两种报文，请求报文和相应报文。HTTP 的报文是明文传输。是无状态的，服务器不会记录客户端的任何信息。<ul>\n<li>请求报文<ul>\n<li>请求报文的第一行叫做请求行，后续的行叫做首部行。</li>\n<li>请求行包含三个字段。方法字段、URL 字段和 HTTP 版本字段。</li>\n<li>首部行 Host 指明了对象所在的主机</li>\n<li>首部行 Connection 指明了是使用持续连接还是非持续连接</li>\n<li>首部行 User-agent 指明了用户代理，即向服务器发送请求的浏览器的类型</li>\n<li>首部行后有一个空行。空行后是请求的实体。</li>\n<li>GET 方法用与获取服务器内容，向服务器传递的参数加在 URL 中，只允许 ASCII 字符，有长度限制。请求的实体为空。</li>\n<li>GET 方法是幂等的。幂等是指，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。</li>\n<li>POST 方法一般用来向指定的资源提交数据进行处理请求，如上传表单和文件。数据包含在请求体中。</li>\n<li>POST 方法是不幂等的。</li>\n<li>HEAD 方法用于向服务器索要与 GET 请求相一致的响应，但是响应体不返回，只返回响应消息的头部。</li>\n<li>PUT 方法用于向指定资源位置上传其最新内容，是幂等的。</li>\n<li>DELETE 方法用于删除 URL 所标识的资源。</li>\n</ul>\n</li>\n<li>响应报文<ul>\n<li>第一行是状态行。包含 HTTP 版本，状态码和状态描述</li>\n<li>接下来每一行都表示一个 HTTP 首部，为客户端提供关于所发送数据的一些信息，并以一个空行结束</li>\n<li>最后是数据块，包含了响应数据</li>\n<li>200 OK 表示请求成功</li>\n<li>302 Found 临时重定向</li>\n<li>404 Not Found 请求失败，所请求的资源未在服务器上找到</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>HTTPS<ul>\n<li>运行在 SSL 上，添加了加密和认证机制，更加安全。</li>\n<li>通信需要证书，一般是向证书颁发机构购买。证书就是一个公钥和一个私钥。</li>\n<li>首先建立 TCP 连接。然后客户端向服务器发送客户端支持的一套加密规则</li>\n<li>服务器从中选取出一组加密算法与 Hash 算法，并将自己的身份信息一证书的形式发回给浏览器。证书里包含了网站地址，加密公钥，和证书的颁发机构等信息。</li>\n<li>客户端验证服务器的合法性</li>\n<li>如果证书受信任，或者客户端接受了不受信任的证书，浏览器会生成一个随机密钥，并用服务器提供的公钥加密。使用 Hash 算法对握手消息进行摘要计算，并对摘要使用之前产生的随机密钥加密。然后，将加密后的随机密钥和摘要发给服务器。</li>\n<li>服务器用自己的私钥解开被加密的随机密钥，并用随机密钥解出被加密的 Hash 摘要，验证握手信息是否一致。如果一致，则服务器使用获得的随机密钥加密握手消息发给客户端。</li>\n<li>客户端解密并验证摘要，若一致，则握手结束，以后发送的数据都使用该随机密钥进行对称加密。</li>\n<li>证书公钥用于加密在握手过程中生成的随机密钥，随机密钥用于加密真正传输的数据，Hash 算法用于验证数据的完整性。</li>\n<li>对称加密，加密和解密使用同一个的密钥。</li>\n<li>非对称加密，需要两个密钥，公钥和私钥。使用公钥加密的内容用私钥才能解开。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>从输入 URL 到获得页面的过程<ul>\n<li>浏览器查询 DNS。浏览器自己的 DNS 缓存，本地 Host 文件，操作系统的 DNS 缓存，本地 DNS 服务器，递归查询或迭代查询</li>\n<li>浏览器获得 IP 地址后，向服务器建立 TCP 连接。</li>\n<li>TCP 连接建立后，浏览器向服务器发送 HTTP 请求。</li>\n<li>服务器响应 HTTP 请求。</li>\n<li>浏览器不断请求资源，最终渲染出整个页面。</li>\n</ul>\n</li>\n<li>计算机网络体系结构<ul>\n<li>原理的体系结构：应用层、传输层、网络层、数据链路层、物理层</li>\n<li>IOS 7 层结构：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</li>\n<li>TCP\\IP 4 层结构：应用层、传输层、网际层、网络接口层</li>\n</ul>\n</li>\n<li>应用层常见协议<ul>\n<li>FTP 文件传输协议 使用 TCP 21端口为控制端口，20端口是数据连接端口</li>\n<li>HTTP 超文本传输协议 80端口 </li>\n<li>HTTPS 加密的超文本传输协议 443 端口</li>\n<li>DNS 地址解析协议 53端口 使用 UDP</li>\n<li>STMP 发送邮件协议 客户端向邮件服务器发邮件，邮件服务器向邮件服务器发邮件 25端口 使用 TCP</li>\n<li>POP3 接收邮件协议 邮件服务器向客户端发邮件 110端口 使用 TCP</li>\n<li>TELNET 远程登录 23端口</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"操作系统基础\">操作系统基础<a href=\"2020/01/13/面试项目总结#操作系统基础\"></a></h1><h2 id=\"进程与线程的区别\">进程与线程的区别<a href=\"2020/01/13/面试项目总结#进程与线程的区别\"></a></h2><ul>\n<li>进程是系统进行资源分配和调度的基本单位，线程是 CUP 调度和分派的基本单位</li>\n<li>线程依赖于进程</li>\n<li>进程有自己的独立地址空间，同一进程的不同线程共享当前线程的地址空间</li>\n<li>线程基本上不拥有系统资源，只有一点在运行中必不可少的资源，比如自己的线程 ID、程序计数器、一组寄存器和栈。同一进程的不同线程共享该进程的系统资源，比内存，CUP，I/O 等。</li>\n<li>进程切换时开销大。因为操作系统要分配和回收资源。同一进程内的线程切换时开销小。</li>\n<li>线程间通信比较方便，因为同一进程下的线程共享全局变量等数据。进程间通信比较复杂，要通过 管道、信号量等方式。</li>\n<li>线程有两种实现方式：用户级线程和内核级线程。</li>\n<li>用户级线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。</li>\n<li>内核级线程，线程管理的所有工作由内核完成，应用程序没有线程管理的代码，只有一个到内核级线程的编程接口。</li>\n<li>多线程模型：多对一模型、一对一模型、多对多模型</li>\n<li>多对一模型：将多个用户级线程映射到一个内核级线程上，线程管理在用户空间完成。一个线程阻塞时，整个进程都阻塞。</li>\n<li>一对一模型：每个用户级线程都对应一个内核级线程。并发能力强。</li>\n<li>多对多模型：m 个用户级线程映射到 n 个内核级线程上，要求 n ≤ m<h2 id=\"进程间通信\"><a href=\"2020/01/13/面试项目总结#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h2></li>\n<li>共享存储<br>通信进程间共享一块可以直接访问的内存空间。通过对这块共享空间的读写操作来实现进程间的信息交换。对共享空间的读写需要用到 P、V 操作实现同步互斥。</li>\n<li>消息传递<br>进程间的数据交换以格式化的消息为单位。进程间通过操作系统提供的发送消息和接受消息两个原语进行数据交换。<br>直接通信方式：发送进程直接把消息发给接收进程，并把消息挂在接收进程的消息缓冲队列上。<br>间接通信方式：发送进程把消息发到某个中间实体，接收进程从中间实体获得消息。</li>\n<li>管道通信<br>管道是连接一个读进程和一个写进程以实现他们之间通信的一个共享文件。写进程向管道写入数据，读进程从管道读出数据。数据被读出后就会被抛弃。管道是半双工通的，要向实现双向通信，则需要两个管道。<h2 id=\"进程间调度策略\"><a href=\"2020/01/13/面试项目总结#进程间调度策略\" class=\"headerlink\" title=\"进程间调度策略\"></a>进程间调度策略</h2></li>\n<li>先来先服务</li>\n<li>最短作业优先</li>\n<li>优先级调度算法<ul>\n<li>优先级反转问题<br>高优先级的进程等待被一个低优先级进程占用的资源时会出现优先级反转。</li>\n<li>解决方法<br>优先级继承：将低优先级进程的优先级提升到等待它所占有的资源的最高优先级进程的优先级。当高优先级进程由于等待资源而被阻塞时，此时资源的拥有者的优先级将会自动被提升。<br>优先级天花板：将申请某资源的进程的优先级提升到可能访问该资源的所有进程中最高优先级进程的优先级.(这个优先级称为该资源的优先级天花板) </li>\n</ul>\n</li>\n<li>高响应比优先调度算法</li>\n<li>时间片轮转</li>\n<li>多级反馈队列<h2 id=\"进程间同步\"><a href=\"2020/01/13/面试项目总结#进程间同步\" class=\"headerlink\" title=\"进程间同步\"></a>进程间同步</h2></li>\n<li>多道程序环境下，进程是并发执行的，但不同进程之前存在这制约关系，为了协调进程间的制约关系，引入了进程间同步。</li>\n<li>临近资源：一次仅允许一个进程使用的资源称为临界资源</li>\n<li>临界区：进程中访问临界资源的那段代码</li>\n<li>同步：为完成某种任务而建立的两个或多个进程，这些进程间因为需要在某些位置上协调他们工作次序而产生制约关系。</li>\n<li>互斥：当进程进入临界区使用临界资源时，另一个进程必须等待。</li>\n<li>同步机制的四个准则：空闲让进、忙则等待、有限等待、让权等待</li>\n<li>信号量机制：信号量机制使用两个原语 “P 操作” 和 “V 操作” 解决同步互斥问题。整型信号量和记录型信号量。</li>\n<li>管程：管程是由一组数据及定义在这组数据上的对这组数据的操作所组成的软件模块。</li>\n<li>管程的组成<ol>\n<li>局部于管程的共享数据结构，该组数据结构可以用于描述系统中的各种软件资源和硬件资源</li>\n<li>对该数据结构进行操作的一组方法</li>\n<li>对该数据结构设置初始值的语句</li>\n</ol>\n</li>\n<li>管程的特性<ol>\n<li>管程内的共享数据只能通过管程的方法操作</li>\n<li>每次只允许一个进程在管程内执行某个管程的方法<h2 id=\"文件系统\"><a href=\"2020/01/13/面试项目总结#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h2></li>\n</ol>\n</li>\n<li>文件目录<br>UNIX 的文件目录由文件名和指向文件对应的 inode 的指针组成。</li>\n<li>inode</li>\n</ul>\n<ol>\n<li>存放了文件控制文件所需要的各种基本信息。<ol>\n<li>文件基本信息<br>文件名、文件物理位置、文件的逻辑结构、文件的物理结构</li>\n<li>存取控制信息<br>文件存取权限</li>\n<li>使用信息<br>文件建立时间、修改时间等</li>\n</ol>\n</li>\n<li>还有文件用到的物理块的地址。</li>\n</ol>\n<ul>\n<li>文件的逻辑结构<ol>\n<li>流式文件。没有结构，将数据按顺序组织成记录并保存，以字节为单位。</li>\n<li>有结构文件。顺序文件、索引文件、索引顺序文件、散列文件</li>\n</ol>\n</li>\n<li>文件共享<br>基于索引节点的硬连接，利用符号链实现的软连接</li>\n<li>文件控制访问<br>为每个文件和目录设置一个访问控制表</li>\n<li>系统打开文件表</li>\n</ul>\n<h1 id=\"编译器文法分析模拟器\">编译器文法分析模拟器<a href=\"2020/01/13/面试项目总结#编译器文法分析模拟器\"></a></h1><ul>\n<li>简单介绍项目<br>项目是一个只有前端没有后端的静态化 Web 应用。项目通过可视化的方式，动态的展示了 LL(1) 文法的分析过程。项目主要是用来辅助老师教学。用户首先自定义一个上下文无关文法，然后通过消除文法中的左递归和提取左因子化简文法，简化的目的是尝试将用户自定义的上下文无关文法化简为 LL(1) 文法。计算化简后文法的 First 集合和 Follow 集合。通过 First 集合和 Follow 集合的信息判断当前文法是否属于 LL(1) 文法。如果是，则继续生成预测分析表，否则提醒用户去修改文法。</li>\n<li>为何选用 Nuxt.js 作为开发框架？<br>因为项目是一个没有后端的静态化 Web 应用，Nuxt.js 可以把基于 Vue.js 的应用生成对应的静态站点，所以就选用了 Nuxt.js。</li>\n<li>如何进行项目管理的？<br>使用华为云项目管理平台进行的项目管理。主要使用了平台的需求规划、迭代和测试管理这三个功能。代码使用 git-flow 进行版本控制。需求分析-用例归约描述-项目计划（项目开发计划和测试计划）-解决方案说明书-设计原型-编码-测试。小组成员每周开两次例会，写一次周报，借此来监控项目进度。</li>\n<li>项目技术细节？<br>项目使用了 Element-UI 组件库中的一些基础组件，也自定义了很多组件，比如 “计算 First 集合” 的组件、“计算 Follow 集合” 的组件。</li>\n<li>你做的工作？<br>实现四个功能。读取用户输入、检查并消除文法中的左递归（包括立即左递归和间接左递归）、计算文法的 First 集合并动态展示计算过程和判断文法是否属于 LL(1) 文法这四个功能。<ol>\n<li>读取用户输入<br>就是读取用户自定义的文法符号和产生式，然后将其转换为我们自定义的一个 grammar 对象。<br>2.1 检查并消除文法中的立即左递归<br>立即左递归很好检查与消除。<br>2.2 检查并消除文法中的间接左递归<br>间接左递归需要经过两步或两步以上的推导才能检测出来，有一些难度，这里使用了回溯法进行检测。</li>\n<li>计算 First 集合并动态展示计算过程<br>计算 First 集合有标准的算法，只要将其翻译为代码即可。这里的难点是动态展示计算过程。要求达到的效果是，用户点击下一步，界面上显示下一步的计算结果，以此帮助用户理解算法的运行过程。<br>解决方法是使用了 JavaScript 中的 Generator 函数，算法每进行一步就通过 yield 表达式返回当前算法状态并展示在前端界面上，然后返回 yield 表达式停下的地方继续执行算法。</li>\n<li>判断文法是否属于 LL(1) 文法<br>这里没有难度。有两条规则用于判断文法是否属于 LL(1) 文法。如果一个文法同时满足这两条规则，则属于 LL(1) 文法，否则不属于。</li>\n</ol>\n</li>\n<li>项目整体架构？<br>项目使用了单例模式，有一个单例对象 grammar，代表用户输入的文法。没有通过编码技巧保证全局只有一个 grammar 对象，只是要求大家在写代码时不可调用 grammar 的构造方法。。</li>\n</ul>\n<h1 id=\"内存数据库模型\">内存数据库模型<a href=\"2020/01/13/面试项目总结#内存数据库模型\"></a></h1><ul>\n<li><p>简单介绍<br>通过控制台读入 SQL 语句，对 SQL 进行解析，调用对应的方法。可以解析八种 SQL 语句。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">database</span> databasename</span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">database</span> databasename</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> tablename(column1,column2) <span class=\"keyword\">values</span> (value1,value2)</span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> tablename <span class=\"keyword\">where</span> <span class=\"keyword\">column</span>=<span class=\"keyword\">value</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> column1 <span class=\"keyword\">from</span> tablename <span class=\"keyword\">where</span> column2=<span class=\"keyword\">value</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> tablename <span class=\"keyword\">set</span> column1=value1, column2=value2 <span class=\"keyword\">where</span> column3=value3</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> tablename</span><br><span class=\"line\">(</span><br><span class=\"line\">\tcolume1 <span class=\"keyword\">type</span>,</span><br><span class=\"line\">\tcolumn2 <span class=\"keyword\">type</span>,</span><br><span class=\"line\">\tprimary <span class=\"keyword\">key</span>(column1)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> tablename</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p>SQL 语句解析过程</p>\n<ul>\n<li>首先从控制台读取 SQL 语句，让后词法分析器提取 SQL 语句中的 token 并传递给语法分析器，语法分析器获取 token 并分析 SQL 的语义，按照语义调用数据引擎的接口，实现 SQL 语句的执行。</li>\n<li>词法分析通过一个 scan 函数，一个字符一个字符的读取 SQL 语句。然后将读到的每一个词素，组成词法单元 token。有一个 Lexer 类实现词法分析。</li>\n<li>语法分析首先要获得一个词法分析器对象。然后不断调用词法分析对象的 scan 方法获取词法单元。然后通过一个 stmt 函数分析获得词法单元。其实就是一堆 switch 和 case，用 case 匹配预先定义好的 token-name。比如 CREATE、TABLE、DROP 等。然后调用 DBs 对象实现的方法来模拟 SQL 语句的功能。</li>\n<li>没有生成语法树，语义分析和语法分析放在一起了。或者说没有语法分析，只有语义分析。语义分析实现了类型检查。</li>\n<li>到语义分析就结束了。该编译器的功能就是把 SQL 语句翻译为 C++ 函数调用。。</li>\n</ul>\n</li>\n<li>数据库模拟<ul>\n<li>有一个 DBs 对象，该对象用来管理所有的数据库。它的属性是一个 vector 数组，数组里面的值是一个个 Database 对象。DBs 对象有所有的操作数据库的方法。SQL 语句分析结束后就是调用这里的方法来模拟执行 SQL 语句。</li>\n<li>一个 Database 对象表示一个数据库。它的属性值有一个 string 类型的数据库名，一个 int 类型的变量记录库中表的个数和一个 vector 数组存储数据库中的所有表。数组里面的值是一个个 Table 对象。还有一些操作表的方法。</li>\n<li>一个 Table 对象来表示一个数据库中的表。它的属性值有一个 string 类型的表名，两个 int 类型的变量分别记录表的行数和列数。两个 vector 数组，分别存储行和列。数组里面分别是 Column 对象和 Row 对象。还有一系列操作属性值的方法。</li>\n<li>一个 Column 对象，用来表示 Table 中的某一列。属性值有 bool 类型的主码标识，string 类型的列名，一个枚举类型的变量，表示列的数据类型，只做到了支持 varchar 类型。一个 bool 类型的变量，用于标识当前列是否允许为空。一个 int 类型的变量用于记录列值的长度。还有一些列操作属性的方法。</li>\n<li>一个 Row 对象，用于表示 Table 中的某一行。属性值只有一个 string 类型的数组，记录一行的内容。</li>\n<li>一个 Where 类，用于支持 where 语句，只有两个属性，一个 string 类型的列名，一个 string 类型的变量记录 where 语句中的值。</li>\n<li>create database 方法实现<ul>\n<li>创建一个数据库就是创建一个 Database 对象。。然后加入 DBs 对象的 vector 数组中。。</li>\n</ul>\n</li>\n<li>drop database 方法实现<ul>\n<li>就是将 DBs 对象的 vector 数组中对应的 Database 对象删除。。</li>\n</ul>\n</li>\n<li>insert 方法实现<ul>\n<li>通过 vector 的 push_back 方法实现的。。插入的时候先检查要插入行的主码是否与已经存在的行的主码相同。。</li>\n</ul>\n</li>\n<li>delete 方法实现<ul>\n<li>通过 vector 的 erase 方法实现的。。</li>\n</ul>\n</li>\n<li>select 方法实现<ul>\n<li>找到对应的数据库，找到对应的表，找到对应的行，然后将行显示出来。</li>\n</ul>\n</li>\n<li>update 方法实现<ul>\n<li>找到对应的数据库，找到对应的表，找到对应的行，然后将要修改的内容修改了。</li>\n</ul>\n</li>\n<li>create table 方法实现<ul>\n<li>先检查要创建的表是否存在，然后用 push_back 将新建的 Table 对象加入 Database 对象的记录 Table 的 vector 数组中。。</li>\n</ul>\n</li>\n<li>drop table 方法实现<ul>\n<li>先检查要创建的表是否存在，然后使用 erase 方法将要删除的表删除。。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>序列化<ul>\n<li>使用了 boost 库。</li>\n<li>之前提到的每一个类都有一个对应的结构，用来序列化。该结构的属性和对应的类的属性相同，有一个用来序列化的函数。</li>\n<li>首先将对象转换为对应的结构。然后再序列化。<h1 id=\"Linux-文件系统\"><a href=\"2020/01/13/面试项目总结#Linux-文件系统\" class=\"headerlink\" title=\"Linux 文件系统\"></a>Linux 文件系统</h1></li>\n</ul>\n</li>\n<li>简单介绍<br>二级文件系统有一个根目录，每个用户在根目录下创建自己的用户目录，用户可以在自己的用户目录下创建文件。使用 C++ 的文件操作函数，对文件进行读、写、删、查操作。</li>\n<li>文件系统结构<ul>\n<li>使用一个真正的文件夹模拟磁盘。该文件称为 file system。</li>\n<li>规定该文件系统最大 100KB，一个 block 的大小为 1KB，单个文件最大 1KB，系统的 inode 个数为 100。</li>\n<li>使用一个名为 superblock 的整数数组记录 inode 和 block 的使用情况。下标 1~100 记录 inode 的使用情况，101~200 记录 block 的使用情况。程序退出时，将该数组写入 file system 目录下的一个名为 superblock.bin 的文件。相当与使用位图管理磁盘空闲块。</li>\n<li>使用一个名为 account 的 map&lt;string,string&gt; 记录用户的帐号和密码。程序退出时，写入file system 目录下的一个名为 users.bin 的文件。</li>\n<li>使用一个名为 inode 的 map&lt;int,fileAttribute&gt; 记录 inode 结点。fileAttribute 记录了文件的基本属性。程序退出时，写入file system 目录下的一个名为 inode.bin 的文件。</li>\n<li>file system 文件夹下有一个 node 文件夹，里面存放 username.bin 文件，记录用户创建的文件名和文件对应的 inode number。相当于系统文件目录。程序启动时读入到一个名为 fileTable 的 map&lt;string,int&gt; 中。</li>\n<li>file system 文件夹下有一个 userfiles 文件夹，里面存放用户创建的文件，使用 inode number 命名。</li>\n</ul>\n</li>\n<li>方法实现<ul>\n<li>signIn 用户注册<br>就是简单的在 account 中添加一项。添加之前检查该用户是否已经存在。</li>\n<li>logIn 用户登陆<br>检查用户输入的帐号密码是否在 account 中。</li>\n<li>createFile 创建文件<br>找到一个空闲的 inode number，找到一个空闲的 block，然后在 userFiles 目录下创建文件，该文件以 inode number 命名。</li>\n<li>deleteFile 删除文件<br>在 fileTabe 中查找文件是否存在，找到了就删除，释放文件占用的 inode number 和 block。</li>\n<li>openFile 打开文件<br>在 fileTable 中查找文件是否存在，找到了就返回文件的 inode number。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"字节跳动-一面\">字节跳动 一面<a href=\"2020/01/13/面试项目总结#字节跳动-一面\"></a></h1><h2 id=\"经验\">经验<a href=\"2020/01/13/面试项目总结#经验\"></a></h2><ul>\n<li>复习知识点时要全面准确，一定要全面，因为面试官会根据你的回答向深处问！！</li>\n<li>不会的要说不会。</li>\n<li>算法要有一定的基础，LeetCode 的简单和中等难度的题要能解决。</li>\n<li>对面试官的问题有疑惑就直接问清楚。</li>\n<li>遇到不会的算法题，自己边想边说，面试官可能会给出一些指导。要回找话头。<h2 id=\"内容\"><a href=\"2020/01/13/面试项目总结#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h2></li>\n<li>自我介绍 就是把自己的简历复述一遍 说的时候有些紧张。。</li>\n<li>项目 编译器文法分析模拟器 <ul>\n<li>直接跳到了编译器有哪几部分，是怎么实现的</li>\n<li>一个可执行的二进制文件从打开到执行的步骤是怎样的（不会）</li>\n</ul>\n</li>\n<li>项目 内存数据库模型<ul>\n<li>解析 SQL 语句的编译器是怎样实现的</li>\n<li>数据库使用什么模拟的？STL 里面的 vector</li>\n<li>数据库事务的特征（不会，就答了一个原子性）</li>\n</ul>\n</li>\n<li>项目 二级文件系统<ul>\n<li>基本功能</li>\n<li>进程打开的第一个文件时，对应的文件描述符是什么（3）</li>\n<li>文件描述符是什么</li>\n<li>系统打开文件表里面存放什么东西（不会）</li>\n</ul>\n</li>\n<li>说一下 TCP 协议的三次握手和四次挥手</li>\n<li>在第四次挥手后为何要有 TIME_WAIT 状态</li>\n<li>如果有两个线程，同时修改一个变量 i，使 i 的值增加一，i 的初始值为 0，不加锁，i 会有几个可能结果。为什么会有这样的结果，怎么解决？</li>\n<li>信号量是怎么实现的？（硬件实现）怎么用硬件实现？实现在哪个硬件中？用什么硬件实现？</li>\n<li>C++ 语言细节<ul>\n<li>const 关键字的用途。（只答了修饰普通变量，指针，函数参数）</li>\n</ul>\n</li>\n<li>算法题：循环有序数组的二分查找、固定几个数字组成的下一个比当前数字大的数</li>\n<li>有啥问题想问面试官，最近在读什么书？</li>\n</ul>\n","next":{"title":"微信小程序开发","link":"2020/01/04/微信小程序开发"},"plink":"http://hespoon.github.io/2020/01/13/面试项目总结/","toc":[{"title":"余大佬的面试经验","id":"余大佬的面试经验","index":"1"},{"title":"计算机网络","id":"计算机网络","index":"2"},{"title":"操作系统基础","id":"操作系统基础","index":"3","children":[{"title":"进程与线程的区别","id":"进程与线程的区别","index":"3.1"},{"title":"","id":"进程间通信","index":"3.2"},{"title":"","id":"进程间调度策略","index":"3.3"},{"title":"","id":"进程间同步","index":"3.4"},{"title":"","id":"文件系统","index":"3.5"}]},{"title":"编译器文法分析模拟器","id":"编译器文法分析模拟器","index":"4"},{"title":"内存数据库模型","id":"内存数据库模型","index":"5"},{"title":"","id":"Linux-文件系统","index":"6"},{"title":"字节跳动 一面","id":"字节跳动-一面","index":"7","children":[{"title":"经验","id":"经验","index":"7.1"},{"title":"","id":"内容","index":"7.2"}]}],"copyright":{"author":"John Doe","link":"<a href=\"http://hespoon.github.io/2020/01/13/面试项目总结/\" title=\"面试项目总结\">http://hespoon.github.io/2020/01/13/面试项目总结/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}