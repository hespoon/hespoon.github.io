{"title":"常见链表操作","date":"2019-10-08T03:19:35.000Z","date_formatted":{"ll":"Oct 8, 2019","L":"10/08/2019","MM-DD":"10-08"},"link":"2019/10/08/常见链表操作","updated":"2020-01-17T10:42:17.822Z","content":"<html><head></head><body><blockquote>\n<p>链表节点定义</p>\n</blockquote>\n<figure class=\"highlight\"><div><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode *next;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> x) : val(x), next(<span class=\"literal\">NULL</span>) {}</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></div></figure>\n<h1 id=\"反转链表\"><a class=\"markdownIt-Anchor\" href=\"2019/10/08/常见链表操作#反转链表\"></a> 反转链表</h1>\n<ol>\n<li>递推法</li>\n</ol>\n<ul>\n<li>反转链表的迭代方式需要3个指针，pre，now，next</li>\n<li>更新指针时先更新 next 指针，用 now!=NULL 来控制循环，最后返回 pre 指针</li>\n</ul>\n<figure class=\"highlight\"><div><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 如果是空链表或者单链表，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>||head->next==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode *pre,*now,*next;</span><br><span class=\"line\">    pre=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    now=head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(now!=<span class=\"literal\">NULL</span>){</span><br><span class=\"line\">        next=now->next;</span><br><span class=\"line\">        now->next=pre;</span><br><span class=\"line\">        pre=now;</span><br><span class=\"line\">        now=next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></div></figure>\n<ol start=\"2\">\n<li>递归法</li>\n</ol>\n<ul>\n<li>递归函数返回值：反转后链表的头结点</li>\n<li>递归边界：当链表是空链表或只有一个节点时，不用翻转，直接返回当前节点。此条件同时是递归终止条件</li>\n<li>递归式：当反转 head 指针指向的的链表时，先递归反转 head->next 指向的链表，然后反转 head->next 节点，令 <code>head->next->next=head，head->next=NULL</code></li>\n</ul>\n<figure class=\"highlight\"><div><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>||head->next==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode *newHead=reverseList(head->next);</span><br><span class=\"line\">    head->next->next=head;</span><br><span class=\"line\">    head->next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></div></figure>\n<h1 id=\"判断链表中是否有环\"><a class=\"markdownIt-Anchor\" href=\"2019/10/08/常见链表操作#判断链表中是否有环\"></a> 判断链表中是否有环</h1>\n<ol>\n<li>双指针，一个快指针，一个慢指针</li>\n</ol>\n<ul>\n<li>试想，两个人在环形操场上跑步，一个跑的快，一个跑的慢，两着一定会在某一时刻相遇</li>\n<li>快指针一次向后移动两个位置，慢指针一次向后移动一个位置。两者进入链表的环形区域后，一定会相遇</li>\n</ul>\n<figure class=\"highlight\"><div><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>||head->next==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    ListNode *low,*fast;</span><br><span class=\"line\">    low=head;</span><br><span class=\"line\">    fast=head->next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast!=low){</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast==<span class=\"literal\">NULL</span>||fast->next==<span class=\"literal\">NULL</span>){</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        low=low->next;</span><br><span class=\"line\">        fast=fast->next->next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></div></figure>\n<ol start=\"2\">\n<li>哈希表</li>\n</ol>\n<ul>\n<li>用一个set容器，存放每个节点的地址，遍历链表的过程中检测当前节点的地址是否出现过</li>\n</ul>\n<figure class=\"highlight\"><div><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span>{</span><br><span class=\"line\">    <span class=\"built_in\">set</span><ListNode*> vis;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head!=<span class=\"literal\">NULL</span>){</span><br><span class=\"line\">        vis.insert(head);</span><br><span class=\"line\">        head=head->next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis.count(head)){</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></div></figure>\n<h1 id=\"合并两个有序链表\"><a class=\"markdownIt-Anchor\" href=\"2019/10/08/常见链表操作#合并两个有序链表\"></a> 合并两个有序链表</h1>\n<ol>\n<li>递推法</li>\n</ol>\n<ul>\n<li>将两个链表合并成一个带头链表，结点指针 head 指向带头链表的头结点。该头结点相当于一个哨兵节点。</li>\n<li>声明节点指针 pre 指向新添加到带头结点中的节点</li>\n</ul>\n<figure class=\"highlight\"><div><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class=\"line\">    ListNode *head=<span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>); <span class=\"comment\">// 哨兵节点</span></span><br><span class=\"line\">    ListNode *pre;</span><br><span class=\"line\">    pre=head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l1!=<span class=\"literal\">NULL</span>&&l2!=<span class=\"literal\">NULL</span>){</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1->val<=l2->val){</span><br><span class=\"line\">            pre->next=l1;</span><br><span class=\"line\">            l1=l1->next;</span><br><span class=\"line\">        }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">            pre->next=l2;</span><br><span class=\"line\">            l2=l2->next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        pre=pre->next;</span><br><span class=\"line\">    }   </span><br><span class=\"line\">    pre->next=l1!=<span class=\"literal\">NULL</span>?l1:l2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head->next;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></div></figure>\n<ol start=\"2\">\n<li>递归法</li>\n</ol>\n<ul>\n<li>递归函数返回值：合并后链表的头指针</li>\n<li>递归边界：如果某一链表是空链表，则返回另一链表的头指针</li>\n<li>递归式：两个链表头部较小的一个与剩下的元素合并</li>\n</ul>\n<figure class=\"highlight\"><div><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1==<span class=\"literal\">NULL</span>){</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">    }<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l2==<span class=\"literal\">NULL</span>){</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1->val<=l2->val){</span><br><span class=\"line\">        l1->next=mergeTwoLists(l1->next,l2);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">    }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">        l2->next=mergeTwoLists(l1,l2->next);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></div></figure>\n<h1 id=\"删除链表倒数第n个节点\"><a class=\"markdownIt-Anchor\" href=\"2019/10/08/常见链表操作#删除链表倒数第n个节点\"></a> 删除链表倒数第n个节点</h1>\n<ol>\n<li>\n<p>双指针</p>\n<p>使用两个指针，初始化时使两个指针相距为 n，然后同步移动，后面的指针指到链表尾时，前面的指针指向要删除的节点的前一个节点</p>\n</li>\n</ol>\n<ul>\n<li>不使用哨兵节点，此时如果要删除第一个节点要特判</li>\n</ul>\n<figure class=\"highlight\"><div><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>{</span><br><span class=\"line\">    ListNode *left,*right;</span><br><span class=\"line\">    left=right=head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i<n;i++){</span><br><span class=\"line\">        right=right->next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(right==<span class=\"literal\">NULL</span>){ <span class=\"comment\">// 此时删除第一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head->next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right->next!=<span class=\"literal\">NULL</span>){</span><br><span class=\"line\">        right=right->next;</span><br><span class=\"line\">        left=left->next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    left->next=left->next->next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></div></figure>\n<ul>\n<li>使用哨兵节点，此时删除第一个节点不需要特判，哨兵使得链表中的所有节点地位相同</li>\n</ul>\n<figure class=\"highlight\"><div><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>{</span><br><span class=\"line\">    ListNode *preHead=<span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>); <span class=\"comment\">// 哨兵节点</span></span><br><span class=\"line\">    preHead->next=head;</span><br><span class=\"line\">    ListNode *left,*right;</span><br><span class=\"line\">    left=right=preHead;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i<n;i++){</span><br><span class=\"line\">        right=right->next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right->next!=<span class=\"literal\">NULL</span>){</span><br><span class=\"line\">        right=right->next;</span><br><span class=\"line\">        left=left->next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    left->next=left->next->next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> preHead->next;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></div></figure>\n<h1 id=\"断链操作\"><a class=\"markdownIt-Anchor\" href=\"2019/10/08/常见链表操作#断链操作\"></a> 断链操作</h1>\n<ul>\n<li>cut(l,n) 将链表 l 切掉前 n 个结点，并返回后半部分的链表头。如果链表元素个数小于 n，则返回 NULL。</li>\n</ul>\n<figure class=\"highlight\"><div><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">cut</span><span class=\"params\">(ListNode *head,<span class=\"keyword\">int</span> n)</span></span>{</span><br><span class=\"line\">    ListNode *temp=head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(--n&&p){</span><br><span class=\"line\">        temp=temp->next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!temp) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    ListNode *ans=temp->next;</span><br><span class=\"line\">    temp->next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></div></figure>\n<h1 id=\"归并排序单链表-好神奇\"><a class=\"markdownIt-Anchor\" href=\"2019/10/08/常见链表操作#归并排序单链表-好神奇\"></a> 归并排序单链表 好神奇</h1>\n<ul>\n<li>排序一个链表，要求算法的事件复杂度为 O(logn) 空间复杂度为 O(1)</li>\n</ul>\n<figure class=\"highlight\"><div><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">margeSortList</span><span class=\"params\">(ListNode *head)</span></span>{</span><br><span class=\"line\">    ListNode* dummyHead=<span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>); <span class=\"comment\">// 一个临时头结点</span></span><br><span class=\"line\">    dummyHead->next=head;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len=<span class=\"number\">0</span>; <span class=\"comment\">// 记录排序链表的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head){</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">        head=head->next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// step 代表归并操作的步长，从 1 开始，每次都翻倍。step 就是部分有序链表的长度！step == n 时，代表整个链表都有序了</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> <span class=\"built_in\">step</span>=<span class=\"number\">1</span>;<span class=\"built_in\">step</span><=n;<span class=\"built_in\">step</span>*=<span class=\"number\">2</span>){</span><br><span class=\"line\">        ListNode *curr=dummyHead->next;</span><br><span class=\"line\">        ListNode *tail=dummyHead; <span class=\"comment\">// 记录部分有序链表的尾结点，初始时无部分有序链表</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curr){ <span class=\"comment\">// 按照步长开始合并，直到没有元素可合并为止</span></span><br><span class=\"line\">            ListNode *firstList=curr; <span class=\"comment\">// 指向第一个有序链表的指针</span></span><br><span class=\"line\">            ListNode *secondList=cut(curr,<span class=\"built_in\">step</span>); <span class=\"comment\">// 指向第二个部分有序链表的指针。同时将第一个部分有序链表切割出来。</span></span><br><span class=\"line\">            curr=cut(secondList,<span class=\"built_in\">step</span>); <span class=\"comment\">// 使 curr 指向剩余链表的第一个结点。同时将第二个部分有序链表切割出来。</span></span><br><span class=\"line\">            tail->next=mergeTwoLists(firstList,secondList); <span class=\"comment\">// 合并两个部分有序链表，将合并后的链表接在之前的部分有序链表的尾部。</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(tail->next) tail=tail->next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummyHead->next;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></div></figure>\n<ul>\n<li>时间复杂度分析<br>\n获取链表长度时间复杂度为 O(n)。<br>\n外层 for 循环共循环 logn 次，里层的 while 循环时间复杂度为 O(n)。<br>\n整个程序的时间复杂度为 O(nlogn)。</li>\n<li>空间复杂度分析<br>\n整个算法使用了 5 个 ListNode 指针，因此空间复杂度为常数 O(1)。</li>\n</ul>\n</body></html>","prev":{"title":"简单计算器","link":"2019/10/10/简单计算器"},"next":{"title":"C++双端队列","link":"2019/10/03/C-双端队列"},"plink":"http://hespoon.github.io/2019/10/08/常见链表操作/","toc":[{"title":"","id":"反转链表","index":"1"},{"title":"","id":"判断链表中是否有环","index":"2"},{"title":"","id":"合并两个有序链表","index":"3"},{"title":"","id":"删除链表倒数第n个节点","index":"4"},{"title":"","id":"断链操作","index":"5"},{"title":"","id":"归并排序单链表-好神奇","index":"6"}],"copyright":{"custom":"my copyright"}}