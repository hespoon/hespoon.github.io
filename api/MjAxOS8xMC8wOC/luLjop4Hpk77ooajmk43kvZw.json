{"title":"常见链表操作","date":"2019-10-08T03:19:35.000Z","date_formatted":{"ll":"Oct 8, 2019","L":"10/08/2019","MM-DD":"10-08"},"link":"2019/10/08/常见链表操作","updated":"2020-01-17T10:42:17.822Z","content":"<blockquote>\n<p>链表节点定义<br><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode *next;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> x) : val(x), next(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure></p>\n</blockquote>\n<h1 id=\"反转链表\">反转链表<a href=\"2019/10/08/常见链表操作#反转链表\"></a></h1><ol>\n<li>递推法</li>\n</ol>\n<ul>\n<li>反转链表的迭代方式需要3个指针，pre，now，next</li>\n<li>更新指针时先更新 next 指针，用 now!=NULL 来控制循环，最后返回 pre 指针<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是空链表或者单链表，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>||head-&gt;next==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode *pre,*now,*next;</span><br><span class=\"line\">    pre=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    now=head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(now!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        next=now-&gt;next;</span><br><span class=\"line\">        now-&gt;next=pre;</span><br><span class=\"line\">        pre=now;</span><br><span class=\"line\">        now=next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>递归法</li>\n</ol>\n<ul>\n<li>递归函数返回值：反转后链表的头结点</li>\n<li>递归边界：当链表是空链表或只有一个节点时，不用翻转，直接返回当前节点。此条件同时是递归终止条件</li>\n<li>递归式：当反转 head 指针指向的的链表时，先递归反转 head-&gt;next 指向的链表，然后反转 head-&gt;next 节点，令 <code>head-&gt;next-&gt;next=head，head-&gt;next=NULL</code><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>||head-&gt;next==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode *newHead=reverseList(head-&gt;next);</span><br><span class=\"line\">    head-&gt;next-&gt;next=head;</span><br><span class=\"line\">    head-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n</li>\n</ul>\n<h1 id=\"判断链表中是否有环\">判断链表中是否有环<a href=\"2019/10/08/常见链表操作#判断链表中是否有环\"></a></h1><ol>\n<li>双指针，一个快指针，一个慢指针</li>\n</ol>\n<ul>\n<li>试想，两个人在环形操场上跑步，一个跑的快，一个跑的慢，两着一定会在某一时刻相遇</li>\n<li>快指针一次向后移动两个位置，慢指针一次向后移动一个位置。两者进入链表的环形区域后，一定会相遇<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>||head-&gt;next==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    ListNode *low,*fast;</span><br><span class=\"line\">    low=head;</span><br><span class=\"line\">    fast=head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast!=low)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast==<span class=\"literal\">NULL</span>||fast-&gt;next==<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        low=low-&gt;next;</span><br><span class=\"line\">        fast=fast-&gt;next-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>哈希表</li>\n</ol>\n<ul>\n<li>用一个set容器，存放每个节点的地址，遍历链表的过程中检测当前节点的地址是否出现过<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;ListNode*&gt; vis;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        vis.insert(head);</span><br><span class=\"line\">        head=head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis.count(head))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n</li>\n</ul>\n<h1 id=\"合并两个有序链表\">合并两个有序链表<a href=\"2019/10/08/常见链表操作#合并两个有序链表\"></a></h1><ol>\n<li>递推法</li>\n</ol>\n<ul>\n<li>将两个链表合并成一个带头链表，结点指针 head 指向带头链表的头结点。该头结点相当于一个哨兵节点。</li>\n<li>声明节点指针 pre 指向新添加到带头结点中的节点<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">    ListNode *head=<span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>); <span class=\"comment\">// 哨兵节点</span></span><br><span class=\"line\">    ListNode *pre;</span><br><span class=\"line\">    pre=head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l1!=<span class=\"literal\">NULL</span>&amp;&amp;l2!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1-&gt;val&lt;=l2-&gt;val)&#123;</span><br><span class=\"line\">            pre-&gt;next=l1;</span><br><span class=\"line\">            l1=l1-&gt;next;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            pre-&gt;next=l2;</span><br><span class=\"line\">            l2=l2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre=pre-&gt;next;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    pre-&gt;next=l1!=<span class=\"literal\">NULL</span>?l1:l2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>递归法</li>\n</ol>\n<ul>\n<li>递归函数返回值：合并后链表的头指针</li>\n<li>递归边界：如果某一链表是空链表，则返回另一链表的头指针</li>\n<li>递归式：两个链表头部较小的一个与剩下的元素合并<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1==<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l2==<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1-&gt;val&lt;=l2-&gt;val)&#123;</span><br><span class=\"line\">        l1-&gt;next=mergeTwoLists(l1-&gt;next,l2);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        l2-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n</li>\n</ul>\n<h1 id=\"删除链表倒数第n个节点\">删除链表倒数第n个节点<a href=\"2019/10/08/常见链表操作#删除链表倒数第n个节点\"></a></h1><ol>\n<li><p>双指针</p>\n<p> 使用两个指针，初始化时使两个指针相距为 n，然后同步移动，后面的指针指到链表尾时，前面的指针指向要删除的节点的前一个节点</p>\n</li>\n</ol>\n<ul>\n<li><p>不使用哨兵节点，此时如果要删除第一个节点要特判</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    ListNode *left,*right;</span><br><span class=\"line\">    left=right=head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        right=right-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(right==<span class=\"literal\">NULL</span>)&#123; <span class=\"comment\">// 此时删除第一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right-&gt;next!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        right=right-&gt;next;</span><br><span class=\"line\">        left=left-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left-&gt;next=left-&gt;next-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p>使用哨兵节点，此时删除第一个节点不需要特判，哨兵使得链表中的所有节点地位相同</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    ListNode *preHead=<span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>); <span class=\"comment\">// 哨兵节点</span></span><br><span class=\"line\">    preHead-&gt;next=head;</span><br><span class=\"line\">    ListNode *left,*right;</span><br><span class=\"line\">    left=right=preHead;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        right=right-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right-&gt;next!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        right=right-&gt;next;</span><br><span class=\"line\">        left=left-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left-&gt;next=left-&gt;next-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> preHead-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n</li>\n</ul>\n<h1 id=\"断链操作\">断链操作<a href=\"2019/10/08/常见链表操作#断链操作\"></a></h1><ul>\n<li>cut(l,n) 将链表 l 切掉前 n 个结点，并返回后半部分的链表头。如果链表元素个数小于 n，则返回 NULL。<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">cut</span><span class=\"params\">(ListNode *head,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    ListNode *temp=head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(--n&amp;&amp;p)&#123;</span><br><span class=\"line\">        temp=temp-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!temp) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    ListNode *ans=temp-&gt;next;</span><br><span class=\"line\">    temp-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n</li>\n</ul>\n<h1 id=\"归并排序单链表-好神奇\">归并排序单链表 好神奇<a href=\"2019/10/08/常见链表操作#归并排序单链表-好神奇\"></a></h1><ul>\n<li><p>排序一个链表，要求算法的事件复杂度为 O(logn) 空间复杂度为 O(1)</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">margeSortList</span><span class=\"params\">(ListNode *head)</span></span>&#123;</span><br><span class=\"line\">    ListNode* dummyHead=<span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>); <span class=\"comment\">// 一个临时头结点</span></span><br><span class=\"line\">    dummyHead-&gt;next=head;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len=<span class=\"number\">0</span>; <span class=\"comment\">// 记录排序链表的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head)&#123;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">        head=head-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// step 代表归并操作的步长，从 1 开始，每次都翻倍。step 就是部分有序链表的长度！step == n 时，代表整个链表都有序了</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> step=<span class=\"number\">1</span>;step&lt;=n;step*=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        ListNode *curr=dummyHead-&gt;next;</span><br><span class=\"line\">        ListNode *tail=dummyHead; <span class=\"comment\">// 记录部分有序链表的尾结点，初始时无部分有序链表</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curr)&#123; <span class=\"comment\">// 按照步长开始合并，直到没有元素可合并为止</span></span><br><span class=\"line\">            ListNode *firstList=curr; <span class=\"comment\">// 指向第一个有序链表的指针</span></span><br><span class=\"line\">            ListNode *secondList=cut(curr,step); <span class=\"comment\">// 指向第二个部分有序链表的指针。同时将第一个部分有序链表切割出来。</span></span><br><span class=\"line\">            curr=cut(secondList,step); <span class=\"comment\">// 使 curr 指向剩余链表的第一个结点。同时将第二个部分有序链表切割出来。</span></span><br><span class=\"line\">            tail-&gt;next=mergeTwoLists(firstList,secondList); <span class=\"comment\">// 合并两个部分有序链表，将合并后的链表接在之前的部分有序链表的尾部。</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(tail-&gt;next) tail=tail-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummyHead-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p>时间复杂度分析<br>获取链表长度时间复杂度为 O(n)。<br>外层 for 循环共循环 logn 次，里层的 while 循环时间复杂度为 O(n)。<br>整个程序的时间复杂度为 O(nlogn)。</p>\n</li>\n<li>空间复杂度分析<br>整个算法使用了 5 个 ListNode 指针，因此空间复杂度为常数 O(1)。</li>\n</ul>\n","prev":{"title":"简单计算器","link":"2019/10/10/简单计算器"},"next":{"title":"C++双端队列","link":"2019/10/03/C-双端队列"},"plink":"http://hespoon.github.io/2019/10/08/常见链表操作/","toc":[{"title":"反转链表","id":"反转链表","index":"1"},{"title":"判断链表中是否有环","id":"判断链表中是否有环","index":"2"},{"title":"合并两个有序链表","id":"合并两个有序链表","index":"3"},{"title":"删除链表倒数第n个节点","id":"删除链表倒数第n个节点","index":"4"},{"title":"断链操作","id":"断链操作","index":"5"},{"title":"归并排序单链表 好神奇","id":"归并排序单链表-好神奇","index":"6"}],"copyright":{"author":"John Doe","link":"<a href=\"http://hespoon.github.io/2019/10/08/常见链表操作/\" title=\"常见链表操作\">http://hespoon.github.io/2019/10/08/常见链表操作/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}