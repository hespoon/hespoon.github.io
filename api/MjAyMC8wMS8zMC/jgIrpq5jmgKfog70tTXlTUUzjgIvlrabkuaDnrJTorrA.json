{"title":"《高性能 MySQL》学习笔记","date":"2020-01-30T12:36:55.000Z","date_formatted":{"ll":"Jan 30, 2020","L":"01/30/2020","MM-DD":"01-30"},"link":"2020/01/30/《高性能-MySQL》学习笔记","updated":"2020-01-30T12:40:40.415Z","content":"<html><head></head><body><h1 id=\"第一章\"><a href=\"2020/01/30/《高性能-MySQL》学习笔记#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><h2 id=\"事务的四种隔离级别\"><a href=\"2020/01/30/《高性能-MySQL》学习笔记#事务的四种隔离级别\" class=\"headerlink\" title=\"事务的四种隔离级别\"></a>事务的四种隔离级别</h2><ol>\n<li>Read Uncommitted<br>事务中的修改对其他事务可见。事务可读取未提交的数据，导致脏读。性能上不比其他隔离级别好太多。一般不使用。<br>脏读是指，事务读取了未提交的数据。</li>\n<li>Read Commit<br>大多数数据库系统的默认隔离级别。MySQL 不是。满足隔离性的定义。事务提交之前对其他事务不可见。也称为不可重复读 Nonrepeatable Read。<br>不可重复读是指，执行两次同样的查询，可能会得到不同的结果。</li>\n<li>Repeatable Read<br>无脏读问题。保证在同一个事务中，多次读取同样记录的结果是一致的。存在幻读问题。<br>幻读是指，一个事务 A 在读取某一范围内的数据后，另一事务 B 在该范围内插入了新数据，事务 A 再次读取该范围内的数据时，会产生幻行。InnoDB 和 XtraDB 通过多版本并发控制解决了幻读问题。<br>可重复读是 MySQL 的默认事务隔离级别。</li>\n<li>Serializable 可串行化<br>最高的隔离级别。强制事务串行处理。会在读取每一行数据时都加上锁，可能导致大量超时和锁争用问题。很少使用该级别。<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>是否会脏读</th>\n<th>是否会不可重复读</th>\n<th>是否会幻读</th>\n<th>读时是否加锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Read Uncommitted</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Read Commit</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Repeatable Read</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Serializable</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>SQL 关键字不区分大小写</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"死锁\"><a href=\"2020/01/30/《高性能-MySQL》学习笔记#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><ul>\n<li><p>死锁是指，两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p>\n</li>\n<li><p>InnoDB 目前处理死锁的方法是，将持有最少行级排他锁的事务回滚。</p>\n</li>\n<li><p>锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有的存储引擎会产生死锁，有的则不会。死锁产生有双重原因：真正的数据冲突和存储引擎的实现方式。</p>\n</li>\n<li><p>死锁产生后，只有部分或者完全回滚一个事务才能打破死锁。</p>\n</li>\n</ul>\n<h2 id=\"事务日志\"><a href=\"2020/01/30/《高性能-MySQL》学习笔记#事务日志\" class=\"headerlink\" title=\"事务日志\"></a>事务日志</h2><ul>\n<li>存储引擎在修改数据时，只需要修改内存拷贝，再把修改行为记录到持久在硬盘上的事务日志中，不用每次都将修改的数据持久到磁盘。</li>\n<li>事务日志采取追加的方式，写日志操作是在磁盘上一小块区域内的顺序 I/O。</li>\n<li>日志持久后，内存中被修改的数据可以在后台慢慢的刷回硬盘。这种方式被称为预写式日志，修改数据需要两次写磁盘。</li>\n</ul>\n<h2 id=\"两阶段锁协议\"><a href=\"2020/01/30/《高性能-MySQL》学习笔记#两阶段锁协议\" class=\"headerlink\" title=\"两阶段锁协议\"></a>两阶段锁协议</h2><ul>\n<li>在事务执行的过程中，随时都可以加锁。锁只有在执行 COMMIT 或者 ROLLBACK 时才会释放，并且所有的锁在同一时刻释放。InnoDB 会根据隔离级别在需要的时候自动加锁。</li>\n<li>两阶段锁协议是为了保证事务的隔离性。 </li>\n</ul>\n</body></html>","prev":{"title":"SQL 命令学习","link":"2020/01/30/SQL-命令学习"},"next":{"title":"JavaScript 学习","link":"2020/01/26/JavaScript-学习"},"plink":"http://hespoon.github.io/2020/01/30/《高性能-MySQL》学习笔记/","toc":[{"title":"","id":"第一章","index":"1","children":[{"title":"","id":"事务的四种隔离级别","index":"1.1"},{"title":"","id":"死锁","index":"1.2"},{"title":"","id":"事务日志","index":"1.3"},{"title":"","id":"两阶段锁协议","index":"1.4"}]}],"copyright":{"author":"John Doe","link":"<a href=\"http://hespoon.github.io/2020/01/30/《高性能-MySQL》学习笔记/\" title=\"《高性能 MySQL》学习笔记\">http://hespoon.github.io/2020/01/30/《高性能-MySQL》学习笔记/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}